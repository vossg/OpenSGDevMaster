/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class VTKMapper!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEVTKMAPPERINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGNode.h> // Root Class
#include <OSGNode.h> // GeoRoots Class
#include <OSGGeometry.h> // Geometries Class
#include <OSGChunkMaterial.h> // Materials Class
#include <OSGMaterialChunk.h> // MaterialChunks Class
#include <OSGGeoPnt3fProperty.h> // Positions Class
#include <OSGGeoUInt32Property.h> // Length Class
#include <OSGGeoUInt8Property.h> // Types Class
#include <OSGGeoColor4fProperty.h> // Colors Class
#include <OSGGeoVec3fProperty.h> // Normals Class

#include "OSGVTKMapperBase.h"
#include "OSGVTKMapper.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::VTKMapper
    
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var NodePtr         VTKMapperBase::_sfRoot
    
*/

/*! \var NodePtr         VTKMapperBase::_mfGeoRoots
    
*/

/*! \var GeometryPtr     VTKMapperBase::_mfGeometries
    
*/

/*! \var ChunkMaterialPtr VTKMapperBase::_mfMaterials
    
*/

/*! \var MaterialChunkPtr VTKMapperBase::_mfMaterialChunks
    
*/

/*! \var GeoPnt3fPropertyPtr VTKMapperBase::_mfPositions
    
*/

/*! \var GeoUInt32PropertyPtr VTKMapperBase::_mfLength
    
*/

/*! \var GeoUInt8PropertyPtr VTKMapperBase::_mfTypes
    
*/

/*! \var GeoColor4fPropertyPtr VTKMapperBase::_mfColors
    
*/

/*! \var GeoVec3fPropertyPtr VTKMapperBase::_mfNormals
    
*/


void VTKMapperBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFNodePtr::Description(
        SFNodePtr::getClassType(),
        "root",
        "",
        RootFieldId, RootFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getSFRoot));

    oType.addInitialDesc(pDesc);

    pDesc = new MFNodePtr::Description(
        MFNodePtr::getClassType(),
        "geoRoots",
        "",
        GeoRootsFieldId, GeoRootsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFGeoRoots));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeometryPtr::Description(
        MFGeometryPtr::getClassType(),
        "geometries",
        "",
        GeometriesFieldId, GeometriesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFGeometries));

    oType.addInitialDesc(pDesc);

    pDesc = new MFChunkMaterialPtr::Description(
        MFChunkMaterialPtr::getClassType(),
        "materials",
        "",
        MaterialsFieldId, MaterialsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFMaterials));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMaterialChunkPtr::Description(
        MFMaterialChunkPtr::getClassType(),
        "materialChunks",
        "",
        MaterialChunksFieldId, MaterialChunksFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFMaterialChunks));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoPnt3fPropertyPtr::Description(
        MFGeoPnt3fPropertyPtr::getClassType(),
        "positions",
        "",
        PositionsFieldId, PositionsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFPositions));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoUInt32PropertyPtr::Description(
        MFGeoUInt32PropertyPtr::getClassType(),
        "length",
        "",
        LengthFieldId, LengthFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFLength));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoUInt8PropertyPtr::Description(
        MFGeoUInt8PropertyPtr::getClassType(),
        "types",
        "",
        TypesFieldId, TypesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFTypes));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoColor4fPropertyPtr::Description(
        MFGeoColor4fPropertyPtr::getClassType(),
        "Colors",
        "",
        ColorsFieldId, ColorsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFColors));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoVec3fPropertyPtr::Description(
        MFGeoVec3fPropertyPtr::getClassType(),
        "normals",
        "",
        NormalsFieldId, NormalsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&VTKMapperBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&VTKMapperBase::getMFNormals));

    oType.addInitialDesc(pDesc);
}


VTKMapperBase::TypeObject VTKMapperBase::_type(true,
    VTKMapperBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &VTKMapperBase::createEmpty,
    VTKMapper::initMethod,
    (InitalInsertDescFunc) &VTKMapperBase::classDescInserter,
    false,
    "<?xml version=\"1.0\" ?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"VTKMapper\"\n"
    "\tparent=\"Group\"\n"
    "\tlibrary=\"Contrib\"\n"
    "\tstructure=\"concrete\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "        isNodeCore=\"true\"\n"
    ">\n"
    "\t<Field\n"
    "\t\tname=\"root\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"geoRoots\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"geometries\"\n"
    "\t\ttype=\"GeometryPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materials\"\n"
    "\t\ttype=\"ChunkMaterialPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialChunks\"\n"
    "\t\ttype=\"MaterialChunkPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"positions\"\n"
    "\t\ttype=\"GeoPnt3fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"length\"\n"
    "\t\ttype=\"GeoUInt32PropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"types\"\n"
    "\t\ttype=\"GeoUInt8PropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Colors\"\n"
    "\t\ttype=\"GeoColor4fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"normals\"\n"
    "\t\ttype=\"GeoVec3fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &VTKMapperBase::getType(void)
{
    return _type;
}

const FieldContainerType &VTKMapperBase::getType(void) const
{
    return _type;
}

UInt32 VTKMapperBase::getContainerSize(void) const
{
    return sizeof(VTKMapper);
}

/*------------------------- decorator get ------------------------------*/


//! Get the VTKMapper::_sfRoot field.
const SFNodePtr *VTKMapperBase::getSFRoot(void) const
{
    return &_sfRoot;
}

//! Get the VTKMapper::_mfGeoRoots field.
const MFNodePtr *VTKMapperBase::getMFGeoRoots(void) const
{
    return &_mfGeoRoots;
}

//! Get the VTKMapper::_mfGeometries field.
const MFGeometryPtr *VTKMapperBase::getMFGeometries(void) const
{
    return &_mfGeometries;
}

//! Get the VTKMapper::_mfMaterials field.
const MFChunkMaterialPtr *VTKMapperBase::getMFMaterials(void) const
{
    return &_mfMaterials;
}

//! Get the VTKMapper::_mfMaterialChunks field.
const MFMaterialChunkPtr *VTKMapperBase::getMFMaterialChunks(void) const
{
    return &_mfMaterialChunks;
}

//! Get the VTKMapper::_mfPositions field.
const MFGeoPnt3fPropertyPtr *VTKMapperBase::getMFPositions(void) const
{
    return &_mfPositions;
}

//! Get the VTKMapper::_mfLength field.
const MFGeoUInt32PropertyPtr *VTKMapperBase::getMFLength(void) const
{
    return &_mfLength;
}

//! Get the VTKMapper::_mfTypes field.
const MFGeoUInt8PropertyPtr *VTKMapperBase::getMFTypes(void) const
{
    return &_mfTypes;
}

//! Get the VTKMapper::_mfColors field.
const MFGeoColor4fPropertyPtr *VTKMapperBase::getMFColors(void) const
{
    return &_mfColors;
}

//! Get the VTKMapper::_mfNormals field.
const MFGeoVec3fPropertyPtr *VTKMapperBase::getMFNormals(void) const
{
    return &_mfNormals;
}


void VTKMapperBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == RootFieldId)
    {
        static_cast<VTKMapper *>(this)->setRoot(
            cast_dynamic<NodePtr>(pNewElement));
    }
    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToGeoRoots(
            cast_dynamic<NodePtr>(pNewElement));
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToGeometries(
            cast_dynamic<GeometryPtr>(pNewElement));
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToMaterials(
            cast_dynamic<ChunkMaterialPtr>(pNewElement));
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToMaterialChunks(
            cast_dynamic<MaterialChunkPtr>(pNewElement));
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToPositions(
            cast_dynamic<GeoPnt3fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToLength(
            cast_dynamic<GeoUInt32PropertyPtr>(pNewElement));
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToTypes(
            cast_dynamic<GeoUInt8PropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToColors(
            cast_dynamic<GeoColor4fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->pushToNormals(
            cast_dynamic<GeoVec3fPropertyPtr>(pNewElement));
    }
}

void VTKMapperBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoGeoRoots(
            uiIndex,
            cast_dynamic<NodePtr>(pNewElement));
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoGeometries(
            uiIndex,
            cast_dynamic<GeometryPtr>(pNewElement));
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoMaterials(
            uiIndex,
            cast_dynamic<ChunkMaterialPtr>(pNewElement));
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoMaterialChunks(
            uiIndex,
            cast_dynamic<MaterialChunkPtr>(pNewElement));
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoPositions(
            uiIndex,
            cast_dynamic<GeoPnt3fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoLength(
            uiIndex,
            cast_dynamic<GeoUInt32PropertyPtr>(pNewElement));
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoTypes(
            uiIndex,
            cast_dynamic<GeoUInt8PropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoColors(
            uiIndex,
            cast_dynamic<GeoColor4fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->insertIntoNormals(
            uiIndex,
            cast_dynamic<GeoVec3fPropertyPtr>(pNewElement));
    }
}

void VTKMapperBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInGeoRoots(
            uiIndex,
            cast_dynamic<NodePtr>(pNewElement));
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInGeometries(
            uiIndex,
            cast_dynamic<GeometryPtr>(pNewElement));
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInMaterials(
            uiIndex,
            cast_dynamic<ChunkMaterialPtr>(pNewElement));
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInMaterialChunks(
            uiIndex,
            cast_dynamic<MaterialChunkPtr>(pNewElement));
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInPositions(
            uiIndex,
            cast_dynamic<GeoPnt3fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInLength(
            uiIndex,
            cast_dynamic<GeoUInt32PropertyPtr>(pNewElement));
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInTypes(
            uiIndex,
            cast_dynamic<GeoUInt8PropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInColors(
            uiIndex,
            cast_dynamic<GeoColor4fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInNormals(
            uiIndex,
            cast_dynamic<GeoVec3fPropertyPtr>(pNewElement));
    }
}

void VTKMapperBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInGeoRoots(
            cast_dynamic<NodePtr>(pOldElement),
            cast_dynamic<NodePtr>(pNewElement));
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInGeometries(
            cast_dynamic<GeometryPtr>(pOldElement),
            cast_dynamic<GeometryPtr>(pNewElement));
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInMaterials(
            cast_dynamic<ChunkMaterialPtr>(pOldElement),
            cast_dynamic<ChunkMaterialPtr>(pNewElement));
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInMaterialChunks(
            cast_dynamic<MaterialChunkPtr>(pOldElement),
            cast_dynamic<MaterialChunkPtr>(pNewElement));
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInPositions(
            cast_dynamic<GeoPnt3fPropertyPtr>(pOldElement),
            cast_dynamic<GeoPnt3fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInLength(
            cast_dynamic<GeoUInt32PropertyPtr>(pOldElement),
            cast_dynamic<GeoUInt32PropertyPtr>(pNewElement));
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInTypes(
            cast_dynamic<GeoUInt8PropertyPtr>(pOldElement),
            cast_dynamic<GeoUInt8PropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInColors(
            cast_dynamic<GeoColor4fPropertyPtr>(pOldElement),
            cast_dynamic<GeoColor4fPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->replaceInNormals(
            cast_dynamic<GeoVec3fPropertyPtr>(pOldElement),
            cast_dynamic<GeoVec3fPropertyPtr>(pNewElement));
    }
}

void VTKMapperBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromGeoRoots(
            uiIndex);
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromGeometries(
            uiIndex);
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromMaterials(
            uiIndex);
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromMaterialChunks(
            uiIndex);
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromPositions(
            uiIndex);
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromLength(
            uiIndex);
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromTypes(
            uiIndex);
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromColors(
            uiIndex);
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromNormals(
            uiIndex);
    }
}

void VTKMapperBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromGeoRoots(
            cast_dynamic<NodePtr>(pElement));
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromGeometries(
            cast_dynamic<GeometryPtr>(pElement));
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromMaterials(
            cast_dynamic<ChunkMaterialPtr>(pElement));
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromMaterialChunks(
            cast_dynamic<MaterialChunkPtr>(pElement));
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromPositions(
            cast_dynamic<GeoPnt3fPropertyPtr>(pElement));
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromLength(
            cast_dynamic<GeoUInt32PropertyPtr>(pElement));
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromTypes(
            cast_dynamic<GeoUInt8PropertyPtr>(pElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromColors(
            cast_dynamic<GeoColor4fPropertyPtr>(pElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->removeFromNormals(
            cast_dynamic<GeoVec3fPropertyPtr>(pElement));
    }
}

void VTKMapperBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == RootFieldId)
    {
        static_cast<VTKMapper *>(this)->setRoot(NullFC);
    }
    if(uiFieldId == GeoRootsFieldId)
    {
        static_cast<VTKMapper *>(this)->clearGeoRoots();
    }
    if(uiFieldId == GeometriesFieldId)
    {
        static_cast<VTKMapper *>(this)->clearGeometries();
    }
    if(uiFieldId == MaterialsFieldId)
    {
        static_cast<VTKMapper *>(this)->clearMaterials();
    }
    if(uiFieldId == MaterialChunksFieldId)
    {
        static_cast<VTKMapper *>(this)->clearMaterialChunks();
    }
    if(uiFieldId == PositionsFieldId)
    {
        static_cast<VTKMapper *>(this)->clearPositions();
    }
    if(uiFieldId == LengthFieldId)
    {
        static_cast<VTKMapper *>(this)->clearLength();
    }
    if(uiFieldId == TypesFieldId)
    {
        static_cast<VTKMapper *>(this)->clearTypes();
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<VTKMapper *>(this)->clearColors();
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<VTKMapper *>(this)->clearNormals();
    }
}

void VTKMapperBase::pushToGeoRoots(NodePtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    addRef(value);

    _mfGeoRoots.push_back(value);
}

void VTKMapperBase::insertIntoGeoRoots(UInt32                uiIndex,
                                                   NodePtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfGeoRoots.insert(fieldIt, value);
}

void VTKMapperBase::replaceInGeoRoots(UInt32                uiIndex,
                                                       NodePtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfGeoRoots.size())
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    addRef(value);

    subRef(_mfGeoRoots[uiIndex]);

    _mfGeoRoots[uiIndex] = value;
}

void VTKMapperBase::replaceInGeoRoots(NodePtrConstArg pOldElem,
                                                        NodePtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfGeoRoots.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromGeoRoots(UInt32 uiIndex)
{
    if(uiIndex < _mfGeoRoots.size())
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfGeoRoots.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromGeoRoots(NodePtrConstArg value)
{
    Int32 iElemIdx = _mfGeoRoots.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfGeoRoots.erase(fieldIt);
    }
}
void VTKMapperBase::clearGeoRoots(void)
{
    editMField(GeoRootsFieldMask, _mfGeoRoots);

    MFNodePtr::iterator       fieldIt  = _mfGeoRoots.begin();
    MFNodePtr::const_iterator fieldEnd = _mfGeoRoots.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfGeoRoots.clear();
}

void VTKMapperBase::pushToGeometries(GeometryPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(GeometriesFieldMask, _mfGeometries);

    addRef(value);

    _mfGeometries.push_back(value);
}

void VTKMapperBase::insertIntoGeometries(UInt32                uiIndex,
                                                   GeometryPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(GeometriesFieldMask, _mfGeometries);

    MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfGeometries.insert(fieldIt, value);
}

void VTKMapperBase::replaceInGeometries(UInt32                uiIndex,
                                                       GeometryPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfGeometries.size())
        return;

    editMField(GeometriesFieldMask, _mfGeometries);

    addRef(value);

    subRef(_mfGeometries[uiIndex]);

    _mfGeometries[uiIndex] = value;
}

void VTKMapperBase::replaceInGeometries(GeometryPtrConstArg pOldElem,
                                                        GeometryPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfGeometries.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GeometriesFieldMask, _mfGeometries);

        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromGeometries(UInt32 uiIndex)
{
    if(uiIndex < _mfGeometries.size())
    {
        editMField(GeometriesFieldMask, _mfGeometries);

        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfGeometries.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromGeometries(GeometryPtrConstArg value)
{
    Int32 iElemIdx = _mfGeometries.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GeometriesFieldMask, _mfGeometries);

        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfGeometries.erase(fieldIt);
    }
}
void VTKMapperBase::clearGeometries(void)
{
    editMField(GeometriesFieldMask, _mfGeometries);

    MFGeometryPtr::iterator       fieldIt  = _mfGeometries.begin();
    MFGeometryPtr::const_iterator fieldEnd = _mfGeometries.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfGeometries.clear();
}

void VTKMapperBase::pushToMaterials(ChunkMaterialPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(MaterialsFieldMask, _mfMaterials);

    addRef(value);

    _mfMaterials.push_back(value);
}

void VTKMapperBase::insertIntoMaterials(UInt32                uiIndex,
                                                   ChunkMaterialPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(MaterialsFieldMask, _mfMaterials);

    MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfMaterials.insert(fieldIt, value);
}

void VTKMapperBase::replaceInMaterials(UInt32                uiIndex,
                                                       ChunkMaterialPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfMaterials.size())
        return;

    editMField(MaterialsFieldMask, _mfMaterials);

    addRef(value);

    subRef(_mfMaterials[uiIndex]);

    _mfMaterials[uiIndex] = value;
}

void VTKMapperBase::replaceInMaterials(ChunkMaterialPtrConstArg pOldElem,
                                                        ChunkMaterialPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfMaterials.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(MaterialsFieldMask, _mfMaterials);

        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromMaterials(UInt32 uiIndex)
{
    if(uiIndex < _mfMaterials.size())
    {
        editMField(MaterialsFieldMask, _mfMaterials);

        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfMaterials.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromMaterials(ChunkMaterialPtrConstArg value)
{
    Int32 iElemIdx = _mfMaterials.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(MaterialsFieldMask, _mfMaterials);

        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfMaterials.erase(fieldIt);
    }
}
void VTKMapperBase::clearMaterials(void)
{
    editMField(MaterialsFieldMask, _mfMaterials);

    MFChunkMaterialPtr::iterator       fieldIt  = _mfMaterials.begin();
    MFChunkMaterialPtr::const_iterator fieldEnd = _mfMaterials.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfMaterials.clear();
}

void VTKMapperBase::pushToMaterialChunks(MaterialChunkPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    addRef(value);

    _mfMaterialChunks.push_back(value);
}

void VTKMapperBase::insertIntoMaterialChunks(UInt32                uiIndex,
                                                   MaterialChunkPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfMaterialChunks.insert(fieldIt, value);
}

void VTKMapperBase::replaceInMaterialChunks(UInt32                uiIndex,
                                                       MaterialChunkPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfMaterialChunks.size())
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    addRef(value);

    subRef(_mfMaterialChunks[uiIndex]);

    _mfMaterialChunks[uiIndex] = value;
}

void VTKMapperBase::replaceInMaterialChunks(MaterialChunkPtrConstArg pOldElem,
                                                        MaterialChunkPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfMaterialChunks.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromMaterialChunks(UInt32 uiIndex)
{
    if(uiIndex < _mfMaterialChunks.size())
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfMaterialChunks.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromMaterialChunks(MaterialChunkPtrConstArg value)
{
    Int32 iElemIdx = _mfMaterialChunks.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfMaterialChunks.erase(fieldIt);
    }
}
void VTKMapperBase::clearMaterialChunks(void)
{
    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    MFMaterialChunkPtr::iterator       fieldIt  = _mfMaterialChunks.begin();
    MFMaterialChunkPtr::const_iterator fieldEnd = _mfMaterialChunks.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfMaterialChunks.clear();
}

void VTKMapperBase::pushToPositions(GeoPnt3fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(PositionsFieldMask, _mfPositions);

    addRef(value);

    _mfPositions.push_back(value);
}

void VTKMapperBase::insertIntoPositions(UInt32                uiIndex,
                                                   GeoPnt3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(PositionsFieldMask, _mfPositions);

    MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfPositions.insert(fieldIt, value);
}

void VTKMapperBase::replaceInPositions(UInt32                uiIndex,
                                                       GeoPnt3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfPositions.size())
        return;

    editMField(PositionsFieldMask, _mfPositions);

    addRef(value);

    subRef(_mfPositions[uiIndex]);

    _mfPositions[uiIndex] = value;
}

void VTKMapperBase::replaceInPositions(GeoPnt3fPropertyPtrConstArg pOldElem,
                                                        GeoPnt3fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfPositions.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PositionsFieldMask, _mfPositions);

        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromPositions(UInt32 uiIndex)
{
    if(uiIndex < _mfPositions.size())
    {
        editMField(PositionsFieldMask, _mfPositions);

        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfPositions.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromPositions(GeoPnt3fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfPositions.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PositionsFieldMask, _mfPositions);

        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfPositions.erase(fieldIt);
    }
}
void VTKMapperBase::clearPositions(void)
{
    editMField(PositionsFieldMask, _mfPositions);

    MFGeoPnt3fPropertyPtr::iterator       fieldIt  = _mfPositions.begin();
    MFGeoPnt3fPropertyPtr::const_iterator fieldEnd = _mfPositions.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfPositions.clear();
}

void VTKMapperBase::pushToLength(GeoUInt32PropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(LengthFieldMask, _mfLength);

    addRef(value);

    _mfLength.push_back(value);
}

void VTKMapperBase::insertIntoLength(UInt32                uiIndex,
                                                   GeoUInt32PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(LengthFieldMask, _mfLength);

    MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfLength.insert(fieldIt, value);
}

void VTKMapperBase::replaceInLength(UInt32                uiIndex,
                                                       GeoUInt32PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfLength.size())
        return;

    editMField(LengthFieldMask, _mfLength);

    addRef(value);

    subRef(_mfLength[uiIndex]);

    _mfLength[uiIndex] = value;
}

void VTKMapperBase::replaceInLength(GeoUInt32PropertyPtrConstArg pOldElem,
                                                        GeoUInt32PropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfLength.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(LengthFieldMask, _mfLength);

        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromLength(UInt32 uiIndex)
{
    if(uiIndex < _mfLength.size())
    {
        editMField(LengthFieldMask, _mfLength);

        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfLength.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromLength(GeoUInt32PropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfLength.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(LengthFieldMask, _mfLength);

        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfLength.erase(fieldIt);
    }
}
void VTKMapperBase::clearLength(void)
{
    editMField(LengthFieldMask, _mfLength);

    MFGeoUInt32PropertyPtr::iterator       fieldIt  = _mfLength.begin();
    MFGeoUInt32PropertyPtr::const_iterator fieldEnd = _mfLength.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfLength.clear();
}

void VTKMapperBase::pushToTypes(GeoUInt8PropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(TypesFieldMask, _mfTypes);

    addRef(value);

    _mfTypes.push_back(value);
}

void VTKMapperBase::insertIntoTypes(UInt32                uiIndex,
                                                   GeoUInt8PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(TypesFieldMask, _mfTypes);

    MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfTypes.insert(fieldIt, value);
}

void VTKMapperBase::replaceInTypes(UInt32                uiIndex,
                                                       GeoUInt8PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfTypes.size())
        return;

    editMField(TypesFieldMask, _mfTypes);

    addRef(value);

    subRef(_mfTypes[uiIndex]);

    _mfTypes[uiIndex] = value;
}

void VTKMapperBase::replaceInTypes(GeoUInt8PropertyPtrConstArg pOldElem,
                                                        GeoUInt8PropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfTypes.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(TypesFieldMask, _mfTypes);

        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromTypes(UInt32 uiIndex)
{
    if(uiIndex < _mfTypes.size())
    {
        editMField(TypesFieldMask, _mfTypes);

        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfTypes.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromTypes(GeoUInt8PropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfTypes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TypesFieldMask, _mfTypes);

        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfTypes.erase(fieldIt);
    }
}
void VTKMapperBase::clearTypes(void)
{
    editMField(TypesFieldMask, _mfTypes);

    MFGeoUInt8PropertyPtr::iterator       fieldIt  = _mfTypes.begin();
    MFGeoUInt8PropertyPtr::const_iterator fieldEnd = _mfTypes.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfTypes.clear();
}

void VTKMapperBase::pushToColors(GeoColor4fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(ColorsFieldMask, _mfColors);

    addRef(value);

    _mfColors.push_back(value);
}

void VTKMapperBase::insertIntoColors(UInt32                uiIndex,
                                                   GeoColor4fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(ColorsFieldMask, _mfColors);

    MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfColors.insert(fieldIt, value);
}

void VTKMapperBase::replaceInColors(UInt32                uiIndex,
                                                       GeoColor4fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfColors.size())
        return;

    editMField(ColorsFieldMask, _mfColors);

    addRef(value);

    subRef(_mfColors[uiIndex]);

    _mfColors[uiIndex] = value;
}

void VTKMapperBase::replaceInColors(GeoColor4fPropertyPtrConstArg pOldElem,
                                                        GeoColor4fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfColors.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(ColorsFieldMask, _mfColors);

        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromColors(UInt32 uiIndex)
{
    if(uiIndex < _mfColors.size())
    {
        editMField(ColorsFieldMask, _mfColors);

        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfColors.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromColors(GeoColor4fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfColors.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ColorsFieldMask, _mfColors);

        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfColors.erase(fieldIt);
    }
}
void VTKMapperBase::clearColors(void)
{
    editMField(ColorsFieldMask, _mfColors);

    MFGeoColor4fPropertyPtr::iterator       fieldIt  = _mfColors.begin();
    MFGeoColor4fPropertyPtr::const_iterator fieldEnd = _mfColors.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfColors.clear();
}

void VTKMapperBase::pushToNormals(GeoVec3fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(NormalsFieldMask, _mfNormals);

    addRef(value);

    _mfNormals.push_back(value);
}

void VTKMapperBase::insertIntoNormals(UInt32                uiIndex,
                                                   GeoVec3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(NormalsFieldMask, _mfNormals);

    MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfNormals.insert(fieldIt, value);
}

void VTKMapperBase::replaceInNormals(UInt32                uiIndex,
                                                       GeoVec3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfNormals.size())
        return;

    editMField(NormalsFieldMask, _mfNormals);

    addRef(value);

    subRef(_mfNormals[uiIndex]);

    _mfNormals[uiIndex] = value;
}

void VTKMapperBase::replaceInNormals(GeoVec3fPropertyPtrConstArg pOldElem,
                                                        GeoVec3fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfNormals.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(NormalsFieldMask, _mfNormals);

        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void VTKMapperBase::removeFromNormals(UInt32 uiIndex)
{
    if(uiIndex < _mfNormals.size())
    {
        editMField(NormalsFieldMask, _mfNormals);

        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfNormals.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromNormals(GeoVec3fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfNormals.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(NormalsFieldMask, _mfNormals);

        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfNormals.erase(fieldIt);
    }
}
void VTKMapperBase::clearNormals(void)
{
    editMField(NormalsFieldMask, _mfNormals);

    MFGeoVec3fPropertyPtr::iterator       fieldIt  = _mfNormals.begin();
    MFGeoVec3fPropertyPtr::const_iterator fieldEnd = _mfNormals.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfNormals.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 VTKMapperBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        returnValue += _sfRoot.getBinSize();
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        returnValue += _mfGeoRoots.getBinSize();
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        returnValue += _mfGeometries.getBinSize();
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        returnValue += _mfMaterials.getBinSize();
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        returnValue += _mfMaterialChunks.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _mfPositions.getBinSize();
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        returnValue += _mfLength.getBinSize();
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        returnValue += _mfTypes.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _mfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _mfNormals.getBinSize();
    }

    return returnValue;
}

void VTKMapperBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        _sfRoot.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        _mfGeoRoots.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        _mfGeometries.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        _mfMaterials.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        _mfMaterialChunks.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _mfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        _mfLength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _mfTypes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _mfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _mfNormals.copyToBin(pMem);
    }
}

void VTKMapperBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        _sfRoot.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        _mfGeoRoots.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        _mfGeometries.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        _mfMaterials.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        _mfMaterialChunks.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _mfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        _mfLength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _mfTypes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _mfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _mfNormals.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
VTKMapperPtr VTKMapperBase::createEmpty(void)
{
    VTKMapperPtr returnValue;

    newPtr<VTKMapper>(returnValue);

    return returnValue;
}

FieldContainerPtr VTKMapperBase::shallowCopy(void) const
{
    VTKMapperPtr returnValue;

    newPtr(returnValue, dynamic_cast<const VTKMapper *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

VTKMapperBase::VTKMapperBase(void) :
    Inherited(),
    _sfRoot                   (),
    _mfGeoRoots               (),
    _mfGeometries             (),
    _mfMaterials              (),
    _mfMaterialChunks         (),
    _mfPositions              (),
    _mfLength                 (),
    _mfTypes                  (),
    _mfColors                 (),
    _mfNormals                ()
{
}

VTKMapperBase::VTKMapperBase(const VTKMapperBase &source) :
    Inherited(source),
    _sfRoot                   (),
    _mfGeoRoots               (),
    _mfGeometries             (),
    _mfMaterials              (),
    _mfMaterialChunks         (),
    _mfPositions              (),
    _mfLength                 (),
    _mfTypes                  (),
    _mfColors                 (),
    _mfNormals                ()
{
}

/*-------------------------- destructors ----------------------------------*/

VTKMapperBase::~VTKMapperBase(void)
{
}

void VTKMapperBase::onCreate(const VTKMapper *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setRoot(source->getRoot());

        MFNodePtr::const_iterator GeoRootsIt  =
            source->_mfGeoRoots.begin();
        MFNodePtr::const_iterator GeoRootsEnd =
            source->_mfGeoRoots.end  ();

        while(GeoRootsIt != GeoRootsEnd)
        {
            this->pushToGeoRoots(*GeoRootsIt);

            ++GeoRootsIt;
        }

        MFGeometryPtr::const_iterator GeometriesIt  =
            source->_mfGeometries.begin();
        MFGeometryPtr::const_iterator GeometriesEnd =
            source->_mfGeometries.end  ();

        while(GeometriesIt != GeometriesEnd)
        {
            this->pushToGeometries(*GeometriesIt);

            ++GeometriesIt;
        }

        MFChunkMaterialPtr::const_iterator MaterialsIt  =
            source->_mfMaterials.begin();
        MFChunkMaterialPtr::const_iterator MaterialsEnd =
            source->_mfMaterials.end  ();

        while(MaterialsIt != MaterialsEnd)
        {
            this->pushToMaterials(*MaterialsIt);

            ++MaterialsIt;
        }

        MFMaterialChunkPtr::const_iterator MaterialChunksIt  =
            source->_mfMaterialChunks.begin();
        MFMaterialChunkPtr::const_iterator MaterialChunksEnd =
            source->_mfMaterialChunks.end  ();

        while(MaterialChunksIt != MaterialChunksEnd)
        {
            this->pushToMaterialChunks(*MaterialChunksIt);

            ++MaterialChunksIt;
        }

        MFGeoPnt3fPropertyPtr::const_iterator PositionsIt  =
            source->_mfPositions.begin();
        MFGeoPnt3fPropertyPtr::const_iterator PositionsEnd =
            source->_mfPositions.end  ();

        while(PositionsIt != PositionsEnd)
        {
            this->pushToPositions(*PositionsIt);

            ++PositionsIt;
        }

        MFGeoUInt32PropertyPtr::const_iterator LengthIt  =
            source->_mfLength.begin();
        MFGeoUInt32PropertyPtr::const_iterator LengthEnd =
            source->_mfLength.end  ();

        while(LengthIt != LengthEnd)
        {
            this->pushToLength(*LengthIt);

            ++LengthIt;
        }

        MFGeoUInt8PropertyPtr::const_iterator TypesIt  =
            source->_mfTypes.begin();
        MFGeoUInt8PropertyPtr::const_iterator TypesEnd =
            source->_mfTypes.end  ();

        while(TypesIt != TypesEnd)
        {
            this->pushToTypes(*TypesIt);

            ++TypesIt;
        }

        MFGeoColor4fPropertyPtr::const_iterator ColorsIt  =
            source->_mfColors.begin();
        MFGeoColor4fPropertyPtr::const_iterator ColorsEnd =
            source->_mfColors.end  ();

        while(ColorsIt != ColorsEnd)
        {
            this->pushToColors(*ColorsIt);

            ++ColorsIt;
        }

        MFGeoVec3fPropertyPtr::const_iterator NormalsIt  =
            source->_mfNormals.begin();
        MFGeoVec3fPropertyPtr::const_iterator NormalsEnd =
            source->_mfNormals.end  ();

        while(NormalsIt != NormalsEnd)
        {
            this->pushToNormals(*NormalsIt);

            ++NormalsIt;
        }
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void VTKMapperBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<VTKMapperBase *>(&oFrom),
                   whichField,
                   syncMode,
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void VTKMapperBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<VTKMapperBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void VTKMapperBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr VTKMapperBase::createAspectCopy(void) const
{
    VTKMapperPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const VTKMapper *>(this));

    return returnValue;
}
#endif

void VTKMapperBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<VTKMapper *>(this)->setRoot(NullFC);

    static_cast<VTKMapper *>(this)->clearGeoRoots();

    static_cast<VTKMapper *>(this)->clearGeometries();

    static_cast<VTKMapper *>(this)->clearMaterials();

    static_cast<VTKMapper *>(this)->clearMaterialChunks();

    static_cast<VTKMapper *>(this)->clearPositions();

    static_cast<VTKMapper *>(this)->clearLength();

    static_cast<VTKMapper *>(this)->clearTypes();

    static_cast<VTKMapper *>(this)->clearColors();

    static_cast<VTKMapper *>(this)->clearNormals();
}


OSG_END_NAMESPACE

#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<VTKMapperPtr>::_type("VTKMapperPtr", "GroupPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(VTKMapperPtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, VTKMapperPtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, VTKMapperPtr);


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGVTKMAPPERBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGVTKMAPPERBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGVTKMAPPERFIELDS_HEADER_CVSID;
}

OSG_END_NAMESPACE

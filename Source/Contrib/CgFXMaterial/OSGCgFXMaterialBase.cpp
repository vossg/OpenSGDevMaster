/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class CgFXMaterial!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#include "OSGConfig.h"



#include "OSGShaderProgramVariables.h"  // Variables Class
#include "OSGCgFXTechnique.h"           // Techniques Class
#include "OSGTextureObjChunk.h"         // Textures Class

#include "OSGCgFXMaterialBase.h"
#include "OSGCgFXMaterial.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::CgFXMaterial
    
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var bool            CgFXMaterialBase::_sfTreatTechniquesAsVariants
    effect compiler options
*/

/*! \var UInt8           CgFXMaterialBase::_sfParameterValueSource
    Source to use for parameters when initializing the material.
    DEFAULT: Uses the values that are read in from the .cgfx file or code string.
    Will overwrite the current value for the corresponding 
    ShaderProgramVariable if there is one.
    CURRENT: Checks if the material already has a ShaderProgramVariable of the same
    name, and if it does, it uses that value instead of the default value.
*/

/*! \var std::string     CgFXMaterialBase::_sfEffectFile
    cgfx file
*/

/*! \var std::string     CgFXMaterialBase::_sfEffectString
    cgfx file
*/

/*! \var std::string     CgFXMaterialBase::_mfCompilerOptions
    effect compiler options
*/

/*! \var ShaderProgramVariables * CgFXMaterialBase::_sfVariables
    
*/

/*! \var std::string     CgFXMaterialBase::_sfSelectedTechnique
    
*/

/*! \var UInt32          CgFXMaterialBase::_sfStateVariables
    
*/

/*! \var CgFXTechnique * CgFXMaterialBase::_mfTechniques
    
*/

/*! \var TextureObjChunk * CgFXMaterialBase::_mfTextures
    
*/

/*! \var GLenum          CgFXMaterialBase::_sfGLId
    The OpenGL texture id for this texture.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<CgFXMaterial *, nsOSG>::_type(
    "CgFXMaterialPtr", 
    "VariantMaterialPtr", 
    CgFXMaterial::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(CgFXMaterial *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           CgFXMaterial *,
                           nsOSG);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           CgFXMaterial *,
                           nsOSG);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void CgFXMaterialBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "treatTechniquesAsVariants",
        "effect compiler options\n",
        TreatTechniquesAsVariantsFieldId, TreatTechniquesAsVariantsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleTreatTechniquesAsVariants),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleTreatTechniquesAsVariants));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt8::Description(
        SFUInt8::getClassType(),
        "ParameterValueSource",
        "Source to use for parameters when initializing the material.\n"
        "DEFAULT: Uses the values that are read in from the .cgfx file or code string.\n"
        "Will overwrite the current value for the corresponding \n"
        "ShaderProgramVariable if there is one.\n"
        "CURRENT: Checks if the material already has a ShaderProgramVariable of the same\n"
        "name, and if it does, it uses that value instead of the default value.\n",
        ParameterValueSourceFieldId, ParameterValueSourceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleParameterValueSource),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleParameterValueSource));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "effectFile",
        "cgfx file\n",
        EffectFileFieldId, EffectFileFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleEffectFile),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleEffectFile));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "effectString",
        "cgfx file\n",
        EffectStringFieldId, EffectStringFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleEffectString),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleEffectString));

    oType.addInitialDesc(pDesc);

    pDesc = new MFString::Description(
        MFString::getClassType(),
        "compilerOptions",
        "effect compiler options\n",
        CompilerOptionsFieldId, CompilerOptionsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleCompilerOptions),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleCompilerOptions));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildShaderProgramVariablesPtr::Description(
        SFUnrecChildShaderProgramVariablesPtr::getClassType(),
        "variables",
        "",
        VariablesFieldId, VariablesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleVariables),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleVariables));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "selectedTechnique",
        "",
        SelectedTechniqueFieldId, SelectedTechniqueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleSelectedTechnique),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleSelectedTechnique));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "stateVariables",
        "",
        StateVariablesFieldId, StateVariablesFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleStateVariables),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleStateVariables));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecCgFXTechniquePtr::Description(
        MFUnrecCgFXTechniquePtr::getClassType(),
        "techniques",
        "",
        TechniquesFieldId, TechniquesFieldMask,
        true,
        (Field::FStdAccess | Field::FClusterLocal | Field::FThreadLocal),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleTechniques),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleTechniques));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecTextureObjChunkPtr::Description(
        MFUnrecTextureObjChunkPtr::getClassType(),
        "textures",
        "",
        TexturesFieldId, TexturesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleTextures),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleTextures));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "GLId",
        "The OpenGL texture id for this texture.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&CgFXMaterial::editHandleGLId),
        static_cast<FieldGetMethodSig >(&CgFXMaterial::getHandleGLId));

    oType.addInitialDesc(pDesc);
}


CgFXMaterialBase::TypeObject CgFXMaterialBase::_type(
    CgFXMaterialBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&CgFXMaterialBase::createEmptyLocal),
    CgFXMaterial::initMethod,
    CgFXMaterial::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&CgFXMaterial::classDescInserter),
    false,
    TreatTechniquesAsVariantsFieldMask | EffectStringFieldMask | EffectFileFieldMask,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"CgFXMaterial\"\n"
    "    parent=\"VariantMaterial\"\n"
    "    library=\"ContribCgFX\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    fieldsUnmarkedOnCreate=\"TreatTechniquesAsVariantsFieldMask\"\n"
    "    >\n"
    "    <Field\n"
    "        name=\"treatTechniquesAsVariants\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "        >\n"
    "\teffect compiler options\n"
    "  </Field>\n"
    "    <Field\n"
    "\t name=\"ParameterValueSource\"\n"
    "\t type=\"UInt8\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t defaultValue=\"CgFXMaterial::DEFAULT\"\n"
    "\t >\n"
    "\tSource to use for parameters when initializing the material.\n"
    "\tDEFAULT: Uses the values that are read in from the .cgfx file or code string.\n"
    "\t\t Will overwrite the current value for the corresponding \n"
    "\t\t ShaderProgramVariable if there is one.\n"
    "\tCURRENT: Checks if the material already has a ShaderProgramVariable of the same\n"
    "\t\t name, and if it does, it uses that value instead of the default value.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"effectFile\"\n"
    "\t type=\"std::string\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tcgfx file\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"effectString\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\tcgfx file\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"compilerOptions\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\teffect compiler options\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"variables\"\n"
    "\t type=\"ShaderProgramVariables\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"protected\"\n"
    "\t category=\"childpointer\"\n"
    "\t childParentType=\"FieldContainer\"\n"
    "\t linkParentField=\"Parents\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"selectedTechnique\"\n"
    "\t type=\"std::string\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"protected\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"stateVariables\"\n"
    "\t type=\"UInt32\"\n"
    "\t category=\"data\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"internal\"\n"
    "\t access=\"protected\"\n"
    "\t defaultValue=\"0\"\n"
    "\t >\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"techniques\"\n"
    "\t type=\"CgFXTechnique\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"internal\"\n"
    "\t access=\"protected\"\n"
    "\t category=\"pointer\"\n"
    "\t fieldFlags=\"FClusterLocal, FThreadLocal\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"textures\"\n"
    "\t type=\"TextureObjChunk\"\n"
    "\t category=\"pointer\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"protected\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"GLId\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"internal\"\n"
    "\t access=\"public\"\n"
    "\t defaultValue=\"0\"\n"
    "     fieldFlags=\"FClusterLocal\"\n"
    "\t >\n"
    "    The OpenGL texture id for this texture.\n"
    "  </Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &CgFXMaterialBase::getType(void)
{
    return _type;
}

const FieldContainerType &CgFXMaterialBase::getType(void) const
{
    return _type;
}

UInt32 CgFXMaterialBase::getContainerSize(void) const
{
    return sizeof(CgFXMaterial);
}

/*------------------------- decorator get ------------------------------*/


SFBool *CgFXMaterialBase::editSFTreatTechniquesAsVariants(void)
{
    editSField(TreatTechniquesAsVariantsFieldMask);

    return &_sfTreatTechniquesAsVariants;
}

const SFBool *CgFXMaterialBase::getSFTreatTechniquesAsVariants(void) const
{
    return &_sfTreatTechniquesAsVariants;
}


SFUInt8 *CgFXMaterialBase::editSFParameterValueSource(void)
{
    editSField(ParameterValueSourceFieldMask);

    return &_sfParameterValueSource;
}

const SFUInt8 *CgFXMaterialBase::getSFParameterValueSource(void) const
{
    return &_sfParameterValueSource;
}


SFString *CgFXMaterialBase::editSFEffectFile(void)
{
    editSField(EffectFileFieldMask);

    return &_sfEffectFile;
}

const SFString *CgFXMaterialBase::getSFEffectFile(void) const
{
    return &_sfEffectFile;
}


SFString *CgFXMaterialBase::editSFEffectString(void)
{
    editSField(EffectStringFieldMask);

    return &_sfEffectString;
}

const SFString *CgFXMaterialBase::getSFEffectString(void) const
{
    return &_sfEffectString;
}


MFString *CgFXMaterialBase::editMFCompilerOptions(void)
{
    editMField(CompilerOptionsFieldMask, _mfCompilerOptions);

    return &_mfCompilerOptions;
}

const MFString *CgFXMaterialBase::getMFCompilerOptions(void) const
{
    return &_mfCompilerOptions;
}


//! Get the CgFXMaterial::_sfVariables field.
const SFUnrecChildShaderProgramVariablesPtr *CgFXMaterialBase::getSFVariables(void) const
{
    return &_sfVariables;
}

SFUnrecChildShaderProgramVariablesPtr *CgFXMaterialBase::editSFVariables      (void)
{
    editSField(VariablesFieldMask);

    return &_sfVariables;
}

SFString *CgFXMaterialBase::editSFSelectedTechnique(void)
{
    editSField(SelectedTechniqueFieldMask);

    return &_sfSelectedTechnique;
}

const SFString *CgFXMaterialBase::getSFSelectedTechnique(void) const
{
    return &_sfSelectedTechnique;
}


SFUInt32 *CgFXMaterialBase::editSFStateVariables(void)
{
    editSField(StateVariablesFieldMask);

    return &_sfStateVariables;
}

const SFUInt32 *CgFXMaterialBase::getSFStateVariables(void) const
{
    return &_sfStateVariables;
}


//! Get the CgFXMaterial::_mfTechniques field.
const MFUnrecCgFXTechniquePtr *CgFXMaterialBase::getMFTechniques(void) const
{
    return &_mfTechniques;
}

MFUnrecCgFXTechniquePtr *CgFXMaterialBase::editMFTechniques     (void)
{
    editMField(TechniquesFieldMask, _mfTechniques);

    return &_mfTechniques;
}

//! Get the CgFXMaterial::_mfTextures field.
const MFUnrecTextureObjChunkPtr *CgFXMaterialBase::getMFTextures(void) const
{
    return &_mfTextures;
}

MFUnrecTextureObjChunkPtr *CgFXMaterialBase::editMFTextures       (void)
{
    editMField(TexturesFieldMask, _mfTextures);

    return &_mfTextures;
}

SFGLenum *CgFXMaterialBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *CgFXMaterialBase::getSFGLId(void) const
{
    return &_sfGLId;
}




void CgFXMaterialBase::pushToTechniques(CgFXTechnique * const value)
{
    editMField(TechniquesFieldMask, _mfTechniques);

    _mfTechniques.push_back(value);
}

void CgFXMaterialBase::assignTechniques(const MFUnrecCgFXTechniquePtr &value)
{
    MFUnrecCgFXTechniquePtr::const_iterator elemIt  =
        value.begin();
    MFUnrecCgFXTechniquePtr::const_iterator elemEnd =
        value.end  ();

    static_cast<CgFXMaterial *>(this)->clearTechniques();

    while(elemIt != elemEnd)
    {
        this->pushToTechniques(*elemIt);

        ++elemIt;
    }
}

void CgFXMaterialBase::removeFromTechniques(UInt32 uiIndex)
{
    if(uiIndex < _mfTechniques.size())
    {
        editMField(TechniquesFieldMask, _mfTechniques);

        _mfTechniques.erase(uiIndex);
    }
}

void CgFXMaterialBase::removeObjFromTechniques(CgFXTechnique * const value)
{
    Int32 iElemIdx = _mfTechniques.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TechniquesFieldMask, _mfTechniques);

        _mfTechniques.erase(iElemIdx);
    }
}
void CgFXMaterialBase::clearTechniques(void)
{
    editMField(TechniquesFieldMask, _mfTechniques);


    _mfTechniques.clear();
}

void CgFXMaterialBase::pushToTextures(TextureObjChunk * const value)
{
    editMField(TexturesFieldMask, _mfTextures);

    _mfTextures.push_back(value);
}

void CgFXMaterialBase::assignTextures (const MFUnrecTextureObjChunkPtr &value)
{
    MFUnrecTextureObjChunkPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecTextureObjChunkPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<CgFXMaterial *>(this)->clearTextures();

    while(elemIt != elemEnd)
    {
        this->pushToTextures(*elemIt);

        ++elemIt;
    }
}

void CgFXMaterialBase::removeFromTextures(UInt32 uiIndex)
{
    if(uiIndex < _mfTextures.size())
    {
        editMField(TexturesFieldMask, _mfTextures);

        _mfTextures.erase(uiIndex);
    }
}

void CgFXMaterialBase::removeObjFromTextures(TextureObjChunk * const value)
{
    Int32 iElemIdx = _mfTextures.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TexturesFieldMask, _mfTextures);

        _mfTextures.erase(iElemIdx);
    }
}
void CgFXMaterialBase::clearTextures(void)
{
    editMField(TexturesFieldMask, _mfTextures);


    _mfTextures.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 CgFXMaterialBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TreatTechniquesAsVariantsFieldMask & whichField))
    {
        returnValue += _sfTreatTechniquesAsVariants.getBinSize();
    }
    if(FieldBits::NoField != (ParameterValueSourceFieldMask & whichField))
    {
        returnValue += _sfParameterValueSource.getBinSize();
    }
    if(FieldBits::NoField != (EffectFileFieldMask & whichField))
    {
        returnValue += _sfEffectFile.getBinSize();
    }
    if(FieldBits::NoField != (EffectStringFieldMask & whichField))
    {
        returnValue += _sfEffectString.getBinSize();
    }
    if(FieldBits::NoField != (CompilerOptionsFieldMask & whichField))
    {
        returnValue += _mfCompilerOptions.getBinSize();
    }
    if(FieldBits::NoField != (VariablesFieldMask & whichField))
    {
        returnValue += _sfVariables.getBinSize();
    }
    if(FieldBits::NoField != (SelectedTechniqueFieldMask & whichField))
    {
        returnValue += _sfSelectedTechnique.getBinSize();
    }
    if(FieldBits::NoField != (StateVariablesFieldMask & whichField))
    {
        returnValue += _sfStateVariables.getBinSize();
    }
    if(FieldBits::NoField != (TechniquesFieldMask & whichField))
    {
        returnValue += _mfTechniques.getBinSize();
    }
    if(FieldBits::NoField != (TexturesFieldMask & whichField))
    {
        returnValue += _mfTextures.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }

    return returnValue;
}

void CgFXMaterialBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TreatTechniquesAsVariantsFieldMask & whichField))
    {
        _sfTreatTechniquesAsVariants.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ParameterValueSourceFieldMask & whichField))
    {
        _sfParameterValueSource.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EffectFileFieldMask & whichField))
    {
        _sfEffectFile.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EffectStringFieldMask & whichField))
    {
        _sfEffectString.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompilerOptionsFieldMask & whichField))
    {
        _mfCompilerOptions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (VariablesFieldMask & whichField))
    {
        _sfVariables.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SelectedTechniqueFieldMask & whichField))
    {
        _sfSelectedTechnique.copyToBin(pMem);
    }
    if(FieldBits::NoField != (StateVariablesFieldMask & whichField))
    {
        _sfStateVariables.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TechniquesFieldMask & whichField))
    {
        _mfTechniques.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TexturesFieldMask & whichField))
    {
        _mfTextures.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
}

void CgFXMaterialBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TreatTechniquesAsVariantsFieldMask & whichField))
    {
        editSField(TreatTechniquesAsVariantsFieldMask);
        _sfTreatTechniquesAsVariants.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ParameterValueSourceFieldMask & whichField))
    {
        editSField(ParameterValueSourceFieldMask);
        _sfParameterValueSource.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EffectFileFieldMask & whichField))
    {
        editSField(EffectFileFieldMask);
        _sfEffectFile.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EffectStringFieldMask & whichField))
    {
        editSField(EffectStringFieldMask);
        _sfEffectString.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompilerOptionsFieldMask & whichField))
    {
        editMField(CompilerOptionsFieldMask, _mfCompilerOptions);
        _mfCompilerOptions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (VariablesFieldMask & whichField))
    {
        editSField(VariablesFieldMask);
        _sfVariables.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SelectedTechniqueFieldMask & whichField))
    {
        editSField(SelectedTechniqueFieldMask);
        _sfSelectedTechnique.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (StateVariablesFieldMask & whichField))
    {
        editSField(StateVariablesFieldMask);
        _sfStateVariables.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TechniquesFieldMask & whichField))
    {
        editMField(TechniquesFieldMask, _mfTechniques);
        _mfTechniques.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TexturesFieldMask & whichField))
    {
        editMField(TexturesFieldMask, _mfTextures);
        _mfTextures.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        editSField(GLIdFieldMask);
        _sfGLId.copyFromBin(pMem);
    }
}

//! create a new instance of the class
CgFXMaterialTransitPtr CgFXMaterialBase::createLocal(BitVector bFlags)
{
    CgFXMaterialTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<CgFXMaterial>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
CgFXMaterialTransitPtr CgFXMaterialBase::createDependent(BitVector bFlags)
{
    CgFXMaterialTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<CgFXMaterial>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
CgFXMaterialTransitPtr CgFXMaterialBase::create(void)
{
    CgFXMaterialTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<CgFXMaterial>(tmpPtr);
    }

    return fc;
}

CgFXMaterial *CgFXMaterialBase::createEmptyLocal(BitVector bFlags)
{
    CgFXMaterial *returnValue;

    newPtr<CgFXMaterial>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
CgFXMaterial *CgFXMaterialBase::createEmpty(void)
{
    CgFXMaterial *returnValue;

    newPtr<CgFXMaterial>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}

FieldContainerTransitPtr CgFXMaterialBase::shallowCopyLocal(
    BitVector bFlags) const
{
    CgFXMaterial *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const CgFXMaterial *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr CgFXMaterialBase::shallowCopyDependent(
    BitVector bFlags) const
{
    CgFXMaterial *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const CgFXMaterial *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr CgFXMaterialBase::shallowCopy(void) const
{
    CgFXMaterial *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const CgFXMaterial *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

CgFXMaterialBase::CgFXMaterialBase(void) :
    Inherited(),
    _sfTreatTechniquesAsVariants(bool(false)),
    _sfParameterValueSource   (UInt8(CgFXMaterial::DEFAULT)),
    _sfEffectFile             (),
    _sfEffectString           (),
    _mfCompilerOptions        (),
    _sfVariables              (this,
                          VariablesFieldId,
                          ShaderProgramVariables::ParentsFieldId),
    _sfSelectedTechnique      (),
    _sfStateVariables         (UInt32(0)),
    _mfTechniques             (),
    _mfTextures               (),
    _sfGLId                   (GLenum(0))
{
}

CgFXMaterialBase::CgFXMaterialBase(const CgFXMaterialBase &source) :
    Inherited(source),
    _sfTreatTechniquesAsVariants(source._sfTreatTechniquesAsVariants),
    _sfParameterValueSource   (source._sfParameterValueSource   ),
    _sfEffectFile             (source._sfEffectFile             ),
    _sfEffectString           (source._sfEffectString           ),
    _mfCompilerOptions        (source._mfCompilerOptions        ),
    _sfVariables              (this,
                          VariablesFieldId,
                          ShaderProgramVariables::ParentsFieldId),
    _sfSelectedTechnique      (source._sfSelectedTechnique      ),
    _sfStateVariables         (source._sfStateVariables         ),
    _mfTechniques             (),
    _mfTextures               (),
    _sfGLId                   (source._sfGLId                   )
{
}


/*-------------------------- destructors ----------------------------------*/

CgFXMaterialBase::~CgFXMaterialBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool CgFXMaterialBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == VariablesFieldId)
    {
        ShaderProgramVariables * pTypedChild =
            dynamic_cast<ShaderProgramVariables *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfVariables.getValue() == pTypedChild)
            {
                editSField(VariablesFieldMask);

                _sfVariables.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void CgFXMaterialBase::onCreate(const CgFXMaterial *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        CgFXMaterial *pThis = static_cast<CgFXMaterial *>(this);

        pThis->setVariables(source->getVariables());

        MFUnrecCgFXTechniquePtr::const_iterator TechniquesIt  =
            source->_mfTechniques.begin();
        MFUnrecCgFXTechniquePtr::const_iterator TechniquesEnd =
            source->_mfTechniques.end  ();

        while(TechniquesIt != TechniquesEnd)
        {
            pThis->pushToTechniques(*TechniquesIt);

            ++TechniquesIt;
        }

        MFUnrecTextureObjChunkPtr::const_iterator TexturesIt  =
            source->_mfTextures.begin();
        MFUnrecTextureObjChunkPtr::const_iterator TexturesEnd =
            source->_mfTextures.end  ();

        while(TexturesIt != TexturesEnd)
        {
            pThis->pushToTextures(*TexturesIt);

            ++TexturesIt;
        }
    }
}

GetFieldHandlePtr CgFXMaterialBase::getHandleTreatTechniquesAsVariants (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfTreatTechniquesAsVariants,
             this->getType().getFieldDesc(TreatTechniquesAsVariantsFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleTreatTechniquesAsVariants(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfTreatTechniquesAsVariants,
             this->getType().getFieldDesc(TreatTechniquesAsVariantsFieldId),
             this));


    editSField(TreatTechniquesAsVariantsFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleParameterValueSource (void) const
{
    SFUInt8::GetHandlePtr returnValue(
        new  SFUInt8::GetHandle(
             &_sfParameterValueSource,
             this->getType().getFieldDesc(ParameterValueSourceFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleParameterValueSource(void)
{
    SFUInt8::EditHandlePtr returnValue(
        new  SFUInt8::EditHandle(
             &_sfParameterValueSource,
             this->getType().getFieldDesc(ParameterValueSourceFieldId),
             this));


    editSField(ParameterValueSourceFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleEffectFile      (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfEffectFile,
             this->getType().getFieldDesc(EffectFileFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleEffectFile     (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfEffectFile,
             this->getType().getFieldDesc(EffectFileFieldId),
             this));


    editSField(EffectFileFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleEffectString    (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfEffectString,
             this->getType().getFieldDesc(EffectStringFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleEffectString   (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfEffectString,
             this->getType().getFieldDesc(EffectStringFieldId),
             this));


    editSField(EffectStringFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleCompilerOptions (void) const
{
    MFString::GetHandlePtr returnValue(
        new  MFString::GetHandle(
             &_mfCompilerOptions,
             this->getType().getFieldDesc(CompilerOptionsFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleCompilerOptions(void)
{
    MFString::EditHandlePtr returnValue(
        new  MFString::EditHandle(
             &_mfCompilerOptions,
             this->getType().getFieldDesc(CompilerOptionsFieldId),
             this));


    editMField(CompilerOptionsFieldMask, _mfCompilerOptions);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleVariables       (void) const
{
    SFUnrecChildShaderProgramVariablesPtr::GetHandlePtr returnValue(
        new  SFUnrecChildShaderProgramVariablesPtr::GetHandle(
             &_sfVariables,
             this->getType().getFieldDesc(VariablesFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleVariables      (void)
{
    SFUnrecChildShaderProgramVariablesPtr::EditHandlePtr returnValue(
        new  SFUnrecChildShaderProgramVariablesPtr::EditHandle(
             &_sfVariables,
             this->getType().getFieldDesc(VariablesFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&CgFXMaterial::setVariables,
                    static_cast<CgFXMaterial *>(this), _1));

    editSField(VariablesFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleSelectedTechnique (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfSelectedTechnique,
             this->getType().getFieldDesc(SelectedTechniqueFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleSelectedTechnique(void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfSelectedTechnique,
             this->getType().getFieldDesc(SelectedTechniqueFieldId),
             this));


    editSField(SelectedTechniqueFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleStateVariables  (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfStateVariables,
             this->getType().getFieldDesc(StateVariablesFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleStateVariables (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfStateVariables,
             this->getType().getFieldDesc(StateVariablesFieldId),
             this));


    editSField(StateVariablesFieldMask);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleTechniques      (void) const
{
    MFUnrecCgFXTechniquePtr::GetHandlePtr returnValue(
        new  MFUnrecCgFXTechniquePtr::GetHandle(
             &_mfTechniques,
             this->getType().getFieldDesc(TechniquesFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleTechniques     (void)
{
    MFUnrecCgFXTechniquePtr::EditHandlePtr returnValue(
        new  MFUnrecCgFXTechniquePtr::EditHandle(
             &_mfTechniques,
             this->getType().getFieldDesc(TechniquesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&CgFXMaterial::pushToTechniques,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&CgFXMaterial::removeFromTechniques,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&CgFXMaterial::removeObjFromTechniques,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&CgFXMaterial::clearTechniques,
                    static_cast<CgFXMaterial *>(this)));

    editMField(TechniquesFieldMask, _mfTechniques);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleTextures        (void) const
{
    MFUnrecTextureObjChunkPtr::GetHandlePtr returnValue(
        new  MFUnrecTextureObjChunkPtr::GetHandle(
             &_mfTextures,
             this->getType().getFieldDesc(TexturesFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleTextures       (void)
{
    MFUnrecTextureObjChunkPtr::EditHandlePtr returnValue(
        new  MFUnrecTextureObjChunkPtr::EditHandle(
             &_mfTextures,
             this->getType().getFieldDesc(TexturesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&CgFXMaterial::pushToTextures,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&CgFXMaterial::removeFromTextures,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&CgFXMaterial::removeObjFromTextures,
                    static_cast<CgFXMaterial *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&CgFXMaterial::clearTextures,
                    static_cast<CgFXMaterial *>(this)));

    editMField(TexturesFieldMask, _mfTextures);

    return returnValue;
}

GetFieldHandlePtr CgFXMaterialBase::getHandleGLId            (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             const_cast<CgFXMaterialBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr CgFXMaterialBase::editHandleGLId           (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             this));


    editSField(GLIdFieldMask);

    return returnValue;
}



#ifdef OSG_MT_CPTR_ASPECT
void CgFXMaterialBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    CgFXMaterial *pThis = static_cast<CgFXMaterial *>(this);

    pThis->execSync(static_cast<CgFXMaterial *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *CgFXMaterialBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    CgFXMaterial *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const CgFXMaterial *>(pRefAspect),
                  dynamic_cast<const CgFXMaterial *>(this));

    return returnValue;
}
#endif

void CgFXMaterialBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<CgFXMaterial *>(this)->setVariables(NULL);

    static_cast<CgFXMaterial *>(this)->clearTechniques();

    static_cast<CgFXMaterial *>(this)->clearTextures();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfCompilerOptions.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

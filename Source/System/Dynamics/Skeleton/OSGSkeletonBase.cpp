/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Skeleton!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGNode.h"                    // Roots Class
#include "OSGBaseSkeletonJoint.h"       // Joints Class

#include "OSGSkeletonBase.h"
#include "OSGSkeleton.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Skeleton
    A Skeleton is simply one (or multiple) node hierarchies that contain some
    SkeletonJoint cores.
    Traversal will jump to the roots (MFRoots) of these hierarchies and traverse
    them, updating the matrix for each joint (MFJointMatrices) in the process.
    A Skeleton assumes exclusive ownership of its joints, but the Skeleton itself
    may be shared.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Node *          SkeletonBase::_mfRoots
    The roots of the joint (or bone) hierarchies for the skeleton.
    There should be Nodes with SkeletonJoint cores in the pointed-to
    hierarchies.
*/

/*! \var BaseSkeletonJoint * SkeletonBase::_mfJoints
    The joints (or bones) of the skeleton. Sorted by their jointId.
    READ ONLY: You should never write to this field, Skeleton scans
    for joints whenever the set of roots is modified.
*/

/*! \var BaseSkeletonJoint * SkeletonBase::_mfParentJoints
    Stores the parent of each joint at the position of the childs jointId.
    In other words parentJoints[i] is the parent of the joint with
    jointId i (which is stored in joints[i]). If the joint has no parent
    NULL is stored instead.
    READ ONLY: You should never write to this field, Skeleton scans
    for joints whenever the set of roots is modified.
*/

/*! \var Matrix          SkeletonBase::_mfJointMatrices
    Matrices for all joints of the skeleton. Elements correspond to
    joints at the same index in _mfJoints.
    These matrices are absolute, not relative to the parent joint.
    READ ONLY: You should never write to this field, Skeleton updates
    it during the RenderActions traversal.
*/

/*! \var Matrix          SkeletonBase::_mfJointNormalMatrices
    Normal matrices for all joints of the skeleton (these are the inverse
    transpose of the jointMatrices). Elements correspond to
    joints at the same index in _mfJoints.
    These matrices are absolute, not relative to the parent joint.
    READ ONLY: You should never write to this field, Skeleton updates
    it during the RenderActions traversal.
*/

/*! \var bool            SkeletonBase::_sfUseInvBindMatrix
    Whether joints should use their SFInvBindMatrix when computing
    the jointMatrices/jointNormalMatrices.
    This is normally set automatically by a SkinnedGeometry as for
    debug rendering of the bones this must be false.
*/

/*! \var bool            SkeletonBase::_sfCalcNormalMatrices
    Whether jointNormalMatrices should be calculated when computing the
    jointMatrices.
*/

/*! \var OSGAny          SkeletonBase::_sfJointsChanged
    Used by the joints to efficiently notify the Skeleton that they have been
    modified and matrices need to be recalculated.
    If the trees starting at 'roots' contain for example Transform cores and
    you modify those without making changes to any SkeletonJoint cores you will
    have to call editJointsChanged() manually once per frame to force a
    recomputation of the joint matrices.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<Skeleton *, nsOSG>::_type(
    "SkeletonPtr", 
    "AttachmentContainerPtr", 
    Skeleton::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(Skeleton *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Skeleton *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Skeleton *,
                           nsOSG)

DataType &FieldTraits< Skeleton *, nsOSG + 1 >::getType(void)
{
    return FieldTraits<Skeleton *, nsOSG>::getType();
}


OSG_EXPORT_PTR_SFIELD(ChildPointerSField,
                      Skeleton *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


OSG_EXPORT_PTR_MFIELD(ChildPointerMField,
                      Skeleton *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


DataType &FieldTraits<Skeleton *, nsOSG + 2 >::getType(void)
{
    return FieldTraits<Skeleton *, nsOSG>::getType();
}


OSG_SFIELDTYPE_INST(ParentPointerSField,
                    Skeleton *,
                    NoRefCountPolicy,
                    nsOSG + 2);

OSG_FIELD_DLLEXPORT_DEF3(ParentPointerSField,
                         Skeleton *,
                         NoRefCountPolicy,
                         nsOSG + 2)


OSG_MFIELDTYPE_INST(ParentPointerMField,
                    Skeleton *,
                    NoRefCountPolicy,
                    2);

OSG_FIELD_DLLEXPORT_DEF3(ParentPointerMField,
                         Skeleton *,
                         NoRefCountPolicy,
                         2)


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SkeletonBase::classDescInserter(TypeObject &oType)
{
    Inherited::classDescInserter(oType);

    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "roots",
        "The roots of the joint (or bone) hierarchies for the skeleton.\n"
        "There should be Nodes with SkeletonJoint cores in the pointed-to\n"
        "hierarchies.\n",
        RootsFieldId, RootsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleRoots),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleRoots));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecChildBaseSkeletonJointPtr::Description(
        MFUnrecChildBaseSkeletonJointPtr::getClassType(),
        "joints",
        "The joints (or bones) of the skeleton. Sorted by their jointId.\n"
        "READ ONLY: You should never write to this field, Skeleton scans\n"
        "for joints whenever the set of roots is modified.\n",
        JointsFieldId, JointsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJoints),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJoints));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecBaseSkeletonJointPtr::Description(
        MFUnrecBaseSkeletonJointPtr::getClassType(),
        "parentJoints",
        "Stores the parent of each joint at the position of the childs jointId.\n"
        "In other words parentJoints[i] is the parent of the joint with\n"
        "jointId i (which is stored in joints[i]). If the joint has no parent\n"
        "NULL is stored instead.\n"
        "READ ONLY: You should never write to this field, Skeleton scans\n"
        "for joints whenever the set of roots is modified.\n",
        ParentJointsFieldId, ParentJointsFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleParentJoints),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleParentJoints));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "jointMatrices",
        "Matrices for all joints of the skeleton. Elements correspond to\n"
        "joints at the same index in _mfJoints.\n"
        "These matrices are absolute, not relative to the parent joint.\n"
        "READ ONLY: You should never write to this field, Skeleton updates\n"
        "it during the RenderActions traversal.\n",
        JointMatricesFieldId, JointMatricesFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJointMatrices),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJointMatrices));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "jointNormalMatrices",
        "Normal matrices for all joints of the skeleton (these are the inverse\n"
        "transpose of the jointMatrices). Elements correspond to\n"
        "joints at the same index in _mfJoints.\n"
        "These matrices are absolute, not relative to the parent joint.\n"
        "READ ONLY: You should never write to this field, Skeleton updates\n"
        "it during the RenderActions traversal.\n",
        JointNormalMatricesFieldId, JointNormalMatricesFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJointNormalMatrices),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJointNormalMatrices));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useInvBindMatrix",
        "Whether joints should use their SFInvBindMatrix when computing\n"
        "the jointMatrices/jointNormalMatrices.\n"
        "This is normally set automatically by a SkinnedGeometry as for\n"
        "debug rendering of the bones this must be false.\n",
        UseInvBindMatrixFieldId, UseInvBindMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleUseInvBindMatrix),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleUseInvBindMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "calcNormalMatrices",
        "Whether jointNormalMatrices should be calculated when computing the\n"
        "jointMatrices.\n",
        CalcNormalMatricesFieldId, CalcNormalMatricesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleCalcNormalMatrices),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleCalcNormalMatrices));

    oType.addInitialDesc(pDesc);

    pDesc = new SFOSGAny::Description(
        SFOSGAny::getClassType(),
        "jointsChanged",
        "Used by the joints to efficiently notify the Skeleton that they have been\n"
        "modified and matrices need to be recalculated.\n"
        "If the trees starting at 'roots' contain for example Transform cores and\n"
        "you modify those without making changes to any SkeletonJoint cores you will\n"
        "have to call editJointsChanged() manually once per frame to force a\n"
        "recomputation of the joint matrices.\n",
        JointsChangedFieldId, JointsChangedFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJointsChanged),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJointsChanged));

    oType.addInitialDesc(pDesc);
}


SkeletonBase::TypeObject SkeletonBase::_type(
    SkeletonBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&SkeletonBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&Skeleton::initMethod),
    reinterpret_cast<ExitContainerF>(&Skeleton::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&Skeleton::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"Skeleton\"\n"
    "   parent=\"AttachmentContainer\"\n"
    "   mixinparent=\"SkeletonParent\"\n"
    "   library=\"Dynamics\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   childFields=\"both\"\n"
    "   parentFields=\"both\"\n"
    ">\n"
    "  A Skeleton is simply one (or multiple) node hierarchies that contain some\n"
    "  SkeletonJoint cores.\n"
    "  Traversal will jump to the roots (MFRoots) of these hierarchies and traverse\n"
    "  them, updating the matrix for each joint (MFJointMatrices) in the process.\n"
    "  A Skeleton assumes exclusive ownership of its joints, but the Skeleton itself\n"
    "  may be shared.\n"
    "\n"
    "  <Field\n"
    "     name=\"roots\"\n"
    "     type=\"Node\"\n"
    "     category=\"pointer\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    The roots of the joint (or bone) hierarchies for the skeleton.\n"
    "    There should be Nodes with SkeletonJoint cores in the pointed-to\n"
    "    hierarchies.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"joints\"\n"
    "     type=\"BaseSkeletonJoint\"\n"
    "     category=\"childpointer\"\n"
    "     linkParentField=\"Skeleton\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    The joints (or bones) of the skeleton. Sorted by their jointId.\n"
    "    READ ONLY: You should never write to this field, Skeleton scans\n"
    "    for joints whenever the set of roots is modified.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"parentJoints\"\n"
    "     type=\"BaseSkeletonJoint\"\n"
    "     category=\"pointer\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    Stores the parent of each joint at the position of the childs jointId.\n"
    "    In other words parentJoints[i] is the parent of the joint with\n"
    "    jointId i (which is stored in joints[i]). If the joint has no parent\n"
    "    NULL is stored instead.\n"
    "    READ ONLY: You should never write to this field, Skeleton scans\n"
    "    for joints whenever the set of roots is modified.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"jointMatrices\"\n"
    "     type=\"Matrix\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    Matrices for all joints of the skeleton. Elements correspond to\n"
    "    joints at the same index in _mfJoints.\n"
    "    These matrices are absolute, not relative to the parent joint.\n"
    "    READ ONLY: You should never write to this field, Skeleton updates\n"
    "    it during the RenderActions traversal.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"jointNormalMatrices\"\n"
    "     type=\"Matrix\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    Normal matrices for all joints of the skeleton (these are the inverse\n"
    "    transpose of the jointMatrices). Elements correspond to\n"
    "    joints at the same index in _mfJoints.\n"
    "    These matrices are absolute, not relative to the parent joint.\n"
    "    READ ONLY: You should never write to this field, Skeleton updates\n"
    "    it during the RenderActions traversal.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"useInvBindMatrix\"\n"
    "     type=\"bool\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"single\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     defaultValue=\"true\"\n"
    "     >\n"
    "    Whether joints should use their SFInvBindMatrix when computing\n"
    "    the jointMatrices/jointNormalMatrices.\n"
    "    This is normally set automatically by a SkinnedGeometry as for\n"
    "    debug rendering of the bones this must be false.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"calcNormalMatrices\"\n"
    "     type=\"bool\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"single\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     defaultValue=\"false\"\n"
    "     >\n"
    "    Whether jointNormalMatrices should be calculated when computing the\n"
    "    jointMatrices.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"jointsChanged\"\n"
    "     type=\"OSGAny\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"single\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    Used by the joints to efficiently notify the Skeleton that they have been\n"
    "    modified and matrices need to be recalculated.\n"
    "    If the trees starting at 'roots' contain for example Transform cores and\n"
    "    you modify those without making changes to any SkeletonJoint cores you will\n"
    "    have to call editJointsChanged() manually once per frame to force a\n"
    "    recomputation of the joint matrices.\n"
    "  </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "A Skeleton is simply one (or multiple) node hierarchies that contain some\n"
    "SkeletonJoint cores.\n"
    "Traversal will jump to the roots (MFRoots) of these hierarchies and traverse\n"
    "them, updating the matrix for each joint (MFJointMatrices) in the process.\n"
    "A Skeleton assumes exclusive ownership of its joints, but the Skeleton itself\n"
    "may be shared.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SkeletonBase::getType(void)
{
    return _type;
}

const FieldContainerType &SkeletonBase::getType(void) const
{
    return _type;
}

UInt32 SkeletonBase::getContainerSize(void) const
{
    return sizeof(Skeleton);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Skeleton::_mfRoots field.
const MFUnrecNodePtr *SkeletonBase::getMFRoots(void) const
{
    return &_mfRoots;
}

MFUnrecNodePtr      *SkeletonBase::editMFRoots          (void)
{
    editMField(RootsFieldMask, _mfRoots);

    return &_mfRoots;
}
Node * SkeletonBase::getRoots(const UInt32 index) const
{
    return _mfRoots[index];
}

//! Get the Skeleton::_mfJoints field.
const MFUnrecChildBaseSkeletonJointPtr *SkeletonBase::getMFJoints(void) const
{
    return &_mfJoints;
}

MFUnrecChildBaseSkeletonJointPtr *SkeletonBase::editMFJoints         (void)
{
    editMField(JointsFieldMask, _mfJoints);

    return &_mfJoints;
}
BaseSkeletonJoint * SkeletonBase::getJoints(const UInt32 index) const
{
    return _mfJoints[index];
}

//! Get the Skeleton::_mfParentJoints field.
const MFUnrecBaseSkeletonJointPtr *SkeletonBase::getMFParentJoints(void) const
{
    return &_mfParentJoints;
}

MFUnrecBaseSkeletonJointPtr *SkeletonBase::editMFParentJoints   (void)
{
    editMField(ParentJointsFieldMask, _mfParentJoints);

    return &_mfParentJoints;
}
BaseSkeletonJoint * SkeletonBase::getParentJoints(const UInt32 index) const
{
    return _mfParentJoints[index];
}

MFMatrix *SkeletonBase::editMFJointMatrices(void)
{
    editMField(JointMatricesFieldMask, _mfJointMatrices);

    return &_mfJointMatrices;
}

const MFMatrix *SkeletonBase::getMFJointMatrices(void) const
{
    return &_mfJointMatrices;
}


MFMatrix *SkeletonBase::editMFJointNormalMatrices(void)
{
    editMField(JointNormalMatricesFieldMask, _mfJointNormalMatrices);

    return &_mfJointNormalMatrices;
}

const MFMatrix *SkeletonBase::getMFJointNormalMatrices(void) const
{
    return &_mfJointNormalMatrices;
}


SFBool *SkeletonBase::editSFUseInvBindMatrix(void)
{
    editSField(UseInvBindMatrixFieldMask);

    return &_sfUseInvBindMatrix;
}

const SFBool *SkeletonBase::getSFUseInvBindMatrix(void) const
{
    return &_sfUseInvBindMatrix;
}


SFBool *SkeletonBase::editSFCalcNormalMatrices(void)
{
    editSField(CalcNormalMatricesFieldMask);

    return &_sfCalcNormalMatrices;
}

const SFBool *SkeletonBase::getSFCalcNormalMatrices(void) const
{
    return &_sfCalcNormalMatrices;
}


SFOSGAny *SkeletonBase::editSFJointsChanged(void)
{
    editSField(JointsChangedFieldMask);

    return &_sfJointsChanged;
}

const SFOSGAny *SkeletonBase::getSFJointsChanged(void) const
{
    return &_sfJointsChanged;
}




void SkeletonBase::pushToRoots(Node * const value)
{
    editMField(RootsFieldMask, _mfRoots);

    _mfRoots.push_back(value);
}

void SkeletonBase::assignRoots    (const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<Skeleton *>(this)->clearRoots();

    while(elemIt != elemEnd)
    {
        this->pushToRoots(*elemIt);

        ++elemIt;
    }
}

void SkeletonBase::removeFromRoots(UInt32 uiIndex)
{
    if(uiIndex < _mfRoots.size())
    {
        editMField(RootsFieldMask, _mfRoots);

        _mfRoots.erase(uiIndex);
    }
}

void SkeletonBase::removeObjFromRoots(Node * const value)
{
    Int32 iElemIdx = _mfRoots.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(RootsFieldMask, _mfRoots);

        _mfRoots.erase(iElemIdx);
    }
}
void SkeletonBase::clearRoots(void)
{
    editMField(RootsFieldMask, _mfRoots);


    _mfRoots.clear();
}

void SkeletonBase::pushToJoints(BaseSkeletonJoint * const value)
{
    editMField(JointsFieldMask, _mfJoints);

    _mfJoints.push_back(value);
}

void SkeletonBase::assignJoints   (const MFUnrecChildBaseSkeletonJointPtr &value)
{
    MFUnrecChildBaseSkeletonJointPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecChildBaseSkeletonJointPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Skeleton *>(this)->clearJoints();

    while(elemIt != elemEnd)
    {
        this->pushToJoints(*elemIt);

        ++elemIt;
    }
}

void SkeletonBase::removeFromJoints(UInt32 uiIndex)
{
    if(uiIndex < _mfJoints.size())
    {
        editMField(JointsFieldMask, _mfJoints);

        _mfJoints.erase(uiIndex);
    }
}

void SkeletonBase::removeObjFromJoints(BaseSkeletonJoint * const value)
{
    Int32 iElemIdx = _mfJoints.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(JointsFieldMask, _mfJoints);

        _mfJoints.erase(iElemIdx);
    }
}
void SkeletonBase::clearJoints(void)
{
    editMField(JointsFieldMask, _mfJoints);


    _mfJoints.clear();
}

void SkeletonBase::pushToParentJoints(BaseSkeletonJoint * const value)
{
    editMField(ParentJointsFieldMask, _mfParentJoints);

    _mfParentJoints.push_back(value);
}

void SkeletonBase::assignParentJoints(const MFUnrecBaseSkeletonJointPtr &value)
{
    MFUnrecBaseSkeletonJointPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecBaseSkeletonJointPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Skeleton *>(this)->clearParentJoints();

    while(elemIt != elemEnd)
    {
        this->pushToParentJoints(*elemIt);

        ++elemIt;
    }
}

void SkeletonBase::removeFromParentJoints(UInt32 uiIndex)
{
    if(uiIndex < _mfParentJoints.size())
    {
        editMField(ParentJointsFieldMask, _mfParentJoints);

        _mfParentJoints.erase(uiIndex);
    }
}

void SkeletonBase::removeObjFromParentJoints(BaseSkeletonJoint * const value)
{
    Int32 iElemIdx = _mfParentJoints.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ParentJointsFieldMask, _mfParentJoints);

        _mfParentJoints.erase(iElemIdx);
    }
}
void SkeletonBase::clearParentJoints(void)
{
    editMField(ParentJointsFieldMask, _mfParentJoints);


    _mfParentJoints.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT SkeletonBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (RootsFieldMask & whichField))
    {
        returnValue += _mfRoots.getBinSize();
    }
    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        returnValue += _mfJoints.getBinSize();
    }
    if(FieldBits::NoField != (ParentJointsFieldMask & whichField))
    {
        returnValue += _mfParentJoints.getBinSize();
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        returnValue += _mfJointMatrices.getBinSize();
    }
    if(FieldBits::NoField != (JointNormalMatricesFieldMask & whichField))
    {
        returnValue += _mfJointNormalMatrices.getBinSize();
    }
    if(FieldBits::NoField != (UseInvBindMatrixFieldMask & whichField))
    {
        returnValue += _sfUseInvBindMatrix.getBinSize();
    }
    if(FieldBits::NoField != (CalcNormalMatricesFieldMask & whichField))
    {
        returnValue += _sfCalcNormalMatrices.getBinSize();
    }
    if(FieldBits::NoField != (JointsChangedFieldMask & whichField))
    {
        returnValue += _sfJointsChanged.getBinSize();
    }

    return returnValue;
}

void SkeletonBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (RootsFieldMask & whichField))
    {
        _mfRoots.copyToBin(pMem);
    }
    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        _mfJoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ParentJointsFieldMask & whichField))
    {
        _mfParentJoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        _mfJointMatrices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (JointNormalMatricesFieldMask & whichField))
    {
        _mfJointNormalMatrices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseInvBindMatrixFieldMask & whichField))
    {
        _sfUseInvBindMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CalcNormalMatricesFieldMask & whichField))
    {
        _sfCalcNormalMatrices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (JointsChangedFieldMask & whichField))
    {
        _sfJointsChanged.copyToBin(pMem);
    }
}

void SkeletonBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (RootsFieldMask & whichField))
    {
        editMField(RootsFieldMask, _mfRoots);
        _mfRoots.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        editMField(JointsFieldMask, _mfJoints);
        _mfJoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ParentJointsFieldMask & whichField))
    {
        editMField(ParentJointsFieldMask, _mfParentJoints);
        _mfParentJoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        editMField(JointMatricesFieldMask, _mfJointMatrices);
        _mfJointMatrices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (JointNormalMatricesFieldMask & whichField))
    {
        editMField(JointNormalMatricesFieldMask, _mfJointNormalMatrices);
        _mfJointNormalMatrices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseInvBindMatrixFieldMask & whichField))
    {
        editSField(UseInvBindMatrixFieldMask);
        _sfUseInvBindMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CalcNormalMatricesFieldMask & whichField))
    {
        editSField(CalcNormalMatricesFieldMask);
        _sfCalcNormalMatrices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (JointsChangedFieldMask & whichField))
    {
        editSField(JointsChangedFieldMask);
        _sfJointsChanged.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SkeletonTransitPtr SkeletonBase::createLocal(BitVector bFlags)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SkeletonTransitPtr SkeletonBase::createDependent(BitVector bFlags)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SkeletonTransitPtr SkeletonBase::create(void)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

Skeleton *SkeletonBase::createEmptyLocal(BitVector bFlags)
{
    Skeleton *returnValue;

    newPtr<Skeleton>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Skeleton *SkeletonBase::createEmpty(void)
{
    Skeleton *returnValue;

    newPtr<Skeleton>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr SkeletonBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Skeleton *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Skeleton *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBase::shallowCopy(void) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Skeleton *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

SkeletonBase::SkeletonBase(void) :
    Inherited(),
    _mfRoots                  (),
    _mfJoints                 (this,
                          JointsFieldId,
                          BaseSkeletonJoint::SkeletonFieldId),
    _mfParentJoints           (),
    _mfJointMatrices          (),
    _mfJointNormalMatrices    (),
    _sfUseInvBindMatrix       (bool(true)),
    _sfCalcNormalMatrices     (bool(false)),
    _sfJointsChanged          ()
{
}

SkeletonBase::SkeletonBase(const SkeletonBase &source) :
    Inherited(source),
    _mfRoots                  (),
    _mfJoints                 (this,
                          JointsFieldId,
                          BaseSkeletonJoint::SkeletonFieldId),
    _mfParentJoints           (),
    _mfJointMatrices          (source._mfJointMatrices          ),
    _mfJointNormalMatrices    (source._mfJointNormalMatrices    ),
    _sfUseInvBindMatrix       (source._sfUseInvBindMatrix       ),
    _sfCalcNormalMatrices     (source._sfCalcNormalMatrices     ),
    _sfJointsChanged          (source._sfJointsChanged          )
{
}


/*-------------------------- destructors ----------------------------------*/

SkeletonBase::~SkeletonBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool SkeletonBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == JointsFieldId)
    {
        BaseSkeletonJoint * pTypedChild =
            dynamic_cast<BaseSkeletonJoint *>(pChild);

        if(pTypedChild != NULL)
        {
            Int32 iChildIdx = _mfJoints.findIndex(pTypedChild);

            if(iChildIdx != -1)
            {
                editMField(JointsFieldMask, _mfJoints);

                _mfJoints.erase(iChildIdx);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void SkeletonBase::onCreate(const Skeleton *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Skeleton *pThis = static_cast<Skeleton *>(this);

        MFUnrecNodePtr::const_iterator RootsIt  =
            source->_mfRoots.begin();
        MFUnrecNodePtr::const_iterator RootsEnd =
            source->_mfRoots.end  ();

        while(RootsIt != RootsEnd)
        {
            pThis->pushToRoots(*RootsIt);

            ++RootsIt;
        }

        MFUnrecChildBaseSkeletonJointPtr::const_iterator JointsIt  =
            source->_mfJoints.begin();
        MFUnrecChildBaseSkeletonJointPtr::const_iterator JointsEnd =
            source->_mfJoints.end  ();

        while(JointsIt != JointsEnd)
        {
            pThis->pushToJoints(*JointsIt);

            ++JointsIt;
        }

        MFUnrecBaseSkeletonJointPtr::const_iterator ParentJointsIt  =
            source->_mfParentJoints.begin();
        MFUnrecBaseSkeletonJointPtr::const_iterator ParentJointsEnd =
            source->_mfParentJoints.end  ();

        while(ParentJointsIt != ParentJointsEnd)
        {
            pThis->pushToParentJoints(*ParentJointsIt);

            ++ParentJointsIt;
        }
    }
}

GetFieldHandlePtr SkeletonBase::getHandleRoots           (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfRoots,
             this->getType().getFieldDesc(RootsFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleRoots          (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfRoots,
             this->getType().getFieldDesc(RootsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Skeleton::pushToRoots,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Skeleton::removeFromRoots,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Skeleton::removeObjFromRoots,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Skeleton::clearRoots,
                    static_cast<Skeleton *>(this)));

    editMField(RootsFieldMask, _mfRoots);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleJoints          (void) const
{
    MFUnrecChildBaseSkeletonJointPtr::GetHandlePtr returnValue(
        new  MFUnrecChildBaseSkeletonJointPtr::GetHandle(
             &_mfJoints,
             this->getType().getFieldDesc(JointsFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJoints         (void)
{
    MFUnrecChildBaseSkeletonJointPtr::EditHandlePtr returnValue(
        new  MFUnrecChildBaseSkeletonJointPtr::EditHandle(
             &_mfJoints,
             this->getType().getFieldDesc(JointsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Skeleton::pushToJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Skeleton::removeFromJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Skeleton::removeObjFromJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Skeleton::clearJoints,
                    static_cast<Skeleton *>(this)));

    editMField(JointsFieldMask, _mfJoints);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleParentJoints    (void) const
{
    MFUnrecBaseSkeletonJointPtr::GetHandlePtr returnValue(
        new  MFUnrecBaseSkeletonJointPtr::GetHandle(
             &_mfParentJoints,
             this->getType().getFieldDesc(ParentJointsFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleParentJoints   (void)
{
    MFUnrecBaseSkeletonJointPtr::EditHandlePtr returnValue(
        new  MFUnrecBaseSkeletonJointPtr::EditHandle(
             &_mfParentJoints,
             this->getType().getFieldDesc(ParentJointsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Skeleton::pushToParentJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Skeleton::removeFromParentJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Skeleton::removeObjFromParentJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Skeleton::clearParentJoints,
                    static_cast<Skeleton *>(this)));

    editMField(ParentJointsFieldMask, _mfParentJoints);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleJointMatrices   (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfJointMatrices,
             this->getType().getFieldDesc(JointMatricesFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJointMatrices  (void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfJointMatrices,
             this->getType().getFieldDesc(JointMatricesFieldId),
             this));


    editMField(JointMatricesFieldMask, _mfJointMatrices);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleJointNormalMatrices (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfJointNormalMatrices,
             this->getType().getFieldDesc(JointNormalMatricesFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJointNormalMatrices(void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfJointNormalMatrices,
             this->getType().getFieldDesc(JointNormalMatricesFieldId),
             this));


    editMField(JointNormalMatricesFieldMask, _mfJointNormalMatrices);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleUseInvBindMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseInvBindMatrix,
             this->getType().getFieldDesc(UseInvBindMatrixFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleUseInvBindMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseInvBindMatrix,
             this->getType().getFieldDesc(UseInvBindMatrixFieldId),
             this));


    editSField(UseInvBindMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleCalcNormalMatrices (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfCalcNormalMatrices,
             this->getType().getFieldDesc(CalcNormalMatricesFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleCalcNormalMatrices(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfCalcNormalMatrices,
             this->getType().getFieldDesc(CalcNormalMatricesFieldId),
             this));


    editSField(CalcNormalMatricesFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleJointsChanged   (void) const
{
    SFOSGAny::GetHandlePtr returnValue(
        new  SFOSGAny::GetHandle(
             &_sfJointsChanged,
             this->getType().getFieldDesc(JointsChangedFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJointsChanged  (void)
{
    SFOSGAny::EditHandlePtr returnValue(
        new  SFOSGAny::EditHandle(
             &_sfJointsChanged,
             this->getType().getFieldDesc(JointsChangedFieldId),
             this));


    editSField(JointsChangedFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void SkeletonBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Skeleton *pThis = static_cast<Skeleton *>(this);

    pThis->execSync(static_cast<Skeleton *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SkeletonBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Skeleton *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Skeleton *>(pRefAspect),
                  dynamic_cast<const Skeleton *>(this));

    return returnValue;
}
#endif

void SkeletonBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Skeleton *>(this)->clearRoots();

    static_cast<Skeleton *>(this)->clearJoints();

    static_cast<Skeleton *>(this)->clearParentJoints();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfJointMatrices.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfJointNormalMatrices.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

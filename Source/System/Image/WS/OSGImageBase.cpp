/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Image!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEIMAGEINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>                        // DataType default header

#include <OSGFieldContainer.h> // Parents Class

#include "OSGImageBase.h"
#include "OSGImage.h"

#include "boost/bind.hpp"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Image
    1D/2D/3D Image with various pixel types data, optionally also can hold
    mipMap and simple multi-frame data.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var ParentFieldContainerPtr ImageBase::_mfParents
    
*/

/*! \var Int32           ImageBase::_sfDimension
    Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.
*/

/*! \var Int32           ImageBase::_sfWidth
    
*/

/*! \var Int32           ImageBase::_sfHeight
    
*/

/*! \var Int32           ImageBase::_sfDepth
    
*/

/*! \var Int32           ImageBase::_sfBpp
    Bytes of data per pixel.
*/

/*! \var Int32           ImageBase::_sfMipMapCount
    
*/

/*! \var Int32           ImageBase::_sfFrameCount
    The number of frames in the data.
*/

/*! \var Time            ImageBase::_sfFrameDelay
    Time between frames.  Determines the frame rate.
*/

/*! \var UInt32          ImageBase::_sfPixelFormat
    
*/

/*! \var UInt8           ImageBase::_mfPixel
    The pixel data buffer. This is where the data for the image is stored.
*/

/*! \var Int32           ImageBase::_sfFrameSize
    
*/

/*! \var std::string     ImageBase::_sfName
    Texture file path.
*/

/*! \var Int32           ImageBase::_sfDataType
    Type of image data.
*/

/*! \var Int32           ImageBase::_sfComponentSize
    Size (in byte) of a single component of the image. Necessary
    for High Dynamic Range and other higher-level image types.
*/

/*! \var Int32           ImageBase::_sfSideCount
    
*/

/*! \var Int32           ImageBase::_sfSideSize
    
*/

/*! \var bool            ImageBase::_sfForceCompressedData
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceColorChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaBinary
    Set to true if using the image to prevent depth sorting for 
    SimpleTexturedMaterials using this Image.
*/

/*! \var Real32          ImageBase::_sfResX
    
*/

/*! \var Real32          ImageBase::_sfResY
    
*/

/*! \var UInt16          ImageBase::_sfResUnit
    resolution unit (invalid=0, none=1, inch=2)
*/


void ImageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFParentFieldContainerPtr::Description(
        MFParentFieldContainerPtr::getClassType(),
        "parents",
        "",
        ParentsFieldId, ParentsFieldMask,
        true,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ImageBase::invalidEditField),
        static_cast     <FieldGetMethodSig >(&ImageBase::invalidGetField));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dimension",
        "Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n",
        DimensionFieldId, DimensionFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleDimension),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleDimension));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "width",
        "",
        WidthFieldId, WidthFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleWidth),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "height",
        "",
        HeightFieldId, HeightFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleHeight),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "depth",
        "",
        DepthFieldId, DepthFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleDepth),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "bpp",
        "Bytes of data per pixel.\n",
        BppFieldId, BppFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleBpp),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleBpp));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "mipMapCount",
        "",
        MipMapCountFieldId, MipMapCountFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleMipMapCount),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleMipMapCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameCount",
        "The number of frames in the data.\n",
        FrameCountFieldId, FrameCountFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleFrameCount),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleFrameCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTime::Description(
        SFTime::getClassType(),
        "frameDelay",
        "Time between frames.  Determines the frame rate.\n",
        FrameDelayFieldId, FrameDelayFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleFrameDelay),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleFrameDelay));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pixelFormat",
        "",
        PixelFormatFieldId, PixelFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandlePixelFormat),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandlePixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "pixel",
        "The pixel data buffer. This is where the data for the image is stored.\n",
        PixelFieldId, PixelFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandlePixel),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandlePixel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameSize",
        "",
        FrameSizeFieldId, FrameSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleFrameSize),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleFrameSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "name",
        "Texture file path.\n",
        NameFieldId, NameFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleName),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleName));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dataType",
        "Type of image data.\n",
        DataTypeFieldId, DataTypeFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleDataType),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleDataType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "componentSize",
        "Size (in byte) of a single component of the image. Necessary\n"
        "for High Dynamic Range and other higher-level image types.\n",
        ComponentSizeFieldId, ComponentSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleComponentSize),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleComponentSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideCount",
        "",
        SideCountFieldId, SideCountFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleSideCount),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleSideCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideSize",
        "",
        SideSizeFieldId, SideSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleSideSize),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleSideSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceCompressedData",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceCompressedDataFieldId, ForceCompressedDataFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleForceCompressedData),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleForceCompressedData));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceAlphaChannelFieldId, ForceAlphaChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleForceAlphaChannel),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleForceAlphaChannel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceColorChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceColorChannelFieldId, ForceColorChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleForceColorChannel),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleForceColorChannel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaBinary",
        "Set to true if using the image to prevent depth sorting for \n"
        "SimpleTexturedMaterials using this Image.\n",
        ForceAlphaBinaryFieldId, ForceAlphaBinaryFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleForceAlphaBinary),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleForceAlphaBinary));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "resX",
        "",
        ResXFieldId, ResXFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleResX),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleResX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "resY",
        "",
        ResYFieldId, ResYFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleResY),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleResY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt16::Description(
        SFUInt16::getClassType(),
        "resUnit",
        "resolution unit (invalid=0, none=1, inch=2)\n",
        ResUnitFieldId, ResUnitFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ImageBase::editHandleResUnit),
        static_cast<FieldGetMethodSig >(&ImageBase::getHandleResUnit));

    oType.addInitialDesc(pDesc);
}


ImageBase::TypeObject ImageBase::_type(
    ImageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ImageBase::createEmptyLocal,
    Image::initMethod,
    Image::exitMethod,
    (InitalInsertDescFunc) &ImageBase::classDescInserter,
    false,
    (ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask),
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Image\"\n"
    "\tparent=\"AttachmentContainer\"\n"
    "\tlibrary=\"System\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    "    fieldsUnmarkedOnCreate=\"(ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask)\"\n"
    "    childfieldparent=\"FieldContainer\"\n"
    "    parentfieldcard=\"multi\"\n"
    "    childFields=\"single\"\n"
    ">\n"
    "1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "mipMap and simple multi-frame data.\n"
    "\t<Field\n"
    "\t\tname=\"parents\"\n"
    "\t\ttype=\"FieldContainer\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"none\"\n"
    "        category=\"parentpointer\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dimension\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tImage dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"width\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"height\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"depth\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bpp\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Bytes of data per pixel.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"mipMapCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The number of frames in the data.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameDelay\"\n"
    "\t\ttype=\"Time\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Time between frames.  Determines the frame rate.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pixelFormat\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"Image::OSG_INVALID_PF\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pixel\"\n"
    "\t\ttype=\"UInt8\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The pixel data buffer. This is where the data for the image is stored.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"name\"\n"
    "\t\ttype=\"std::string\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture file path.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dataType\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_UNSIGNED_BYTE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tType of image data.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"componentSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tSize (in byte) of a single component of the image. Necessary\n"
    "        for High Dynamic Range and other higher-level image types.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sideCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sideSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceCompressedData\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceAlphaChannel\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceColorChannel\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceAlphaBinary\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to prevent depth sorting for \n"
    "        SimpleTexturedMaterials using this Image.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"resX\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"72.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"resY\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"72.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"resUnit\"\n"
    "\t\ttype=\"UInt16\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"2\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tresolution unit (invalid=0, none=1, inch=2)\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "mipMap and simple multi-frame data.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ImageBase::getType(void)
{
    return _type;
}

const FieldContainerType &ImageBase::getType(void) const
{
    return _type;
}

UInt32 ImageBase::getContainerSize(void) const
{
    return sizeof(Image);
}

/*------------------------- decorator get ------------------------------*/



SFInt32 *ImageBase::editSFDimension(void)
{
    editSField(DimensionFieldMask);

    return &_sfDimension;
}

const SFInt32 *ImageBase::getSFDimension(void) const
{
    return &_sfDimension;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDimension      (void)
{
    return this->editSFDimension      ();
}
#endif

SFInt32 *ImageBase::editSFWidth(void)
{
    editSField(WidthFieldMask);

    return &_sfWidth;
}

const SFInt32 *ImageBase::getSFWidth(void) const
{
    return &_sfWidth;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFWidth          (void)
{
    return this->editSFWidth          ();
}
#endif

SFInt32 *ImageBase::editSFHeight(void)
{
    editSField(HeightFieldMask);

    return &_sfHeight;
}

const SFInt32 *ImageBase::getSFHeight(void) const
{
    return &_sfHeight;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFHeight         (void)
{
    return this->editSFHeight         ();
}
#endif

SFInt32 *ImageBase::editSFDepth(void)
{
    editSField(DepthFieldMask);

    return &_sfDepth;
}

const SFInt32 *ImageBase::getSFDepth(void) const
{
    return &_sfDepth;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDepth          (void)
{
    return this->editSFDepth          ();
}
#endif

SFInt32 *ImageBase::editSFBpp(void)
{
    editSField(BppFieldMask);

    return &_sfBpp;
}

const SFInt32 *ImageBase::getSFBpp(void) const
{
    return &_sfBpp;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFBpp            (void)
{
    return this->editSFBpp            ();
}
#endif

SFInt32 *ImageBase::editSFMipMapCount(void)
{
    editSField(MipMapCountFieldMask);

    return &_sfMipMapCount;
}

const SFInt32 *ImageBase::getSFMipMapCount(void) const
{
    return &_sfMipMapCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFMipMapCount    (void)
{
    return this->editSFMipMapCount    ();
}
#endif

SFInt32 *ImageBase::editSFFrameCount(void)
{
    editSField(FrameCountFieldMask);

    return &_sfFrameCount;
}

const SFInt32 *ImageBase::getSFFrameCount(void) const
{
    return &_sfFrameCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFFrameCount     (void)
{
    return this->editSFFrameCount     ();
}
#endif

SFTime *ImageBase::editSFFrameDelay(void)
{
    editSField(FrameDelayFieldMask);

    return &_sfFrameDelay;
}

const SFTime *ImageBase::getSFFrameDelay(void) const
{
    return &_sfFrameDelay;
}

#ifdef OSG_1_GET_COMPAT
SFTime              *ImageBase::getSFFrameDelay     (void)
{
    return this->editSFFrameDelay     ();
}
#endif

SFUInt32 *ImageBase::editSFPixelFormat(void)
{
    editSField(PixelFormatFieldMask);

    return &_sfPixelFormat;
}

const SFUInt32 *ImageBase::getSFPixelFormat(void) const
{
    return &_sfPixelFormat;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ImageBase::getSFPixelFormat    (void)
{
    return this->editSFPixelFormat    ();
}
#endif

MFUInt8 *ImageBase::editMFPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    return &_mfPixel;
}

const MFUInt8 *ImageBase::getMFPixel(void) const
{
    return &_mfPixel;
}

#ifdef OSG_1_GET_COMPAT
MFUInt8             *ImageBase::getMFPixel          (void)
{
    return this->editMFPixel          ();
}
#endif

SFInt32 *ImageBase::editSFFrameSize(void)
{
    editSField(FrameSizeFieldMask);

    return &_sfFrameSize;
}

const SFInt32 *ImageBase::getSFFrameSize(void) const
{
    return &_sfFrameSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFFrameSize      (void)
{
    return this->editSFFrameSize      ();
}
#endif

SFString *ImageBase::editSFName(void)
{
    editSField(NameFieldMask);

    return &_sfName;
}

const SFString *ImageBase::getSFName(void) const
{
    return &_sfName;
}

#ifdef OSG_1_GET_COMPAT
SFString            *ImageBase::getSFName           (void)
{
    return this->editSFName           ();
}
#endif

SFInt32 *ImageBase::editSFDataType(void)
{
    editSField(DataTypeFieldMask);

    return &_sfDataType;
}

const SFInt32 *ImageBase::getSFDataType(void) const
{
    return &_sfDataType;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDataType       (void)
{
    return this->editSFDataType       ();
}
#endif

SFInt32 *ImageBase::editSFComponentSize(void)
{
    editSField(ComponentSizeFieldMask);

    return &_sfComponentSize;
}

const SFInt32 *ImageBase::getSFComponentSize(void) const
{
    return &_sfComponentSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFComponentSize  (void)
{
    return this->editSFComponentSize  ();
}
#endif

SFInt32 *ImageBase::editSFSideCount(void)
{
    editSField(SideCountFieldMask);

    return &_sfSideCount;
}

const SFInt32 *ImageBase::getSFSideCount(void) const
{
    return &_sfSideCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFSideCount      (void)
{
    return this->editSFSideCount      ();
}
#endif

SFInt32 *ImageBase::editSFSideSize(void)
{
    editSField(SideSizeFieldMask);

    return &_sfSideSize;
}

const SFInt32 *ImageBase::getSFSideSize(void) const
{
    return &_sfSideSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFSideSize       (void)
{
    return this->editSFSideSize       ();
}
#endif

SFBool *ImageBase::editSFForceCompressedData(void)
{
    editSField(ForceCompressedDataFieldMask);

    return &_sfForceCompressedData;
}

const SFBool *ImageBase::getSFForceCompressedData(void) const
{
    return &_sfForceCompressedData;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceCompressedData(void)
{
    return this->editSFForceCompressedData();
}
#endif

SFBool *ImageBase::editSFForceAlphaChannel(void)
{
    editSField(ForceAlphaChannelFieldMask);

    return &_sfForceAlphaChannel;
}

const SFBool *ImageBase::getSFForceAlphaChannel(void) const
{
    return &_sfForceAlphaChannel;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceAlphaChannel(void)
{
    return this->editSFForceAlphaChannel();
}
#endif

SFBool *ImageBase::editSFForceColorChannel(void)
{
    editSField(ForceColorChannelFieldMask);

    return &_sfForceColorChannel;
}

const SFBool *ImageBase::getSFForceColorChannel(void) const
{
    return &_sfForceColorChannel;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceColorChannel(void)
{
    return this->editSFForceColorChannel();
}
#endif

SFBool *ImageBase::editSFForceAlphaBinary(void)
{
    editSField(ForceAlphaBinaryFieldMask);

    return &_sfForceAlphaBinary;
}

const SFBool *ImageBase::getSFForceAlphaBinary(void) const
{
    return &_sfForceAlphaBinary;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceAlphaBinary(void)
{
    return this->editSFForceAlphaBinary();
}
#endif

SFReal32 *ImageBase::editSFResX(void)
{
    editSField(ResXFieldMask);

    return &_sfResX;
}

const SFReal32 *ImageBase::getSFResX(void) const
{
    return &_sfResX;
}

#ifdef OSG_1_GET_COMPAT
SFReal32            *ImageBase::getSFResX           (void)
{
    return this->editSFResX           ();
}
#endif

SFReal32 *ImageBase::editSFResY(void)
{
    editSField(ResYFieldMask);

    return &_sfResY;
}

const SFReal32 *ImageBase::getSFResY(void) const
{
    return &_sfResY;
}

#ifdef OSG_1_GET_COMPAT
SFReal32            *ImageBase::getSFResY           (void)
{
    return this->editSFResY           ();
}
#endif

SFUInt16 *ImageBase::editSFResUnit(void)
{
    editSField(ResUnitFieldMask);

    return &_sfResUnit;
}

const SFUInt16 *ImageBase::getSFResUnit(void) const
{
    return &_sfResUnit;
}

#ifdef OSG_1_GET_COMPAT
SFUInt16            *ImageBase::getSFResUnit        (void)
{
    return this->editSFResUnit        ();
}
#endif





/*------------------------------ access -----------------------------------*/

UInt32 ImageBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        returnValue += _mfParents.getBinSize();
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        returnValue += _sfDimension.getBinSize();
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        returnValue += _sfWidth.getBinSize();
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        returnValue += _sfHeight.getBinSize();
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        returnValue += _sfDepth.getBinSize();
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        returnValue += _sfBpp.getBinSize();
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        returnValue += _sfMipMapCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        returnValue += _sfFrameCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        returnValue += _sfFrameDelay.getBinSize();
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        returnValue += _sfPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        returnValue += _mfPixel.getBinSize();
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        returnValue += _sfFrameSize.getBinSize();
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        returnValue += _sfName.getBinSize();
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        returnValue += _sfDataType.getBinSize();
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        returnValue += _sfComponentSize.getBinSize();
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        returnValue += _sfSideCount.getBinSize();
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        returnValue += _sfSideSize.getBinSize();
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        returnValue += _sfForceCompressedData.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        returnValue += _sfForceAlphaChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        returnValue += _sfForceColorChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        returnValue += _sfForceAlphaBinary.getBinSize();
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        returnValue += _sfResX.getBinSize();
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        returnValue += _sfResY.getBinSize();
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        returnValue += _sfResUnit.getBinSize();
    }

    return returnValue;
}

void ImageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        _sfResX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        _sfResY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        _sfResUnit.copyToBin(pMem);
    }
}

void ImageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        _sfResX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        _sfResY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        _sfResUnit.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ImageTransitPtr ImageBase::create(void)
{
    ImageTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Image>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ImageTransitPtr ImageBase::createLocal(BitVector bFlags)
{
    ImageTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Image>(tmpPtr);
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
ImagePtr ImageBase::createEmpty(void)
{
    ImagePtr returnValue;

    newPtr<Image>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &= 
        ~Thread::getCurrentLocalFlags(); 

    return returnValue;
}

ImagePtr ImageBase::createEmptyLocal(BitVector bFlags)
{
    ImagePtr returnValue;

    newPtr<Image>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ImageBase::shallowCopy(void) const
{
    ImagePtr tmpPtr;

    newPtr(tmpPtr, 
           dynamic_cast<const Image *>(this), 
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}

FieldContainerTransitPtr ImageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ImagePtr tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Image *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

ImageBase::ImageBase(void) :
    Inherited(),
    _mfParents                (),
    _sfDimension              (Int32(0)),
    _sfWidth                  (Int32(0)),
    _sfHeight                 (Int32(1)),
    _sfDepth                  (Int32(1)),
    _sfBpp                    (Int32(1)),
    _sfMipMapCount            (Int32(1)),
    _sfFrameCount             (Int32(1)),
    _sfFrameDelay             (Time(0)),
    _sfPixelFormat            (UInt32(Image::OSG_INVALID_PF)),
    _mfPixel                  (),
    _sfFrameSize              (Int32(0)),
    _sfName                   (),
    _sfDataType               (Int32(GL_UNSIGNED_BYTE)),
    _sfComponentSize          (Int32(1)),
    _sfSideCount              (Int32(1)),
    _sfSideSize               (Int32(0)),
    _sfForceCompressedData    (bool(false)),
    _sfForceAlphaChannel      (bool(false)),
    _sfForceColorChannel      (bool(false)),
    _sfForceAlphaBinary       (bool(false)),
    _sfResX                   (Real32(72.0f)),
    _sfResY                   (Real32(72.0f)),
    _sfResUnit                (UInt16(2))
{
}

ImageBase::ImageBase(const ImageBase &source) :
    Inherited(source),
    _mfParents                (),
    _sfDimension              (source._sfDimension              ),
    _sfWidth                  (source._sfWidth                  ),
    _sfHeight                 (source._sfHeight                 ),
    _sfDepth                  (source._sfDepth                  ),
    _sfBpp                    (source._sfBpp                    ),
    _sfMipMapCount            (source._sfMipMapCount            ),
    _sfFrameCount             (source._sfFrameCount             ),
    _sfFrameDelay             (source._sfFrameDelay             ),
    _sfPixelFormat            (source._sfPixelFormat            ),
    _mfPixel                  (source._mfPixel                  ),
    _sfFrameSize              (source._sfFrameSize              ),
    _sfName                   (source._sfName                   ),
    _sfDataType               (source._sfDataType               ),
    _sfComponentSize          (source._sfComponentSize          ),
    _sfSideCount              (source._sfSideCount              ),
    _sfSideSize               (source._sfSideSize               ),
    _sfForceCompressedData    (source._sfForceCompressedData    ),
    _sfForceAlphaChannel      (source._sfForceAlphaChannel      ),
    _sfForceColorChannel      (source._sfForceColorChannel      ),
    _sfForceAlphaBinary       (source._sfForceAlphaBinary       ),
    _sfResX                   (source._sfResX                   ),
    _sfResY                   (source._sfResY                   ),
    _sfResUnit                (source._sfResUnit                )
{
}


/*-------------------------- destructors ----------------------------------*/

ImageBase::~ImageBase(void)
{
}
/*-------------------------------------------------------------------------*/
/* Parent linking                                                          */

bool ImageBase::linkParent(
    const FieldContainerPtr pParent,
    const UInt16            childFieldId,
    const UInt16            parentFieldId )
{
    if(parentFieldId == ParentsFieldId)
    {
        FieldContainerPtr pTypedParent =
            dynamic_cast< FieldContainerPtr >(pParent);
        
        if(pTypedParent != NullFC)
        {
            editMField(ParentsFieldMask, _mfParents);

            _mfParents.push_back(pParent, childFieldId);
            
            return true;
        }
    
        return false;
    }
    
    return Inherited::linkParent(pParent, childFieldId, parentFieldId);
}

bool ImageBase::unlinkParent(
    const FieldContainerPtr pParent,
    const UInt16            parentFieldId)
{
    if(parentFieldId == ParentsFieldId)
    {
        FieldContainerPtr pTypedParent =
            dynamic_cast< FieldContainerPtr >(pParent);
            
        if(pTypedParent != NullFC)
        {
            MFParentFieldContainerPtr::iterator pI = 
                _mfParents.find_nc(pParent);
                
            if(pI != _mfParents.end())
            {
                editMField(ParentsFieldMask, _mfParents);
                
                _mfParents.erase(pI);
                
                return true;
            }
            
            FWARNING(("ImageBase::unlinkParent: "
                      "Child <-> Parent link inconsistent.\n"));
            
            return false;
        }

        return false;
    }
    
    return Inherited::unlinkParent(pParent, parentFieldId);
}


void ImageBase::onCreate(const Image *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Image *pThis = static_cast<Image *>(this);
    }
}

GetFieldHandlePtr ImageBase::getHandleParents         (void) const
{
    MFParentFieldContainerPtr::GetHandlePtr returnValue;

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleParents        (void)
{
    EditFieldHandlePtr returnValue;

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDimension       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDimension, 
             this->getType().getFieldDesc(DimensionFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDimension      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDimension, 
             this->getType().getFieldDesc(DimensionFieldId)));

    editSField(DimensionFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleWidth           (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfWidth, 
             this->getType().getFieldDesc(WidthFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleWidth          (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfWidth, 
             this->getType().getFieldDesc(WidthFieldId)));

    editSField(WidthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleHeight          (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfHeight, 
             this->getType().getFieldDesc(HeightFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleHeight         (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfHeight, 
             this->getType().getFieldDesc(HeightFieldId)));

    editSField(HeightFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDepth           (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDepth, 
             this->getType().getFieldDesc(DepthFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDepth          (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDepth, 
             this->getType().getFieldDesc(DepthFieldId)));

    editSField(DepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleBpp             (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfBpp, 
             this->getType().getFieldDesc(BppFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleBpp            (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfBpp, 
             this->getType().getFieldDesc(BppFieldId)));

    editSField(BppFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleMipMapCount     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfMipMapCount, 
             this->getType().getFieldDesc(MipMapCountFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleMipMapCount    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfMipMapCount, 
             this->getType().getFieldDesc(MipMapCountFieldId)));

    editSField(MipMapCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameCount      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFrameCount, 
             this->getType().getFieldDesc(FrameCountFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameCount     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFrameCount, 
             this->getType().getFieldDesc(FrameCountFieldId)));

    editSField(FrameCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameDelay      (void) const
{
    SFTime::GetHandlePtr returnValue(
        new  SFTime::GetHandle(
             &_sfFrameDelay, 
             this->getType().getFieldDesc(FrameDelayFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameDelay     (void)
{
    SFTime::EditHandlePtr returnValue(
        new  SFTime::EditHandle(
             &_sfFrameDelay, 
             this->getType().getFieldDesc(FrameDelayFieldId)));

    editSField(FrameDelayFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandlePixelFormat     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfPixelFormat, 
             this->getType().getFieldDesc(PixelFormatFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandlePixelFormat    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfPixelFormat, 
             this->getType().getFieldDesc(PixelFormatFieldId)));

    editSField(PixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandlePixel           (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfPixel, 
             this->getType().getFieldDesc(PixelFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandlePixel          (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfPixel, 
             this->getType().getFieldDesc(PixelFieldId)));

    editMField(PixelFieldMask, _mfPixel);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameSize       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFrameSize, 
             this->getType().getFieldDesc(FrameSizeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameSize      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFrameSize, 
             this->getType().getFieldDesc(FrameSizeFieldId)));

    editSField(FrameSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleName            (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfName, 
             this->getType().getFieldDesc(NameFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleName           (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfName, 
             this->getType().getFieldDesc(NameFieldId)));

    editSField(NameFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDataType        (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDataType, 
             this->getType().getFieldDesc(DataTypeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDataType       (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDataType, 
             this->getType().getFieldDesc(DataTypeFieldId)));

    editSField(DataTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleComponentSize   (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfComponentSize, 
             this->getType().getFieldDesc(ComponentSizeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleComponentSize  (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfComponentSize, 
             this->getType().getFieldDesc(ComponentSizeFieldId)));

    editSField(ComponentSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleSideCount       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSideCount, 
             this->getType().getFieldDesc(SideCountFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleSideCount      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSideCount, 
             this->getType().getFieldDesc(SideCountFieldId)));

    editSField(SideCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleSideSize        (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSideSize, 
             this->getType().getFieldDesc(SideSizeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleSideSize       (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSideSize, 
             this->getType().getFieldDesc(SideSizeFieldId)));

    editSField(SideSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceCompressedData (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceCompressedData, 
             this->getType().getFieldDesc(ForceCompressedDataFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceCompressedData(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceCompressedData, 
             this->getType().getFieldDesc(ForceCompressedDataFieldId)));

    editSField(ForceCompressedDataFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceAlphaChannel (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceAlphaChannel, 
             this->getType().getFieldDesc(ForceAlphaChannelFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceAlphaChannel(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceAlphaChannel, 
             this->getType().getFieldDesc(ForceAlphaChannelFieldId)));

    editSField(ForceAlphaChannelFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceColorChannel (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceColorChannel, 
             this->getType().getFieldDesc(ForceColorChannelFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceColorChannel(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceColorChannel, 
             this->getType().getFieldDesc(ForceColorChannelFieldId)));

    editSField(ForceColorChannelFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceAlphaBinary (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceAlphaBinary, 
             this->getType().getFieldDesc(ForceAlphaBinaryFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceAlphaBinary(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceAlphaBinary, 
             this->getType().getFieldDesc(ForceAlphaBinaryFieldId)));

    editSField(ForceAlphaBinaryFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResX            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfResX, 
             this->getType().getFieldDesc(ResXFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResX           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfResX, 
             this->getType().getFieldDesc(ResXFieldId)));

    editSField(ResXFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResY            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfResY, 
             this->getType().getFieldDesc(ResYFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResY           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfResY, 
             this->getType().getFieldDesc(ResYFieldId)));

    editSField(ResYFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResUnit         (void) const
{
    SFUInt16::GetHandlePtr returnValue(
        new  SFUInt16::GetHandle(
             &_sfResUnit, 
             this->getType().getFieldDesc(ResUnitFieldId)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResUnit        (void)
{
    SFUInt16::EditHandlePtr returnValue(
        new  SFUInt16::EditHandle(
             &_sfResUnit, 
             this->getType().getFieldDesc(ResUnitFieldId)));

    editSField(ResUnitFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ImageBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ImageBase::createAspectCopy(void) const
{
    ImagePtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Image *>(this));

    return returnValue;
}
#endif

void ImageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfPixel.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ImagePtr>::_type("ImagePtr", "AttachmentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ImagePtr)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField, 
                           ImagePtr, 
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField, 
                           ImagePtr, 
                           0);

DataType &FieldTraits< ImagePtr, 1 >::getType(void)
{                                                           
    return FieldTraits<ImagePtr, 0>::getType();
}


OSG_EXPORT_PTR_SFIELD(ChildPointerSField,
                      ImagePtr,       
                      UnrecordedRefCountPolicy,  
                      1);


OSG_END_NAMESPACE

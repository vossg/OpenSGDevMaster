/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Image!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEIMAGEINST

#include <stdlib.h>
#include <stdio.h>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>   // DataType default header

#include <OSGFieldContainer.h> // Parents Class

#include "OSGImageBase.h"
#include "OSGImage.h"

OSG_USING_NAMESPACE

// Field descriptions

/*! \var ParentFieldContainerPtr ImageBase::_mfParents
    
*/
/*! \var Int32 ImageBase::_sfDimension
    	image dimension, 0 for invalid, 1 for 1D, 2 for 2D and     3 for 3D data.

*/
/*! \var Int32 ImageBase::_sfWidth
    
*/
/*! \var Int32 ImageBase::_sfHeight
    
*/
/*! \var Int32 ImageBase::_sfDepth
    
*/
/*! \var Int32 ImageBase::_sfBpp
    
*/
/*! \var Int32 ImageBase::_sfMipMapCount
    
*/
/*! \var Int32 ImageBase::_sfFrameCount
    
*/
/*! \var Time ImageBase::_sfFrameDelay
    
*/
/*! \var UInt32 ImageBase::_sfPixelFormat
    
*/
/*! \var UInt8 ImageBase::_mfPixel
    
*/
/*! \var Int32 ImageBase::_sfFrameSize
    
*/
/*! \var std::string ImageBase::_sfName
    	Texture file path

*/
/*! \var Int32 ImageBase::_sfDataType
    	Type of image data

*/
/*! \var Int32 ImageBase::_sfComponentSize
    	Size (in byte) of a single component of the image. Necessary         for High Dynamic Range and other higher-level image types.

*/
/*! \var Int32 ImageBase::_sfSideCount
    
*/
/*! \var Int32 ImageBase::_sfSideSize
    
*/
/*! \var bool ImageBase::_sfForceCompressedData
            Set to true if using the image to keep unknown data for textures.
        Generally used in conjunction with TextureChunk::externalFormat.

*/
/*! \var bool ImageBase::_sfForceAlphaChannel
            Set to true if using the image to keep unknown data for textures.
        Generally used in conjunction with TextureChunk::externalFormat.

*/
/*! \var bool ImageBase::_sfForceColorChannel
            Set to true if using the image to keep unknown data for textures.
        Generally used in conjunction with TextureChunk::externalFormat.

*/
/*! \var bool ImageBase::_sfForceAlphaBinary
            Set to true if using the image to prevent depth sorting for 
        SimpleTexturedMaterials using this Image.

*/

void ImageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL; 


    pDesc = new MFParentFieldContainerPtr::Description(
        MFParentFieldContainerPtr::getClassType(), 
        "parents", 
        "",
        ParentsFieldId, ParentsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ImageBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getMFParents));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDimensionF)(void) const;

    GetSFDimensionF GetSFDimension = &ImageBase::getSFDimension;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dimension", 
        "	image dimension, 0 for invalid, 1 for 1D, 2 for 2D and     3 for 3D data.\n",
        DimensionFieldId, DimensionFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDimension),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDimension));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDimension));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFWidthF)(void) const;

    GetSFWidthF GetSFWidth = &ImageBase::getSFWidth;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "width", 
        "",
        WidthFieldId, WidthFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFWidth),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWidth));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFWidth));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFHeightF)(void) const;

    GetSFHeightF GetSFHeight = &ImageBase::getSFHeight;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "height", 
        "",
        HeightFieldId, HeightFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFHeight),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFHeight));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFHeight));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDepthF)(void) const;

    GetSFDepthF GetSFDepth = &ImageBase::getSFDepth;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "depth", 
        "",
        DepthFieldId, DepthFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDepth),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDepth));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDepth));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFBppF)(void) const;

    GetSFBppF GetSFBpp = &ImageBase::getSFBpp;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "bpp", 
        "",
        BppFieldId, BppFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFBpp),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBpp));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFBpp));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFMipMapCountF)(void) const;

    GetSFMipMapCountF GetSFMipMapCount = &ImageBase::getSFMipMapCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "mipMapCount", 
        "",
        MipMapCountFieldId, MipMapCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFMipMapCount),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMipMapCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFMipMapCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFFrameCountF)(void) const;

    GetSFFrameCountF GetSFFrameCount = &ImageBase::getSFFrameCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "frameCount", 
        "",
        FrameCountFieldId, FrameCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameCount),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFTime *(ImageBase::*GetSFFrameDelayF)(void) const;

    GetSFFrameDelayF GetSFFrameDelay = &ImageBase::getSFFrameDelay;
#endif

    pDesc = new SFTime::Description(
        SFTime::getClassType(), 
        "frameDelay", 
        "",
        FrameDelayFieldId, FrameDelayFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameDelay),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameDelay));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameDelay));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(ImageBase::*GetSFPixelFormatF)(void) const;

    GetSFPixelFormatF GetSFPixelFormat = &ImageBase::getSFPixelFormat;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "pixelFormat", 
        "",
        PixelFormatFieldId, PixelFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFPixelFormat),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPixelFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFPixelFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFUInt8 *(ImageBase::*GetMFPixelF)(void) const;

    GetMFPixelF GetMFPixel = &ImageBase::getMFPixel;
#endif

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(), 
        "pixel", 
        "",
        PixelFieldId, PixelFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editMFPixel),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFPixel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getMFPixel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFFrameSizeF)(void) const;

    GetSFFrameSizeF GetSFFrameSize = &ImageBase::getSFFrameSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "frameSize", 
        "",
        FrameSizeFieldId, FrameSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameSize),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFString *(ImageBase::*GetSFNameF)(void) const;

    GetSFNameF GetSFName = &ImageBase::getSFName;
#endif

    pDesc = new SFString::Description(
        SFString::getClassType(), 
        "name", 
        "	Texture file path\n",
        NameFieldId, NameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFName),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFName));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFName));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDataTypeF)(void) const;

    GetSFDataTypeF GetSFDataType = &ImageBase::getSFDataType;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dataType", 
        "	Type of image data\n",
        DataTypeFieldId, DataTypeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDataType),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDataType));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDataType));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFComponentSizeF)(void) const;

    GetSFComponentSizeF GetSFComponentSize = &ImageBase::getSFComponentSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "componentSize", 
        "	Size (in byte) of a single component of the image. Necessary         for High Dynamic Range and other higher-level image types.\n",
        ComponentSizeFieldId, ComponentSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFComponentSize),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFComponentSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFComponentSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFSideCountF)(void) const;

    GetSFSideCountF GetSFSideCount = &ImageBase::getSFSideCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "sideCount", 
        "",
        SideCountFieldId, SideCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFSideCount),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFSideCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFSideCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFSideSizeF)(void) const;

    GetSFSideSizeF GetSFSideSize = &ImageBase::getSFSideSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "sideSize", 
        "",
        SideSizeFieldId, SideSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFSideSize),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFSideSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFSideSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceCompressedDataF)(void) const;

    GetSFForceCompressedDataF GetSFForceCompressedData = &ImageBase::getSFForceCompressedData;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "forceCompressedData", 
        "        Set to true if using the image to keep unknown data for textures.\n        Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceCompressedDataFieldId, ForceCompressedDataFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceCompressedData),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceCompressedData));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceCompressedData));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceAlphaChannelF)(void) const;

    GetSFForceAlphaChannelF GetSFForceAlphaChannel = &ImageBase::getSFForceAlphaChannel;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "forceAlphaChannel", 
        "        Set to true if using the image to keep unknown data for textures.\n        Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceAlphaChannelFieldId, ForceAlphaChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceAlphaChannel),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceAlphaChannel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceAlphaChannel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceColorChannelF)(void) const;

    GetSFForceColorChannelF GetSFForceColorChannel = &ImageBase::getSFForceColorChannel;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "forceColorChannel", 
        "        Set to true if using the image to keep unknown data for textures.\n        Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceColorChannelFieldId, ForceColorChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceColorChannel),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceColorChannel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceColorChannel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceAlphaBinaryF)(void) const;

    GetSFForceAlphaBinaryF GetSFForceAlphaBinary = &ImageBase::getSFForceAlphaBinary;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "forceAlphaBinary", 
        "        Set to true if using the image to prevent depth sorting for \n        SimpleTexturedMaterials using this Image.\n",
        ForceAlphaBinaryFieldId, ForceAlphaBinaryFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceAlphaBinary),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceAlphaBinary));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceAlphaBinary));
#endif

    oType.addInitialDesc(pDesc);
}


ImageBase::TypeObject ImageBase::_type(true,
    ImageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ImageBase::createEmpty,
    Image::initMethod,
    (InitalInsertDescFunc) &ImageBase::classDescInserter,
    false,
    "<?xml version=\"1.0\"?>\n"
"\n"
"<FieldContainer\n"
"	name=\"Image\"\n"
"	parent=\"AttachmentContainer\"\n"
"	library=\"System\"\n"
"	pointerfieldtypes=\"both\"\n"
"	structure=\"concrete\"\n"
"	systemcomponent=\"true\"\n"
"	parentsystemcomponent=\"true\"\n"
"	decoratable=\"false\"\n"
"	useLocalIncludes=\"false\"\n"
">\n"
"1D/2D/3D Image with various pixel types data, can also optional hold mipMap and simple multi-frame data.\n"
"	<Field\n"
"		name=\"parents\"\n"
"		type=\"ParentFieldContainerPtr\"\n"
"		cardinality=\"multi\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"dimension\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"	image dimension, 0 for invalid, 1 for 1D, 2 for 2D and     3 for 3D data.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"width\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"height\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"depth\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"bpp\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"mipMapCount\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"frameCount\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"frameDelay\"\n"
"		type=\"Time\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"pixelFormat\"\n"
"		type=\"UInt32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"Image::OSG_INVALID_PF\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"pixel\"\n"
"		type=\"UInt8\"\n"
"		cardinality=\"multi\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"frameSize\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"internal\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"name\"\n"
"		type=\"std::string\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"	Texture file path\n"
"	</Field>\n"
"	<Field\n"
"		name=\"dataType\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_UNSIGNED_BYTE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	Type of image data\n"
"	</Field>\n"
"	<Field\n"
"		name=\"componentSize\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"internal\"\n"
"		defaultValue=\"1\"\n"
"		access=\"protected\"\n"
"	>\n"
"	Size (in byte) of a single component of the image. Necessary         for High Dynamic Range and other higher-level image types.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"sideCount\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"sideSize\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"internal\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"forceCompressedData\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"false\"\n"
"		access=\"public\"\n"
"	>\n"
"        Set to true if using the image to keep unknown data for textures.\n"
"        Generally used in conjunction with TextureChunk::externalFormat.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"forceAlphaChannel\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"false\"\n"
"		access=\"public\"\n"
"	>\n"
"        Set to true if using the image to keep unknown data for textures.\n"
"        Generally used in conjunction with TextureChunk::externalFormat.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"forceColorChannel\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"false\"\n"
"		access=\"public\"\n"
"	>\n"
"        Set to true if using the image to keep unknown data for textures.\n"
"        Generally used in conjunction with TextureChunk::externalFormat.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"forceAlphaBinary\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"false\"\n"
"		access=\"public\"\n"
"	>\n"
"        Set to true if using the image to prevent depth sorting for \n"
"        SimpleTexturedMaterials using this Image.\n"
"	</Field>\n"
"</FieldContainer>\n"
,
    "1D/2D/3D Image with various pixel types data, can also optional hold mipMap and simple multi-frame data.\n" 
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ImageBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &ImageBase::getType(void) const 
{
    return _type;
} 

UInt32 ImageBase::getContainerSize(void) const 
{ 
    return sizeof(Image); 
}

/*------------------------- decorator get ------------------------------*/


//! Get the Image::_mfParents field.
const MFParentFieldContainerPtr *ImageBase::getMFParents(void) const
{
    return &_mfParents;
}

SFInt32 *ImageBase::editSFDimension(void)
{
    editSField(DimensionFieldMask);

    return &_sfDimension;
}

const SFInt32 *ImageBase::getSFDimension(void) const
{
    return &_sfDimension;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFDimension(void)
{
    return this->editSFDimension();
}
#endif

SFInt32 *ImageBase::editSFWidth(void)
{
    editSField(WidthFieldMask);

    return &_sfWidth;
}

const SFInt32 *ImageBase::getSFWidth(void) const
{
    return &_sfWidth;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFWidth(void)
{
    return this->editSFWidth();
}
#endif

SFInt32 *ImageBase::editSFHeight(void)
{
    editSField(HeightFieldMask);

    return &_sfHeight;
}

const SFInt32 *ImageBase::getSFHeight(void) const
{
    return &_sfHeight;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFHeight(void)
{
    return this->editSFHeight();
}
#endif

SFInt32 *ImageBase::editSFDepth(void)
{
    editSField(DepthFieldMask);

    return &_sfDepth;
}

const SFInt32 *ImageBase::getSFDepth(void) const
{
    return &_sfDepth;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFDepth(void)
{
    return this->editSFDepth();
}
#endif

SFInt32 *ImageBase::editSFBpp(void)
{
    editSField(BppFieldMask);

    return &_sfBpp;
}

const SFInt32 *ImageBase::getSFBpp(void) const
{
    return &_sfBpp;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFBpp(void)
{
    return this->editSFBpp();
}
#endif

SFInt32 *ImageBase::editSFMipMapCount(void)
{
    editSField(MipMapCountFieldMask);

    return &_sfMipMapCount;
}

const SFInt32 *ImageBase::getSFMipMapCount(void) const
{
    return &_sfMipMapCount;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFMipMapCount(void)
{
    return this->editSFMipMapCount();
}
#endif

SFInt32 *ImageBase::editSFFrameCount(void)
{
    editSField(FrameCountFieldMask);

    return &_sfFrameCount;
}

const SFInt32 *ImageBase::getSFFrameCount(void) const
{
    return &_sfFrameCount;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFFrameCount(void)
{
    return this->editSFFrameCount();
}
#endif

SFTime *ImageBase::editSFFrameDelay(void)
{
    editSField(FrameDelayFieldMask);

    return &_sfFrameDelay;
}

const SFTime *ImageBase::getSFFrameDelay(void) const
{
    return &_sfFrameDelay;
}

#ifdef OSG_1_COMPAT
SFTime *ImageBase::getSFFrameDelay(void)
{
    return this->editSFFrameDelay();
}
#endif

SFUInt32 *ImageBase::editSFPixelFormat(void)
{
    editSField(PixelFormatFieldMask);

    return &_sfPixelFormat;
}

const SFUInt32 *ImageBase::getSFPixelFormat(void) const
{
    return &_sfPixelFormat;
}

#ifdef OSG_1_COMPAT
SFUInt32 *ImageBase::getSFPixelFormat(void)
{
    return this->editSFPixelFormat();
}
#endif

MFUInt8 *ImageBase::editMFPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    return &_mfPixel;
}

const MFUInt8 *ImageBase::getMFPixel(void) const
{
    return &_mfPixel;
}

#ifdef OSG_1_COMPAT
MFUInt8 *ImageBase::getMFPixel(void)
{
    return this->editMFPixel();
}
#endif

SFInt32 *ImageBase::editSFFrameSize(void)
{
    editSField(FrameSizeFieldMask);

    return &_sfFrameSize;
}

const SFInt32 *ImageBase::getSFFrameSize(void) const
{
    return &_sfFrameSize;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFFrameSize(void)
{
    return this->editSFFrameSize();
}
#endif

SFString *ImageBase::editSFName(void)
{
    editSField(NameFieldMask);

    return &_sfName;
}

const SFString *ImageBase::getSFName(void) const
{
    return &_sfName;
}

#ifdef OSG_1_COMPAT
SFString *ImageBase::getSFName(void)
{
    return this->editSFName();
}
#endif

SFInt32 *ImageBase::editSFDataType(void)
{
    editSField(DataTypeFieldMask);

    return &_sfDataType;
}

const SFInt32 *ImageBase::getSFDataType(void) const
{
    return &_sfDataType;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFDataType(void)
{
    return this->editSFDataType();
}
#endif

SFInt32 *ImageBase::editSFComponentSize(void)
{
    editSField(ComponentSizeFieldMask);

    return &_sfComponentSize;
}

const SFInt32 *ImageBase::getSFComponentSize(void) const
{
    return &_sfComponentSize;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFComponentSize(void)
{
    return this->editSFComponentSize();
}
#endif

SFInt32 *ImageBase::editSFSideCount(void)
{
    editSField(SideCountFieldMask);

    return &_sfSideCount;
}

const SFInt32 *ImageBase::getSFSideCount(void) const
{
    return &_sfSideCount;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFSideCount(void)
{
    return this->editSFSideCount();
}
#endif

SFInt32 *ImageBase::editSFSideSize(void)
{
    editSField(SideSizeFieldMask);

    return &_sfSideSize;
}

const SFInt32 *ImageBase::getSFSideSize(void) const
{
    return &_sfSideSize;
}

#ifdef OSG_1_COMPAT
SFInt32 *ImageBase::getSFSideSize(void)
{
    return this->editSFSideSize();
}
#endif

SFBool *ImageBase::editSFForceCompressedData(void)
{
    editSField(ForceCompressedDataFieldMask);

    return &_sfForceCompressedData;
}

const SFBool *ImageBase::getSFForceCompressedData(void) const
{
    return &_sfForceCompressedData;
}

#ifdef OSG_1_COMPAT
SFBool *ImageBase::getSFForceCompressedData(void)
{
    return this->editSFForceCompressedData();
}
#endif

SFBool *ImageBase::editSFForceAlphaChannel(void)
{
    editSField(ForceAlphaChannelFieldMask);

    return &_sfForceAlphaChannel;
}

const SFBool *ImageBase::getSFForceAlphaChannel(void) const
{
    return &_sfForceAlphaChannel;
}

#ifdef OSG_1_COMPAT
SFBool *ImageBase::getSFForceAlphaChannel(void)
{
    return this->editSFForceAlphaChannel();
}
#endif

SFBool *ImageBase::editSFForceColorChannel(void)
{
    editSField(ForceColorChannelFieldMask);

    return &_sfForceColorChannel;
}

const SFBool *ImageBase::getSFForceColorChannel(void) const
{
    return &_sfForceColorChannel;
}

#ifdef OSG_1_COMPAT
SFBool *ImageBase::getSFForceColorChannel(void)
{
    return this->editSFForceColorChannel();
}
#endif

SFBool *ImageBase::editSFForceAlphaBinary(void)
{
    editSField(ForceAlphaBinaryFieldMask);

    return &_sfForceAlphaBinary;
}

const SFBool *ImageBase::getSFForceAlphaBinary(void) const
{
    return &_sfForceAlphaBinary;
}

#ifdef OSG_1_COMPAT
SFBool *ImageBase::getSFForceAlphaBinary(void)
{
    return this->editSFForceAlphaBinary();
}
#endif


void ImageBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->pushToParents(
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->insertIntoParents(
            uiIndex,
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->replaceInParents(
            uiIndex,
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->replaceInParents(
            cast_dynamic<ParentFieldContainerPtr>(pOldElement),
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->removeFromParents(
            uiIndex);
    }
}

void ImageBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->removeFromParents(
            cast_dynamic<ParentFieldContainerPtr>(pElement));
    }
}

void ImageBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->clearParents();
    }
}

void ImageBase::pushToParents(ParentFieldContainerPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(ParentsFieldMask, _mfParents);

    addRef(value);

    _mfParents.push_back(value);
}

void ImageBase::insertIntoParents(UInt32                uiIndex,
                                             ParentFieldContainerPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(ParentsFieldMask, _mfParents);

    MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfParents.insert(fieldIt, value);
}

void ImageBase::replaceInParents(UInt32                uiIndex,
                                                 ParentFieldContainerPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfParents.size())
        return;

    editMField(ParentsFieldMask, _mfParents);

    addRef(value);

    subRef(_mfParents[uiIndex]);

    _mfParents[uiIndex] = value;
}

void ImageBase::replaceInParents(ParentFieldContainerPtrConstArg pOldElem,
                                                  ParentFieldContainerPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfParents.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void ImageBase::removeFromParents(UInt32 uiIndex)
{
    if(uiIndex < _mfParents.size())
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfParents.erase(fieldIt);
    }
}

void ImageBase::removeFromParents(ParentFieldContainerPtrConstArg value)
{
    Int32 iElemIdx = _mfParents.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfParents.erase(fieldIt);
    }
}
void ImageBase::clearParents(void)
{
    editMField(ParentsFieldMask, _mfParents);

    MFParentFieldContainerPtr::iterator       fieldIt  = _mfParents.begin();
    MFParentFieldContainerPtr::const_iterator fieldEnd = _mfParents.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfParents.clear();
}



/*********************************** Non-ptr code ********************************/
void ImageBase::pushToPixel(const UInt8& value)
{
    editMField(PixelFieldMask, _mfPixel);
    _mfPixel.push_back(value);
}

void ImageBase::insertIntoPixel(UInt32                uiIndex,
                                             const UInt8& value   )
{
    editMField(PixelFieldMask, _mfPixel);

    MFUInt8::iterator fieldIt = _mfPixel.begin();

    fieldIt += uiIndex;

    _mfPixel.insert(fieldIt, value);
}

void ImageBase::replaceInPixel(UInt32                uiIndex,
                                                 const UInt8& value   )
{
    if(uiIndex >= _mfPixel.size())
        return;

    editMField(PixelFieldMask, _mfPixel);

    _mfPixel[uiIndex] = value;
}

void ImageBase::replaceInPixel(const UInt8& pOldElem,
                                                  const UInt8& pNewElem)
{
    Int32  elemIdx = _mfPixel.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void ImageBase::removeFromPixel(UInt32 uiIndex)
{
    if(uiIndex < _mfPixel.size())
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += uiIndex;
        _mfPixel.erase(fieldIt);
    }
}

void ImageBase::removeFromPixel(const UInt8& value)
{
    Int32 iElemIdx = _mfPixel.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += iElemIdx;

        _mfPixel.erase(fieldIt);
    }
}
void ImageBase::clearPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    _mfPixel.clear();
}









/*------------------------------ access -----------------------------------*/

UInt32 ImageBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        returnValue += _mfParents.getBinSize();
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        returnValue += _sfDimension.getBinSize();
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        returnValue += _sfWidth.getBinSize();
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        returnValue += _sfHeight.getBinSize();
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        returnValue += _sfDepth.getBinSize();
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        returnValue += _sfBpp.getBinSize();
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        returnValue += _sfMipMapCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        returnValue += _sfFrameCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        returnValue += _sfFrameDelay.getBinSize();
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        returnValue += _sfPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        returnValue += _mfPixel.getBinSize();
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        returnValue += _sfFrameSize.getBinSize();
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        returnValue += _sfName.getBinSize();
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        returnValue += _sfDataType.getBinSize();
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        returnValue += _sfComponentSize.getBinSize();
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        returnValue += _sfSideCount.getBinSize();
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        returnValue += _sfSideSize.getBinSize();
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        returnValue += _sfForceCompressedData.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        returnValue += _sfForceAlphaChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        returnValue += _sfForceColorChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        returnValue += _sfForceAlphaBinary.getBinSize();
    }

    return returnValue;
}

void ImageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyToBin(pMem);
    }
}

void ImageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
ImagePtr ImageBase::createEmpty(void) 
{ 
    ImagePtr returnValue; 
    
    newPtr<Image>(returnValue); 

    return returnValue; 
}

FieldContainerPtr ImageBase::shallowCopy(void) const 
{ 
    ImagePtr returnValue; 

    newPtr(returnValue, dynamic_cast<const Image *>(this)); 

    return returnValue; 
}



/*------------------------- constructors ----------------------------------*/

ImageBase::ImageBase(void) :
    Inherited(),
    _mfParents(),
    _sfDimension(Int32(0)),
    _sfWidth(Int32(0)),
    _sfHeight(Int32(1)),
    _sfDepth(Int32(1)),
    _sfBpp(Int32(1)),
    _sfMipMapCount(Int32(1)),
    _sfFrameCount(Int32(1)),
    _sfFrameDelay(Time(0)),
    _sfPixelFormat(UInt32(Image::OSG_INVALID_PF)),
    _mfPixel(),
    _sfFrameSize(Int32(0)),
    _sfName(),
    _sfDataType(Int32(GL_UNSIGNED_BYTE)),
    _sfComponentSize(Int32(1)),
    _sfSideCount(Int32(1)),
    _sfSideSize(Int32(0)),
    _sfForceCompressedData(bool(false)),
    _sfForceAlphaChannel(bool(false)),
    _sfForceColorChannel(bool(false)),
    _sfForceAlphaBinary(bool(false))
{
}

ImageBase::ImageBase(const ImageBase &source) :
    Inherited(source),
    _mfParents(),
    _sfDimension(source._sfDimension),
    _sfWidth(source._sfWidth),
    _sfHeight(source._sfHeight),
    _sfDepth(source._sfDepth),
    _sfBpp(source._sfBpp),
    _sfMipMapCount(source._sfMipMapCount),
    _sfFrameCount(source._sfFrameCount),
    _sfFrameDelay(source._sfFrameDelay),
    _sfPixelFormat(source._sfPixelFormat),
    _mfPixel(source._mfPixel),
    _sfFrameSize(source._sfFrameSize),
    _sfName(source._sfName),
    _sfDataType(source._sfDataType),
    _sfComponentSize(source._sfComponentSize),
    _sfSideCount(source._sfSideCount),
    _sfSideSize(source._sfSideSize),
    _sfForceCompressedData(source._sfForceCompressedData),
    _sfForceAlphaChannel(source._sfForceAlphaChannel),
    _sfForceColorChannel(source._sfForceColorChannel),
    _sfForceAlphaBinary(source._sfForceAlphaBinary)
{
}

/*-------------------------- destructors ----------------------------------*/

ImageBase::~ImageBase(void)
{
}

void ImageBase::onCreate(const Image *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        MFParentFieldContainerPtr::const_iterator ParentsIt  = 
            source->_mfParents.begin();
        MFParentFieldContainerPtr::const_iterator ParentsEnd = 
            source->_mfParents.end  ();

        while(ParentsIt != ParentsEnd)
        {
            this->pushToParents(*ParentsIt);

            ++ParentsIt;
        }
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<ImageBase *>(&oFrom),
                   whichField, 
                   syncMode, 
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ImageBase *>(&oFrom), 
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void ImageBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ImageBase::createAspectCopy(void) const
{
    ImagePtr returnValue; 

    newAspectCopy(returnValue, 
                  dynamic_cast<const Image *>(this)); 

    return returnValue; 
}
#endif

void ImageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Image *>(this)->clearParents();
}


#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ImagePtr>::_type("ImagePtr", "AttachmentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ImagePtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, ImagePtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, ImagePtr);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGIMAGEBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGIMAGEBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGIMAGEFIELDS_HEADER_CVSID;
}

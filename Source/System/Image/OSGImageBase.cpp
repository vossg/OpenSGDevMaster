/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Image!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGL.h"                        // DataType default header

#include "OSGFieldContainer.h"          // Parents Class

#include "OSGImageBase.h"
#include "OSGImage.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Image
    1D/2D/3D Image with various pixel types data, optionally also can hold
    mipMap and simple multi-frame data.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var FieldContainer * ImageBase::_mfParents
    
*/

/*! \var Int32           ImageBase::_sfDimension
    Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.
*/

/*! \var Int32           ImageBase::_sfWidth
    
*/

/*! \var Int32           ImageBase::_sfHeight
    
*/

/*! \var Int32           ImageBase::_sfDepth
    
*/

/*! \var Int32           ImageBase::_sfBpp
    Bytes of data per pixel.
*/

/*! \var Int32           ImageBase::_sfMipMapCount
    
*/

/*! \var Int32           ImageBase::_sfFrameCount
    The number of frames in the data.
*/

/*! \var Time            ImageBase::_sfFrameDelay
    Time between frames.  Determines the frame rate.
*/

/*! \var UInt32          ImageBase::_sfPixelFormat
    
*/

/*! \var UInt8           ImageBase::_mfPixel
    The pixel data buffer. This is where the data for the image is stored.
*/

/*! \var Int32           ImageBase::_sfFrameSize
    
*/

/*! \var std::string     ImageBase::_sfName
    Texture file path.
*/

/*! \var Int32           ImageBase::_sfDataType
    Type of image data.
*/

/*! \var Int32           ImageBase::_sfComponentSize
    Size (in byte) of a single component of the image. Necessary
    for High Dynamic Range and other higher-level image types.
*/

/*! \var Int32           ImageBase::_sfSideCount
    
*/

/*! \var Int32           ImageBase::_sfSideSize
    
*/

/*! \var bool            ImageBase::_sfForceCompressedData
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceColorChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaBinary
    Set to true if using the image to prevent depth sorting for 
    SimpleTexturedMaterials using this Image.
*/

/*! \var Real32          ImageBase::_sfResX
    
*/

/*! \var Real32          ImageBase::_sfResY
    
*/

/*! \var UInt16          ImageBase::_sfResUnit
    resolution unit (invalid=0, none=1, inch=2)
*/

/*! \var bool            ImageBase::_sfClearOnLoad
    Set to true if the image data should be cleared after it has been uploaded to the graphics
    card and is no longer needed in main memory.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<Image *, nsOSG>::_type(
    "ImagePtr", 
    "AttachmentContainerPtr", 
    Image::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(Image *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Image *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Image *,
                           nsOSG)

DataType &FieldTraits< Image *, nsOSG + 1 >::getType(void)
{
    return FieldTraits<Image *, nsOSG>::getType();
}


OSG_EXPORT_PTR_SFIELD(ChildPointerSField,
                      Image *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void ImageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFParentFieldContainerPtr::Description(
        MFParentFieldContainerPtr::getClassType(),
        "parents",
        "",
        ParentsFieldId, ParentsFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast     <FieldEditMethodSig>(&Image::invalidEditField),
        static_cast     <FieldGetMethodSig >(&Image::invalidGetField));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dimension",
        "Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n",
        DimensionFieldId, DimensionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleDimension),
        static_cast<FieldGetMethodSig >(&Image::getHandleDimension));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "width",
        "",
        WidthFieldId, WidthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleWidth),
        static_cast<FieldGetMethodSig >(&Image::getHandleWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "height",
        "",
        HeightFieldId, HeightFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleHeight),
        static_cast<FieldGetMethodSig >(&Image::getHandleHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "depth",
        "",
        DepthFieldId, DepthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleDepth),
        static_cast<FieldGetMethodSig >(&Image::getHandleDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "bpp",
        "Bytes of data per pixel.\n",
        BppFieldId, BppFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleBpp),
        static_cast<FieldGetMethodSig >(&Image::getHandleBpp));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "mipMapCount",
        "",
        MipMapCountFieldId, MipMapCountFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleMipMapCount),
        static_cast<FieldGetMethodSig >(&Image::getHandleMipMapCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameCount",
        "The number of frames in the data.\n",
        FrameCountFieldId, FrameCountFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleFrameCount),
        static_cast<FieldGetMethodSig >(&Image::getHandleFrameCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTime::Description(
        SFTime::getClassType(),
        "frameDelay",
        "Time between frames.  Determines the frame rate.\n",
        FrameDelayFieldId, FrameDelayFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleFrameDelay),
        static_cast<FieldGetMethodSig >(&Image::getHandleFrameDelay));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pixelFormat",
        "",
        PixelFormatFieldId, PixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandlePixelFormat),
        static_cast<FieldGetMethodSig >(&Image::getHandlePixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "pixel",
        "The pixel data buffer. This is where the data for the image is stored.\n",
        PixelFieldId, PixelFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandlePixel),
        static_cast<FieldGetMethodSig >(&Image::getHandlePixel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameSize",
        "",
        FrameSizeFieldId, FrameSizeFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleFrameSize),
        static_cast<FieldGetMethodSig >(&Image::getHandleFrameSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "name",
        "Texture file path.\n",
        NameFieldId, NameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleName),
        static_cast<FieldGetMethodSig >(&Image::getHandleName));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dataType",
        "Type of image data.\n",
        DataTypeFieldId, DataTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleDataType),
        static_cast<FieldGetMethodSig >(&Image::getHandleDataType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "componentSize",
        "Size (in byte) of a single component of the image. Necessary\n"
        "for High Dynamic Range and other higher-level image types.\n",
        ComponentSizeFieldId, ComponentSizeFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleComponentSize),
        static_cast<FieldGetMethodSig >(&Image::getHandleComponentSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideCount",
        "",
        SideCountFieldId, SideCountFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleSideCount),
        static_cast<FieldGetMethodSig >(&Image::getHandleSideCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideSize",
        "",
        SideSizeFieldId, SideSizeFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleSideSize),
        static_cast<FieldGetMethodSig >(&Image::getHandleSideSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceCompressedData",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceCompressedDataFieldId, ForceCompressedDataFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleForceCompressedData),
        static_cast<FieldGetMethodSig >(&Image::getHandleForceCompressedData));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceAlphaChannelFieldId, ForceAlphaChannelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleForceAlphaChannel),
        static_cast<FieldGetMethodSig >(&Image::getHandleForceAlphaChannel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceColorChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceColorChannelFieldId, ForceColorChannelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleForceColorChannel),
        static_cast<FieldGetMethodSig >(&Image::getHandleForceColorChannel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaBinary",
        "Set to true if using the image to prevent depth sorting for \n"
        "SimpleTexturedMaterials using this Image.\n",
        ForceAlphaBinaryFieldId, ForceAlphaBinaryFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleForceAlphaBinary),
        static_cast<FieldGetMethodSig >(&Image::getHandleForceAlphaBinary));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "resX",
        "",
        ResXFieldId, ResXFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleResX),
        static_cast<FieldGetMethodSig >(&Image::getHandleResX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "resY",
        "",
        ResYFieldId, ResYFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleResY),
        static_cast<FieldGetMethodSig >(&Image::getHandleResY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt16::Description(
        SFUInt16::getClassType(),
        "resUnit",
        "resolution unit (invalid=0, none=1, inch=2)\n",
        ResUnitFieldId, ResUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleResUnit),
        static_cast<FieldGetMethodSig >(&Image::getHandleResUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "clearOnLoad",
        "Set to true if the image data should be cleared after it has been uploaded to the graphics\n"
        "card and is no longer needed in main memory.\n",
        ClearOnLoadFieldId, ClearOnLoadFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Image::editHandleClearOnLoad),
        static_cast<FieldGetMethodSig >(&Image::getHandleClearOnLoad));

    oType.addInitialDesc(pDesc);
}


ImageBase::TypeObject ImageBase::_type(
    ImageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&ImageBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&Image::initMethod),
    reinterpret_cast<ExitContainerF>(&Image::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&Image::classDescInserter)),
    false,
    (ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask),
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"Image\"\n"
    "   parent=\"AttachmentContainer\"\n"
    "   library=\"System\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   fieldsUnmarkedOnCreate=\"(ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask)\"\n"
    "   childFields=\"single\"\n"
    "   docGroupBase=\"GrpSystemImage\"\n"
    "   >\n"
    "\n"
    "  1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "  mipMap and simple multi-frame data.\n"
    "\n"
    "  <Field\n"
    "\t name=\"parents\"\n"
    "\t type=\"FieldContainer\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"internal\"\n"
    "\t access=\"none\"\n"
    "     category=\"parentpointer\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"dimension\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tImage dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"width\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"height\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"depth\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"bpp\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Bytes of data per pixel.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"mipMapCount\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"frameCount\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    The number of frames in the data.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"frameDelay\"\n"
    "\t type=\"Time\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Time between frames.  Determines the frame rate.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"pixelFormat\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"Image::OSG_INVALID_PF\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"pixel\"\n"
    "\t type=\"UInt8\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    The pixel data buffer. This is where the data for the image is stored.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"frameSize\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"internal\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"name\"\n"
    "\t type=\"std::string\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tTexture file path.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"dataType\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_UNSIGNED_BYTE\"\n"
    "\t defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tType of image data.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"componentSize\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"internal\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"protected\"\n"
    "\t >\n"
    "\tSize (in byte) of a single component of the image. Necessary\n"
    "    for High Dynamic Range and other higher-level image types.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"sideCount\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"sideSize\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"internal\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"forceCompressedData\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Set to true if using the image to keep unknown data for textures.\n"
    "    Generally used in conjunction with TextureChunk::externalFormat.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"forceAlphaChannel\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Set to true if using the image to keep unknown data for textures.\n"
    "    Generally used in conjunction with TextureChunk::externalFormat.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"forceColorChannel\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Set to true if using the image to keep unknown data for textures.\n"
    "    Generally used in conjunction with TextureChunk::externalFormat.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"forceAlphaBinary\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Set to true if using the image to prevent depth sorting for \n"
    "    SimpleTexturedMaterials using this Image.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"resX\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"72.0f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"resY\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"72.0f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"resUnit\"\n"
    "\t type=\"UInt16\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"2\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tresolution unit (invalid=0, none=1, inch=2)\n"
    "  </Field>\t\n"
    "  <Field\n"
    "\t name=\"clearOnLoad\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "    Set to true if the image data should be cleared after it has been uploaded to the graphics\n"
    "    card and is no longer needed in main memory.\n"
    "  </Field>\n"
    "</FieldContainer>\n",
    "1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "mipMap and simple multi-frame data.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ImageBase::getType(void)
{
    return _type;
}

const FieldContainerType &ImageBase::getType(void) const
{
    return _type;
}

UInt32 ImageBase::getContainerSize(void) const
{
    return sizeof(Image);
}

/*------------------------- decorator get ------------------------------*/



SFInt32 *ImageBase::editSFDimension(void)
{
    editSField(DimensionFieldMask);

    return &_sfDimension;
}

const SFInt32 *ImageBase::getSFDimension(void) const
{
    return &_sfDimension;
}


SFInt32 *ImageBase::editSFWidth(void)
{
    editSField(WidthFieldMask);

    return &_sfWidth;
}

const SFInt32 *ImageBase::getSFWidth(void) const
{
    return &_sfWidth;
}


SFInt32 *ImageBase::editSFHeight(void)
{
    editSField(HeightFieldMask);

    return &_sfHeight;
}

const SFInt32 *ImageBase::getSFHeight(void) const
{
    return &_sfHeight;
}


SFInt32 *ImageBase::editSFDepth(void)
{
    editSField(DepthFieldMask);

    return &_sfDepth;
}

const SFInt32 *ImageBase::getSFDepth(void) const
{
    return &_sfDepth;
}


SFInt32 *ImageBase::editSFBpp(void)
{
    editSField(BppFieldMask);

    return &_sfBpp;
}

const SFInt32 *ImageBase::getSFBpp(void) const
{
    return &_sfBpp;
}


SFInt32 *ImageBase::editSFMipMapCount(void)
{
    editSField(MipMapCountFieldMask);

    return &_sfMipMapCount;
}

const SFInt32 *ImageBase::getSFMipMapCount(void) const
{
    return &_sfMipMapCount;
}


SFInt32 *ImageBase::editSFFrameCount(void)
{
    editSField(FrameCountFieldMask);

    return &_sfFrameCount;
}

const SFInt32 *ImageBase::getSFFrameCount(void) const
{
    return &_sfFrameCount;
}


SFTime *ImageBase::editSFFrameDelay(void)
{
    editSField(FrameDelayFieldMask);

    return &_sfFrameDelay;
}

const SFTime *ImageBase::getSFFrameDelay(void) const
{
    return &_sfFrameDelay;
}


SFUInt32 *ImageBase::editSFPixelFormat(void)
{
    editSField(PixelFormatFieldMask);

    return &_sfPixelFormat;
}

const SFUInt32 *ImageBase::getSFPixelFormat(void) const
{
    return &_sfPixelFormat;
}


MFUInt8 *ImageBase::editMFPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    return &_mfPixel;
}

const MFUInt8 *ImageBase::getMFPixel(void) const
{
    return &_mfPixel;
}


SFInt32 *ImageBase::editSFFrameSize(void)
{
    editSField(FrameSizeFieldMask);

    return &_sfFrameSize;
}

const SFInt32 *ImageBase::getSFFrameSize(void) const
{
    return &_sfFrameSize;
}


SFString *ImageBase::editSFName(void)
{
    editSField(NameFieldMask);

    return &_sfName;
}

const SFString *ImageBase::getSFName(void) const
{
    return &_sfName;
}


SFInt32 *ImageBase::editSFDataType(void)
{
    editSField(DataTypeFieldMask);

    return &_sfDataType;
}

const SFInt32 *ImageBase::getSFDataType(void) const
{
    return &_sfDataType;
}


SFInt32 *ImageBase::editSFComponentSize(void)
{
    editSField(ComponentSizeFieldMask);

    return &_sfComponentSize;
}

const SFInt32 *ImageBase::getSFComponentSize(void) const
{
    return &_sfComponentSize;
}


SFInt32 *ImageBase::editSFSideCount(void)
{
    editSField(SideCountFieldMask);

    return &_sfSideCount;
}

const SFInt32 *ImageBase::getSFSideCount(void) const
{
    return &_sfSideCount;
}


SFInt32 *ImageBase::editSFSideSize(void)
{
    editSField(SideSizeFieldMask);

    return &_sfSideSize;
}

const SFInt32 *ImageBase::getSFSideSize(void) const
{
    return &_sfSideSize;
}


SFBool *ImageBase::editSFForceCompressedData(void)
{
    editSField(ForceCompressedDataFieldMask);

    return &_sfForceCompressedData;
}

const SFBool *ImageBase::getSFForceCompressedData(void) const
{
    return &_sfForceCompressedData;
}


SFBool *ImageBase::editSFForceAlphaChannel(void)
{
    editSField(ForceAlphaChannelFieldMask);

    return &_sfForceAlphaChannel;
}

const SFBool *ImageBase::getSFForceAlphaChannel(void) const
{
    return &_sfForceAlphaChannel;
}


SFBool *ImageBase::editSFForceColorChannel(void)
{
    editSField(ForceColorChannelFieldMask);

    return &_sfForceColorChannel;
}

const SFBool *ImageBase::getSFForceColorChannel(void) const
{
    return &_sfForceColorChannel;
}


SFBool *ImageBase::editSFForceAlphaBinary(void)
{
    editSField(ForceAlphaBinaryFieldMask);

    return &_sfForceAlphaBinary;
}

const SFBool *ImageBase::getSFForceAlphaBinary(void) const
{
    return &_sfForceAlphaBinary;
}


SFReal32 *ImageBase::editSFResX(void)
{
    editSField(ResXFieldMask);

    return &_sfResX;
}

const SFReal32 *ImageBase::getSFResX(void) const
{
    return &_sfResX;
}


SFReal32 *ImageBase::editSFResY(void)
{
    editSField(ResYFieldMask);

    return &_sfResY;
}

const SFReal32 *ImageBase::getSFResY(void) const
{
    return &_sfResY;
}


SFUInt16 *ImageBase::editSFResUnit(void)
{
    editSField(ResUnitFieldMask);

    return &_sfResUnit;
}

const SFUInt16 *ImageBase::getSFResUnit(void) const
{
    return &_sfResUnit;
}


SFBool *ImageBase::editSFClearOnLoad(void)
{
    editSField(ClearOnLoadFieldMask);

    return &_sfClearOnLoad;
}

const SFBool *ImageBase::getSFClearOnLoad(void) const
{
    return &_sfClearOnLoad;
}






/*------------------------------ access -----------------------------------*/

SizeT ImageBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        returnValue += _mfParents.getBinSize();
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        returnValue += _sfDimension.getBinSize();
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        returnValue += _sfWidth.getBinSize();
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        returnValue += _sfHeight.getBinSize();
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        returnValue += _sfDepth.getBinSize();
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        returnValue += _sfBpp.getBinSize();
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        returnValue += _sfMipMapCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        returnValue += _sfFrameCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        returnValue += _sfFrameDelay.getBinSize();
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        returnValue += _sfPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        returnValue += _mfPixel.getBinSize();
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        returnValue += _sfFrameSize.getBinSize();
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        returnValue += _sfName.getBinSize();
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        returnValue += _sfDataType.getBinSize();
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        returnValue += _sfComponentSize.getBinSize();
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        returnValue += _sfSideCount.getBinSize();
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        returnValue += _sfSideSize.getBinSize();
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        returnValue += _sfForceCompressedData.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        returnValue += _sfForceAlphaChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        returnValue += _sfForceColorChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        returnValue += _sfForceAlphaBinary.getBinSize();
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        returnValue += _sfResX.getBinSize();
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        returnValue += _sfResY.getBinSize();
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        returnValue += _sfResUnit.getBinSize();
    }
    if(FieldBits::NoField != (ClearOnLoadFieldMask & whichField))
    {
        returnValue += _sfClearOnLoad.getBinSize();
    }

    return returnValue;
}

void ImageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        _sfResX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        _sfResY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        _sfResUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClearOnLoadFieldMask & whichField))
    {
        _sfClearOnLoad.copyToBin(pMem);
    }
}

void ImageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        editMField(ParentsFieldMask, _mfParents);
        _mfParents.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        editSField(DimensionFieldMask);
        _sfDimension.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        editSField(WidthFieldMask);
        _sfWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        editSField(HeightFieldMask);
        _sfHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        editSField(DepthFieldMask);
        _sfDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        editSField(BppFieldMask);
        _sfBpp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        editSField(MipMapCountFieldMask);
        _sfMipMapCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        editSField(FrameCountFieldMask);
        _sfFrameCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        editSField(FrameDelayFieldMask);
        _sfFrameDelay.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        editSField(PixelFormatFieldMask);
        _sfPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        editMField(PixelFieldMask, _mfPixel);
        _mfPixel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        editSField(FrameSizeFieldMask);
        _sfFrameSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        editSField(NameFieldMask);
        _sfName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        editSField(DataTypeFieldMask);
        _sfDataType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        editSField(ComponentSizeFieldMask);
        _sfComponentSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        editSField(SideCountFieldMask);
        _sfSideCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        editSField(SideSizeFieldMask);
        _sfSideSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        editSField(ForceCompressedDataFieldMask);
        _sfForceCompressedData.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        editSField(ForceAlphaChannelFieldMask);
        _sfForceAlphaChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        editSField(ForceColorChannelFieldMask);
        _sfForceColorChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        editSField(ForceAlphaBinaryFieldMask);
        _sfForceAlphaBinary.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResXFieldMask & whichField))
    {
        editSField(ResXFieldMask);
        _sfResX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResYFieldMask & whichField))
    {
        editSField(ResYFieldMask);
        _sfResY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ResUnitFieldMask & whichField))
    {
        editSField(ResUnitFieldMask);
        _sfResUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClearOnLoadFieldMask & whichField))
    {
        editSField(ClearOnLoadFieldMask);
        _sfClearOnLoad.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ImageTransitPtr ImageBase::createLocal(BitVector bFlags)
{
    ImageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Image>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
ImageTransitPtr ImageBase::createDependent(BitVector bFlags)
{
    ImageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Image>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ImageTransitPtr ImageBase::create(void)
{
    ImageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Image>(tmpPtr);
    }

    return fc;
}

Image *ImageBase::createEmptyLocal(BitVector bFlags)
{
    Image *returnValue;

    newPtr<Image>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Image *ImageBase::createEmpty(void)
{
    Image *returnValue;

    newPtr<Image>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ImageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Image *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Image *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ImageBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Image *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Image *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr ImageBase::shallowCopy(void) const
{
    Image *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Image *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ImageBase::ImageBase(void) :
    Inherited(),
    _mfParents                (),
    _sfDimension              (Int32(0)),
    _sfWidth                  (Int32(0)),
    _sfHeight                 (Int32(1)),
    _sfDepth                  (Int32(1)),
    _sfBpp                    (Int32(1)),
    _sfMipMapCount            (Int32(1)),
    _sfFrameCount             (Int32(1)),
    _sfFrameDelay             (Time(0)),
    _sfPixelFormat            (UInt32(Image::OSG_INVALID_PF)),
    _mfPixel                  (),
    _sfFrameSize              (Int32(0)),
    _sfName                   (),
    _sfDataType               (Int32(GL_UNSIGNED_BYTE)),
    _sfComponentSize          (Int32(1)),
    _sfSideCount              (Int32(1)),
    _sfSideSize               (Int32(0)),
    _sfForceCompressedData    (bool(false)),
    _sfForceAlphaChannel      (bool(false)),
    _sfForceColorChannel      (bool(false)),
    _sfForceAlphaBinary       (bool(false)),
    _sfResX                   (Real32(72.0f)),
    _sfResY                   (Real32(72.0f)),
    _sfResUnit                (UInt16(2)),
    _sfClearOnLoad            (bool(false))
{
}

ImageBase::ImageBase(const ImageBase &source) :
    Inherited(source),
    _mfParents                (),
    _sfDimension              (source._sfDimension              ),
    _sfWidth                  (source._sfWidth                  ),
    _sfHeight                 (source._sfHeight                 ),
    _sfDepth                  (source._sfDepth                  ),
    _sfBpp                    (source._sfBpp                    ),
    _sfMipMapCount            (source._sfMipMapCount            ),
    _sfFrameCount             (source._sfFrameCount             ),
    _sfFrameDelay             (source._sfFrameDelay             ),
    _sfPixelFormat            (source._sfPixelFormat            ),
    _mfPixel                  (source._mfPixel                  ),
    _sfFrameSize              (source._sfFrameSize              ),
    _sfName                   (source._sfName                   ),
    _sfDataType               (source._sfDataType               ),
    _sfComponentSize          (source._sfComponentSize          ),
    _sfSideCount              (source._sfSideCount              ),
    _sfSideSize               (source._sfSideSize               ),
    _sfForceCompressedData    (source._sfForceCompressedData    ),
    _sfForceAlphaChannel      (source._sfForceAlphaChannel      ),
    _sfForceColorChannel      (source._sfForceColorChannel      ),
    _sfForceAlphaBinary       (source._sfForceAlphaBinary       ),
    _sfResX                   (source._sfResX                   ),
    _sfResY                   (source._sfResY                   ),
    _sfResUnit                (source._sfResUnit                ),
    _sfClearOnLoad            (source._sfClearOnLoad            )
{
}


/*-------------------------- destructors ----------------------------------*/

ImageBase::~ImageBase(void)
{
}
/*-------------------------------------------------------------------------*/
/* Parent linking                                                          */

bool ImageBase::linkParent(
    FieldContainer * const pParent,
    UInt16           const childFieldId,
    UInt16           const parentFieldId )
{
    if(parentFieldId == ParentsFieldId)
    {
        FieldContainer * pTypedParent =
            dynamic_cast< FieldContainer * >(pParent);

        if(pTypedParent != NULL)
        {
            editMField(ParentsFieldMask, _mfParents);

            _mfParents.push_back(pTypedParent, childFieldId);

            return true;
        }

        return false;
    }

    return Inherited::linkParent(pParent, childFieldId, parentFieldId);
}

bool ImageBase::unlinkParent(
    FieldContainer * const pParent,
    UInt16           const parentFieldId)
{
    if(parentFieldId == ParentsFieldId)
    {
        FieldContainer * pTypedParent =
            dynamic_cast< FieldContainer * >(pParent);

        if(pTypedParent != NULL)
        {
            Int32 iParentIdx = _mfParents.findIndex(pTypedParent);

            if(iParentIdx != -1)
            {
                editMField(ParentsFieldMask, _mfParents);

                _mfParents.erase(iParentIdx);

                return true;
            }

            SWARNING << "Child (["          << this
                     << "] id ["            << this->getId()
                     << "] type ["          << this->getType().getCName()
                     << "] parentFieldId [" << parentFieldId
                     << "]) - Parent (["    << pParent
                     << "] id ["            << pParent->getId()
                     << "] type ["          << pParent->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    return Inherited::unlinkParent(pParent, parentFieldId);
}



GetFieldHandlePtr ImageBase::getHandleParents         (void) const
{
    MFParentFieldContainerPtr::GetHandlePtr returnValue;

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleParents        (void)
{
    EditFieldHandlePtr returnValue;

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDimension       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDimension,
             this->getType().getFieldDesc(DimensionFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDimension      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDimension,
             this->getType().getFieldDesc(DimensionFieldId),
             this));


    editSField(DimensionFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleWidth           (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfWidth,
             this->getType().getFieldDesc(WidthFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleWidth          (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfWidth,
             this->getType().getFieldDesc(WidthFieldId),
             this));


    editSField(WidthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleHeight          (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfHeight,
             this->getType().getFieldDesc(HeightFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleHeight         (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfHeight,
             this->getType().getFieldDesc(HeightFieldId),
             this));


    editSField(HeightFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDepth           (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDepth,
             this->getType().getFieldDesc(DepthFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDepth          (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDepth,
             this->getType().getFieldDesc(DepthFieldId),
             this));


    editSField(DepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleBpp             (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfBpp,
             this->getType().getFieldDesc(BppFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleBpp            (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfBpp,
             this->getType().getFieldDesc(BppFieldId),
             this));


    editSField(BppFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleMipMapCount     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfMipMapCount,
             this->getType().getFieldDesc(MipMapCountFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleMipMapCount    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfMipMapCount,
             this->getType().getFieldDesc(MipMapCountFieldId),
             this));


    editSField(MipMapCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameCount      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFrameCount,
             this->getType().getFieldDesc(FrameCountFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameCount     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFrameCount,
             this->getType().getFieldDesc(FrameCountFieldId),
             this));


    editSField(FrameCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameDelay      (void) const
{
    SFTime::GetHandlePtr returnValue(
        new  SFTime::GetHandle(
             &_sfFrameDelay,
             this->getType().getFieldDesc(FrameDelayFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameDelay     (void)
{
    SFTime::EditHandlePtr returnValue(
        new  SFTime::EditHandle(
             &_sfFrameDelay,
             this->getType().getFieldDesc(FrameDelayFieldId),
             this));


    editSField(FrameDelayFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandlePixelFormat     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfPixelFormat,
             this->getType().getFieldDesc(PixelFormatFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandlePixelFormat    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfPixelFormat,
             this->getType().getFieldDesc(PixelFormatFieldId),
             this));


    editSField(PixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandlePixel           (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfPixel,
             this->getType().getFieldDesc(PixelFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandlePixel          (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfPixel,
             this->getType().getFieldDesc(PixelFieldId),
             this));


    editMField(PixelFieldMask, _mfPixel);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleFrameSize       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFrameSize,
             this->getType().getFieldDesc(FrameSizeFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleFrameSize      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFrameSize,
             this->getType().getFieldDesc(FrameSizeFieldId),
             this));


    editSField(FrameSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleName            (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfName,
             this->getType().getFieldDesc(NameFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleName           (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfName,
             this->getType().getFieldDesc(NameFieldId),
             this));


    editSField(NameFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleDataType        (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDataType,
             this->getType().getFieldDesc(DataTypeFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleDataType       (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDataType,
             this->getType().getFieldDesc(DataTypeFieldId),
             this));


    editSField(DataTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleComponentSize   (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfComponentSize,
             this->getType().getFieldDesc(ComponentSizeFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleComponentSize  (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfComponentSize,
             this->getType().getFieldDesc(ComponentSizeFieldId),
             this));


    editSField(ComponentSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleSideCount       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSideCount,
             this->getType().getFieldDesc(SideCountFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleSideCount      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSideCount,
             this->getType().getFieldDesc(SideCountFieldId),
             this));


    editSField(SideCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleSideSize        (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSideSize,
             this->getType().getFieldDesc(SideSizeFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleSideSize       (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSideSize,
             this->getType().getFieldDesc(SideSizeFieldId),
             this));


    editSField(SideSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceCompressedData (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceCompressedData,
             this->getType().getFieldDesc(ForceCompressedDataFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceCompressedData(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceCompressedData,
             this->getType().getFieldDesc(ForceCompressedDataFieldId),
             this));


    editSField(ForceCompressedDataFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceAlphaChannel (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceAlphaChannel,
             this->getType().getFieldDesc(ForceAlphaChannelFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceAlphaChannel(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceAlphaChannel,
             this->getType().getFieldDesc(ForceAlphaChannelFieldId),
             this));


    editSField(ForceAlphaChannelFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceColorChannel (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceColorChannel,
             this->getType().getFieldDesc(ForceColorChannelFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceColorChannel(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceColorChannel,
             this->getType().getFieldDesc(ForceColorChannelFieldId),
             this));


    editSField(ForceColorChannelFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleForceAlphaBinary (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceAlphaBinary,
             this->getType().getFieldDesc(ForceAlphaBinaryFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleForceAlphaBinary(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceAlphaBinary,
             this->getType().getFieldDesc(ForceAlphaBinaryFieldId),
             this));


    editSField(ForceAlphaBinaryFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResX            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfResX,
             this->getType().getFieldDesc(ResXFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResX           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfResX,
             this->getType().getFieldDesc(ResXFieldId),
             this));


    editSField(ResXFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResY            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfResY,
             this->getType().getFieldDesc(ResYFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResY           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfResY,
             this->getType().getFieldDesc(ResYFieldId),
             this));


    editSField(ResYFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleResUnit         (void) const
{
    SFUInt16::GetHandlePtr returnValue(
        new  SFUInt16::GetHandle(
             &_sfResUnit,
             this->getType().getFieldDesc(ResUnitFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleResUnit        (void)
{
    SFUInt16::EditHandlePtr returnValue(
        new  SFUInt16::EditHandle(
             &_sfResUnit,
             this->getType().getFieldDesc(ResUnitFieldId),
             this));


    editSField(ResUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr ImageBase::getHandleClearOnLoad     (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfClearOnLoad,
             this->getType().getFieldDesc(ClearOnLoadFieldId),
             const_cast<ImageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ImageBase::editHandleClearOnLoad    (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfClearOnLoad,
             this->getType().getFieldDesc(ClearOnLoadFieldId),
             this));


    editSField(ClearOnLoadFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Image *pThis = static_cast<Image *>(this);

    pThis->execSync(static_cast<Image *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ImageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Image *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Image *>(pRefAspect),
                  dynamic_cast<const Image *>(this));

    return returnValue;
}
#endif

void ImageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfPixel.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

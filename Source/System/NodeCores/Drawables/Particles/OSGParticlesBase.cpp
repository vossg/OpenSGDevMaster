/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Particles!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEPARTICLESINST

#include <stdlib.h>
#include <stdio.h>

#include <OSGConfig.h>



#include <OSGGeoVectorProperty.h> // Positions Class
#include <OSGGeoVectorProperty.h> // SecPositions Class
#include <OSGGeoVectorProperty.h> // Colors Class
#include <OSGGeoVectorProperty.h> // Normals Class

#include "OSGParticlesBase.h"
#include "OSGParticles.h"

OSG_USING_NAMESPACE

// Field descriptions

/*! \var UInt32 ParticlesBase::_sfMode
    	The particle mode, see OSG::Particles::modeE for options.

*/
/*! \var GeoVectorPropertyPtr ParticlesBase::_sfPositions
            The positions of the particles. This is the primary defining
        information for a particle.

*/
/*! \var Vec3f ParticlesBase::_mfSizes
            The particle sizes. If not set (1,1,1) will be used, if only one entry
        is set, it will be used for all particles. If the number of sizes if
        equal to the number of positions every particle will get its own size.
        Most modes only use the X coordinate of the vector. Particles with 
        size[0] == 0 are ignored.

*/
/*! \var GeoVectorPropertyPtr ParticlesBase::_sfSecPositions
            The secondary position of the particle. This information is only used
        by a few rendering modes, e.g. the streak mode. Usually it represents
        the particle's last position.

*/
/*! \var GeoVectorPropertyPtr ParticlesBase::_sfColors
    	The particle colors (optional).

*/
/*! \var GeoVectorPropertyPtr ParticlesBase::_sfNormals
            Most particles will be automatically aligned to the view
        direction. If normals are set they will be used to define the
        direction the particles are facing.

*/
/*! \var Int32 ParticlesBase::_mfIndices
            Indices for the particles. Useful to select subsets of all particles for 
        rendering.

*/
/*! \var Real32 ParticlesBase::_mfTextureZs
            The texture z coordinate of the particles. Useful in conjunction with 3D 
        textures to use different texture images on different particles.

*/
/*! \var UInt32 ParticlesBase::_sfDrawOrder
            Define an optional sorting on the particles, see OSG::Particles::DrawOrderE
        for variants. Default is unordered.

*/
/*! \var bool ParticlesBase::_sfDynamic
            Hint to tell the system whether particles are expected to change position or
        not. Is used to speed up sorting.

*/
/*! \var UInt32 ParticlesBase::_sfPump
    
*/
/*! \var ParticleBSPTree ParticlesBase::_sfBsp
    
*/
/*! \var Int32 ParticlesBase::_sfNumParticles
            Optional number of particles to use. If set to -1, all the particles in 
        pos, or indices if set, will be used.

*/

void ParticlesBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL; 


#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFModeF)(void) const;

    GetSFModeF GetSFMode = &ParticlesBase::getSFMode;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "mode", 
        ModeFieldId, ModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFMode));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(), 
        "positions", 
        PositionsFieldId, PositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFPositions));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(ParticlesBase::*GetMFSizesF)(void) const;

    GetMFSizesF GetMFSizes = &ParticlesBase::getMFSizes;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(), 
        "sizes", 
        SizesFieldId, SizesFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFSizes),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFSizes));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFSizes));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(), 
        "secPositions", 
        SecPositionsFieldId, SecPositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFSecPositions));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(), 
        "colors", 
        ColorsFieldId, ColorsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFColors));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(), 
        "normals", 
        NormalsFieldId, NormalsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFNormals));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFInt32 *(ParticlesBase::*GetMFIndicesF)(void) const;

    GetMFIndicesF GetMFIndices = &ParticlesBase::getMFIndices;
#endif

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(), 
        "indices", 
        IndicesFieldId, IndicesFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFIndices),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFIndices));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFIndices));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFReal32 *(ParticlesBase::*GetMFTextureZsF)(void) const;

    GetMFTextureZsF GetMFTextureZs = &ParticlesBase::getMFTextureZs;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(), 
        "textureZs", 
        TextureZsFieldId, TextureZsFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFTextureZs),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFTextureZs));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFTextureZs));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFDrawOrderF)(void) const;

    GetSFDrawOrderF GetSFDrawOrder = &ParticlesBase::getSFDrawOrder;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "drawOrder", 
        DrawOrderFieldId, DrawOrderFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFDrawOrder),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDrawOrder));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFDrawOrder));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(ParticlesBase::*GetSFDynamicF)(void) const;

    GetSFDynamicF GetSFDynamic = &ParticlesBase::getSFDynamic;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "dynamic", 
        DynamicFieldId, DynamicFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFDynamic),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDynamic));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFDynamic));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFPumpF)(void) const;

    GetSFPumpF GetSFPump = &ParticlesBase::getSFPump;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "pump", 
        PumpFieldId, PumpFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFPump),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPump));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFPump));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFParticleBSPTree *(ParticlesBase::*GetSFBspF)(void) const;

    GetSFBspF GetSFBsp = &ParticlesBase::getSFBsp;
#endif

    pDesc = new SFParticleBSPTree::Description(
        SFParticleBSPTree::getClassType(), 
        "bsp", 
        BspFieldId, BspFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFBsp),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBsp));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFBsp));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(ParticlesBase::*GetSFNumParticlesF)(void) const;

    GetSFNumParticlesF GetSFNumParticles = &ParticlesBase::getSFNumParticles;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "numParticles", 
        NumParticlesFieldId, NumParticlesFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFNumParticles),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFNumParticles));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFNumParticles));
#endif

    oType.addInitialDesc(pDesc);
}


ParticlesBase::TypeObject ParticlesBase::_type(true,
    ParticlesBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ParticlesBase::createEmpty,
    Particles::initMethod,
    (InitalInsertDescFunc) &ParticlesBase::classDescInserter,
    false);

/*------------------------------ get -----------------------------------*/

FieldContainerType &ParticlesBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &ParticlesBase::getType(void) const 
{
    return _type;
} 

UInt32 ParticlesBase::getContainerSize(void) const 
{ 
    return sizeof(Particles); 
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *ParticlesBase::editSFMode(void)
{
    editSField(ModeFieldMask);

    return &_sfMode;
}

const SFUInt32 *ParticlesBase::getSFMode(void) const
{
    return &_sfMode;
}

#ifdef OSG_1_COMPAT
SFUInt32 *ParticlesBase::getSFMode(void)
{
    return this->editSFMode();
}
#endif

//! Get the Particles::_sfPositions field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFPositions(void) const
{
    return &_sfPositions;
}

MFVec3f *ParticlesBase::editMFSizes(void)
{
    editMField(SizesFieldMask, _mfSizes);

    return &_mfSizes;
}

const MFVec3f *ParticlesBase::getMFSizes(void) const
{
    return &_mfSizes;
}

#ifdef OSG_1_COMPAT
MFVec3f *ParticlesBase::getMFSizes(void)
{
    return this->editMFSizes();
}
#endif

//! Get the Particles::_sfSecPositions field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFSecPositions(void) const
{
    return &_sfSecPositions;
}

//! Get the Particles::_sfColors field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFColors(void) const
{
    return &_sfColors;
}

//! Get the Particles::_sfNormals field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFNormals(void) const
{
    return &_sfNormals;
}

MFInt32 *ParticlesBase::editMFIndices(void)
{
    editMField(IndicesFieldMask, _mfIndices);

    return &_mfIndices;
}

const MFInt32 *ParticlesBase::getMFIndices(void) const
{
    return &_mfIndices;
}

#ifdef OSG_1_COMPAT
MFInt32 *ParticlesBase::getMFIndices(void)
{
    return this->editMFIndices();
}
#endif

MFReal32 *ParticlesBase::editMFTextureZs(void)
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    return &_mfTextureZs;
}

const MFReal32 *ParticlesBase::getMFTextureZs(void) const
{
    return &_mfTextureZs;
}

#ifdef OSG_1_COMPAT
MFReal32 *ParticlesBase::getMFTextureZs(void)
{
    return this->editMFTextureZs();
}
#endif

SFUInt32 *ParticlesBase::editSFDrawOrder(void)
{
    editSField(DrawOrderFieldMask);

    return &_sfDrawOrder;
}

const SFUInt32 *ParticlesBase::getSFDrawOrder(void) const
{
    return &_sfDrawOrder;
}

#ifdef OSG_1_COMPAT
SFUInt32 *ParticlesBase::getSFDrawOrder(void)
{
    return this->editSFDrawOrder();
}
#endif

SFBool *ParticlesBase::editSFDynamic(void)
{
    editSField(DynamicFieldMask);

    return &_sfDynamic;
}

const SFBool *ParticlesBase::getSFDynamic(void) const
{
    return &_sfDynamic;
}

#ifdef OSG_1_COMPAT
SFBool *ParticlesBase::getSFDynamic(void)
{
    return this->editSFDynamic();
}
#endif

SFUInt32 *ParticlesBase::editSFPump(void)
{
    editSField(PumpFieldMask);

    return &_sfPump;
}

const SFUInt32 *ParticlesBase::getSFPump(void) const
{
    return &_sfPump;
}

#ifdef OSG_1_COMPAT
SFUInt32 *ParticlesBase::getSFPump(void)
{
    return this->editSFPump();
}
#endif

SFParticleBSPTree *ParticlesBase::editSFBsp(void)
{
    editSField(BspFieldMask);

    return &_sfBsp;
}

const SFParticleBSPTree *ParticlesBase::getSFBsp(void) const
{
    return &_sfBsp;
}

#ifdef OSG_1_COMPAT
SFParticleBSPTree *ParticlesBase::getSFBsp(void)
{
    return this->editSFBsp();
}
#endif

SFInt32 *ParticlesBase::editSFNumParticles(void)
{
    editSField(NumParticlesFieldMask);

    return &_sfNumParticles;
}

const SFInt32 *ParticlesBase::getSFNumParticles(void) const
{
    return &_sfNumParticles;
}

#ifdef OSG_1_COMPAT
SFInt32 *ParticlesBase::getSFNumParticles(void)
{
    return this->editSFNumParticles();
}
#endif


void ParticlesBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == PositionsFieldId)
    {
        static_cast<Particles *>(this)->setPositions(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == SecPositionsFieldId)
    {
        static_cast<Particles *>(this)->setSecPositions(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<Particles *>(this)->setColors(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<Particles *>(this)->setNormals(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
}

void ParticlesBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void ParticlesBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void ParticlesBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void ParticlesBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void ParticlesBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void ParticlesBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == PositionsFieldId)
    {
        static_cast<Particles *>(this)->setPositions(NullFC);
    }
    if(uiFieldId == SecPositionsFieldId)
    {
        static_cast<Particles *>(this)->setSecPositions(NullFC);
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<Particles *>(this)->setColors(NullFC);
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<Particles *>(this)->setNormals(NullFC);
    }
}






/*------------------------------ access -----------------------------------*/

UInt32 ParticlesBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        returnValue += _sfMode.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _sfPositions.getBinSize();
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        returnValue += _mfSizes.getBinSize();
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        returnValue += _sfSecPositions.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _sfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _sfNormals.getBinSize();
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        returnValue += _mfIndices.getBinSize();
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        returnValue += _mfTextureZs.getBinSize();
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        returnValue += _sfDrawOrder.getBinSize();
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        returnValue += _sfDynamic.getBinSize();
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        returnValue += _sfPump.getBinSize();
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        returnValue += _sfBsp.getBinSize();
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        returnValue += _sfNumParticles.getBinSize();
    }

    return returnValue;
}

void ParticlesBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyToBin(pMem);
    }
}

void ParticlesBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
ParticlesPtr ParticlesBase::createEmpty(void) 
{ 
    ParticlesPtr returnValue; 
    
    newPtr<Particles>(returnValue); 

    return returnValue; 
}

FieldContainerPtr ParticlesBase::shallowCopy(void) const 
{ 
    ParticlesPtr returnValue; 

    newPtr(returnValue, dynamic_cast<const Particles *>(this)); 

    return returnValue; 
}



/*------------------------- constructors ----------------------------------*/

ParticlesBase::ParticlesBase(void) :
    Inherited(),
    _sfMode(UInt32(2)),
    _sfPositions(),
    _mfSizes(),
    _sfSecPositions(),
    _sfColors(),
    _sfNormals(),
    _mfIndices(),
    _mfTextureZs(),
    _sfDrawOrder(UInt32(0)),
    _sfDynamic(bool(true)),
    _sfPump(),
    _sfBsp(),
    _sfNumParticles(Int32(-1))
{
}

ParticlesBase::ParticlesBase(const ParticlesBase &source) :
    Inherited(source),
    _sfMode(source._sfMode),
    _sfPositions(),
    _mfSizes(source._mfSizes),
    _sfSecPositions(),
    _sfColors(),
    _sfNormals(),
    _mfIndices(source._mfIndices),
    _mfTextureZs(source._mfTextureZs),
    _sfDrawOrder(source._sfDrawOrder),
    _sfDynamic(source._sfDynamic),
    _sfPump(source._sfPump),
    _sfBsp(source._sfBsp),
    _sfNumParticles(source._sfNumParticles)
{
}

/*-------------------------- destructors ----------------------------------*/

ParticlesBase::~ParticlesBase(void)
{
}

void ParticlesBase::onCreate(const Particles *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setPositions(source->getPositions());

        this->setSecPositions(source->getSecPositions());

        this->setColors(source->getColors());

        this->setNormals(source->getNormals());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<ParticlesBase *>(&oFrom),
                   whichField, 
                   syncMode, 
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ParticlesBase *>(&oFrom), 
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void ParticlesBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ParticlesBase::createAspectCopy(void) const
{
    ParticlesPtr returnValue; 

    newAspectCopy(returnValue, 
                  dynamic_cast<const Particles *>(this)); 

    return returnValue; 
}
#endif

void ParticlesBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Particles *>(this)->setPositions(NullFC);

    static_cast<Particles *>(this)->setSecPositions(NullFC);

    static_cast<Particles *>(this)->setColors(NullFC);

    static_cast<Particles *>(this)->setNormals(NullFC);
}


#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ParticlesPtr>::_type("ParticlesPtr", "MaterialDrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ParticlesPtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, ParticlesPtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, ParticlesPtr);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGPARTICLESBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGPARTICLESBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGPARTICLESFIELDS_HEADER_CVSID;
}

/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Particles!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEPARTICLESINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGGeoVectorProperty.h> // Positions Class
#include <OSGGeoVectorProperty.h> // SecPositions Class
#include <OSGGeoVectorProperty.h> // Colors Class
#include <OSGGeoVectorProperty.h> // Normals Class

#include "OSGParticlesBase.h"
#include "OSGParticles.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Particles
    \ingroup GrpSystemNodeCoresDrawablesParticles

    See \ref PageSystemParticles for details.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var UInt32          ParticlesBase::_sfMode
    The particle mode, see OSG::Particles::modeE for options.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfPositions
    The positions of the particles. This is the primary defining
    information for a particle.
*/

/*! \var Vec3f           ParticlesBase::_mfSizes
    The particle sizes. If not set (1,1,1) will be used, if only one entry
    is set, it will be used for all particles. If the number of sizes if
    equal to the number of positions every particle will get its own size.
    Most modes only use the X coordinate of the vector. Particles with 
    size[0] == 0 are ignored.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfSecPositions
    The secondary position of the particle. This information is only used
    by a few rendering modes, e.g. the streak mode. Usually it represents
    the particle's last position.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfColors
    The particle colors (optional).
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfNormals
    Most particles will be automatically aligned to the view
    direction. If normals are set they will be used to define the
    direction the particles are facing.
*/

/*! \var Int32           ParticlesBase::_mfIndices
    Indices for the particles. Useful to select subsets of all particles for 
    rendering.
*/

/*! \var Real32          ParticlesBase::_mfTextureZs
    The texture z coordinate of the particles. Useful in conjunction with 3D 
    textures to use different texture images on different particles.
*/

/*! \var UInt32          ParticlesBase::_sfDrawOrder
    Define an optional sorting on the particles, see OSG::Particles::DrawOrderE
    for variants. Default is unordered.
*/

/*! \var bool            ParticlesBase::_sfDynamic
    Hint to tell the system whether particles are expected to change position or
    not. Is used to speed up sorting.
*/

/*! \var UInt32          ParticlesBase::_sfPump
    
*/

/*! \var ParticleBSPTree ParticlesBase::_sfBsp
    
*/

/*! \var Int32           ParticlesBase::_sfNumParticles
    Optional number of particles to use. If set to -1, all the particles in 
    pos, or indices if set, will be used.
*/


void ParticlesBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFModeF)(void) const;

    GetSFModeF GetSFMode = &ParticlesBase::getSFMode;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mode",
        "The particle mode, see OSG::Particles::modeE for options.\n",
        ModeFieldId, ModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFMode),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFMode));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(),
        "positions",
        "The positions of the particles. This is the primary defining\n"
        "information for a particle.\n",
        PositionsFieldId, PositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFPositions));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const MFVec3f *(ParticlesBase::*GetMFSizesF)(void) const;

    GetMFSizesF GetMFSizes = &ParticlesBase::getMFSizes;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "sizes",
        "The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
        "is set, it will be used for all particles. If the number of sizes if\n"
        "equal to the number of positions every particle will get its own size.\n"
        "Most modes only use the X coordinate of the vector. Particles with \n"
        "size[0] == 0 are ignored.\n",
        SizesFieldId, SizesFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFSizes),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFSizes));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFSizes));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(),
        "secPositions",
        "The secondary position of the particle. This information is only used\n"
        "by a few rendering modes, e.g. the streak mode. Usually it represents\n"
        "the particle's last position.\n",
        SecPositionsFieldId, SecPositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFSecPositions));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(),
        "colors",
        "The particle colors (optional).\n",
        ColorsFieldId, ColorsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFColors));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGeoVectorPropertyPtr::Description(
        SFGeoVectorPropertyPtr::getClassType(),
        "normals",
        "Most particles will be automatically aligned to the view\n"
        "direction. If normals are set they will be used to define the\n"
        "direction the particles are facing.\n",
        NormalsFieldId, NormalsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ParticlesBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFNormals));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const MFInt32 *(ParticlesBase::*GetMFIndicesF)(void) const;

    GetMFIndicesF GetMFIndices = &ParticlesBase::getMFIndices;
#endif

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(),
        "indices",
        "Indices for the particles. Useful to select subsets of all particles for \n"
        "rendering.\n",
        IndicesFieldId, IndicesFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFIndices),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFIndices));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFIndices));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const MFReal32 *(ParticlesBase::*GetMFTextureZsF)(void) const;

    GetMFTextureZsF GetMFTextureZs = &ParticlesBase::getMFTextureZs;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "textureZs",
        "The texture z coordinate of the particles. Useful in conjunction with 3D \n"
        "textures to use different texture images on different particles.\n",
        TextureZsFieldId, TextureZsFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editMFTextureZs),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFTextureZs));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getMFTextureZs));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFDrawOrderF)(void) const;

    GetSFDrawOrderF GetSFDrawOrder = &ParticlesBase::getSFDrawOrder;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "drawOrder",
        "Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
        "for variants. Default is unordered.\n",
        DrawOrderFieldId, DrawOrderFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFDrawOrder),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDrawOrder));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFDrawOrder));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(ParticlesBase::*GetSFDynamicF)(void) const;

    GetSFDynamicF GetSFDynamic = &ParticlesBase::getSFDynamic;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "dynamic",
        "Hint to tell the system whether particles are expected to change position or\n"
        "not. Is used to speed up sorting.\n",
        DynamicFieldId, DynamicFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFDynamic),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDynamic));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFDynamic));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(ParticlesBase::*GetSFPumpF)(void) const;

    GetSFPumpF GetSFPump = &ParticlesBase::getSFPump;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pump",
        "",
        PumpFieldId, PumpFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFPump),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPump));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFPump));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFParticleBSPTree *(ParticlesBase::*GetSFBspF)(void) const;

    GetSFBspF GetSFBsp = &ParticlesBase::getSFBsp;
#endif

    pDesc = new SFParticleBSPTree::Description(
        SFParticleBSPTree::getClassType(),
        "bsp",
        "",
        BspFieldId, BspFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFBsp),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBsp));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFBsp));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ParticlesBase::*GetSFNumParticlesF)(void) const;

    GetSFNumParticlesF GetSFNumParticles = &ParticlesBase::getSFNumParticles;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numParticles",
        "Optional number of particles to use. If set to -1, all the particles in \n"
        "pos, or indices if set, will be used.\n",
        NumParticlesFieldId, NumParticlesFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ParticlesBase::editSFNumParticles),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFNumParticles));
#else
        reinterpret_cast<FieldGetMethodSig >(&ParticlesBase::getSFNumParticles));
#endif

    oType.addInitialDesc(pDesc);
}


ParticlesBase::TypeObject ParticlesBase::_type(
    ParticlesBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ParticlesBase::createEmpty,
    Particles::initMethod,
    (InitalInsertDescFunc) &ParticlesBase::classDescInserter,
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Particles\"\n"
    "\tparent=\"MaterialDrawable\"\n"
    "\tlibrary=\"Drawable\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    ">\n"
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    "\t<Field\n"
    "\t\tname=\"mode\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"2\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe particle mode, see OSG::Particles::modeE for options.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"positions\"\n"
    "\t\ttype=\"GeoVectorPropertyPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        linkMParent=\"true\"\n"
    "\t>\n"
    "        The positions of the particles. This is the primary defining\n"
    "        information for a particle.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sizes\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
    "        is set, it will be used for all particles. If the number of sizes if\n"
    "        equal to the number of positions every particle will get its own size.\n"
    "        Most modes only use the X coordinate of the vector. Particles with \n"
    "        size[0] == 0 are ignored.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"secPositions\"\n"
    "\t\ttype=\"GeoVectorPropertyPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        linkMParent=\"true\"\n"
    "\t>\n"
    "        The secondary position of the particle. This information is only used\n"
    "        by a few rendering modes, e.g. the streak mode. Usually it represents\n"
    "        the particle's last position.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"colors\"\n"
    "\t\ttype=\"GeoVectorPropertyPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        linkMParent=\"true\"\n"
    "\t>\n"
    "\tThe particle colors (optional).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"normals\"\n"
    "\t\ttype=\"GeoVectorPropertyPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        linkMParent=\"true\"\n"
    "\t>\n"
    "        Most particles will be automatically aligned to the view\n"
    "        direction. If normals are set they will be used to define the\n"
    "        direction the particles are facing.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"indices\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Indices for the particles. Useful to select subsets of all particles for \n"
    "        rendering.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"textureZs\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The texture z coordinate of the particles. Useful in conjunction with 3D \n"
    "        textures to use different texture images on different particles.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"drawOrder\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
    "        for variants. Default is unordered.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dynamic\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Hint to tell the system whether particles are expected to change position or\n"
    "        not. Is used to speed up sorting.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pump\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"private\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bsp\"\n"
    "\t\ttype=\"ParticleBSPTree\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\theader=\"OSGParticleBSP.h\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"numParticles\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "                defaultValue=\"-1\"\n"
    "\t>\n"
    "        Optional number of particles to use. If set to -1, all the particles in \n"
    "        pos, or indices if set, will be used.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ParticlesBase::getType(void)
{
    return _type;
}

const FieldContainerType &ParticlesBase::getType(void) const
{
    return _type;
}

UInt32 ParticlesBase::getContainerSize(void) const
{
    return sizeof(Particles);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *ParticlesBase::editSFMode(void)
{
    editSField(ModeFieldMask);

    return &_sfMode;
}

const SFUInt32 *ParticlesBase::getSFMode(void) const
{
    return &_sfMode;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFMode           (void)
{
    return this->editSFMode           ();
}
#endif

//! Get the Particles::_sfPositions field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFPositions(void) const
{
    return &_sfPositions;
}

MFVec3f *ParticlesBase::editMFSizes(void)
{
    editMField(SizesFieldMask, _mfSizes);

    return &_mfSizes;
}

const MFVec3f *ParticlesBase::getMFSizes(void) const
{
    return &_mfSizes;
}

#ifdef OSG_1_GET_COMPAT
MFVec3f             *ParticlesBase::getMFSizes          (void)
{
    return this->editMFSizes          ();
}
#endif

//! Get the Particles::_sfSecPositions field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFSecPositions(void) const
{
    return &_sfSecPositions;
}

//! Get the Particles::_sfColors field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFColors(void) const
{
    return &_sfColors;
}

//! Get the Particles::_sfNormals field.
const SFGeoVectorPropertyPtr *ParticlesBase::getSFNormals(void) const
{
    return &_sfNormals;
}

MFInt32 *ParticlesBase::editMFIndices(void)
{
    editMField(IndicesFieldMask, _mfIndices);

    return &_mfIndices;
}

const MFInt32 *ParticlesBase::getMFIndices(void) const
{
    return &_mfIndices;
}

#ifdef OSG_1_GET_COMPAT
MFInt32             *ParticlesBase::getMFIndices        (void)
{
    return this->editMFIndices        ();
}
#endif

MFReal32 *ParticlesBase::editMFTextureZs(void)
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    return &_mfTextureZs;
}

const MFReal32 *ParticlesBase::getMFTextureZs(void) const
{
    return &_mfTextureZs;
}

#ifdef OSG_1_GET_COMPAT
MFReal32            *ParticlesBase::getMFTextureZs      (void)
{
    return this->editMFTextureZs      ();
}
#endif

SFUInt32 *ParticlesBase::editSFDrawOrder(void)
{
    editSField(DrawOrderFieldMask);

    return &_sfDrawOrder;
}

const SFUInt32 *ParticlesBase::getSFDrawOrder(void) const
{
    return &_sfDrawOrder;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFDrawOrder      (void)
{
    return this->editSFDrawOrder      ();
}
#endif

SFBool *ParticlesBase::editSFDynamic(void)
{
    editSField(DynamicFieldMask);

    return &_sfDynamic;
}

const SFBool *ParticlesBase::getSFDynamic(void) const
{
    return &_sfDynamic;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ParticlesBase::getSFDynamic        (void)
{
    return this->editSFDynamic        ();
}
#endif

SFUInt32 *ParticlesBase::editSFPump(void)
{
    editSField(PumpFieldMask);

    return &_sfPump;
}

const SFUInt32 *ParticlesBase::getSFPump(void) const
{
    return &_sfPump;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFPump           (void)
{
    return this->editSFPump           ();
}
#endif

SFParticleBSPTree *ParticlesBase::editSFBsp(void)
{
    editSField(BspFieldMask);

    return &_sfBsp;
}

const SFParticleBSPTree *ParticlesBase::getSFBsp(void) const
{
    return &_sfBsp;
}

#ifdef OSG_1_GET_COMPAT
SFParticleBSPTree   *ParticlesBase::getSFBsp            (void)
{
    return this->editSFBsp            ();
}
#endif

SFInt32 *ParticlesBase::editSFNumParticles(void)
{
    editSField(NumParticlesFieldMask);

    return &_sfNumParticles;
}

const SFInt32 *ParticlesBase::getSFNumParticles(void) const
{
    return &_sfNumParticles;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ParticlesBase::getSFNumParticles   (void)
{
    return this->editSFNumParticles   ();
}
#endif


void ParticlesBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == PositionsFieldId)
    {
        static_cast<Particles *>(this)->setPositions(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == SecPositionsFieldId)
    {
        static_cast<Particles *>(this)->setSecPositions(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<Particles *>(this)->setColors(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<Particles *>(this)->setNormals(
            cast_dynamic<GeoVectorPropertyPtr>(pNewElement));
    }
}

void ParticlesBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void ParticlesBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void ParticlesBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void ParticlesBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void ParticlesBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void ParticlesBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == PositionsFieldId)
    {
        static_cast<Particles *>(this)->setPositions(NullFC);
    }
    if(uiFieldId == SecPositionsFieldId)
    {
        static_cast<Particles *>(this)->setSecPositions(NullFC);
    }
    if(uiFieldId == ColorsFieldId)
    {
        static_cast<Particles *>(this)->setColors(NullFC);
    }
    if(uiFieldId == NormalsFieldId)
    {
        static_cast<Particles *>(this)->setNormals(NullFC);
    }
}

/*********************************** Non-ptr code ********************************/
void ParticlesBase::pushToSizes(const Vec3f& value)
{
    editMField(SizesFieldMask, _mfSizes);
    _mfSizes.push_back(value);
}

void ParticlesBase::insertIntoSizes(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(SizesFieldMask, _mfSizes);

    MFVec3f::iterator fieldIt = _mfSizes.begin();

    fieldIt += uiIndex;

    _mfSizes.insert(fieldIt, value);
}

void ParticlesBase::replaceInSizes(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfSizes.size())
        return;

    editMField(SizesFieldMask, _mfSizes);

    _mfSizes[uiIndex] = value;
}

void ParticlesBase::replaceInSizes(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfSizes.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(SizesFieldMask, _mfSizes);

        MFVec3f::iterator fieldIt = _mfSizes.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void ParticlesBase::removeFromSizes(UInt32 uiIndex)
{
    if(uiIndex < _mfSizes.size())
    {
        editMField(SizesFieldMask, _mfSizes);

        MFVec3f::iterator fieldIt = _mfSizes.begin();

        fieldIt += uiIndex;
        _mfSizes.erase(fieldIt);
    }
}

void ParticlesBase::removeFromSizes(const Vec3f& value)
{
    Int32 iElemIdx = _mfSizes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(SizesFieldMask, _mfSizes);

        MFVec3f::iterator fieldIt = _mfSizes.begin();

        fieldIt += iElemIdx;

        _mfSizes.erase(fieldIt);
    }
}

void ParticlesBase::clearSizes(void)
{
    editMField(SizesFieldMask, _mfSizes);

    _mfSizes.clear();
}
/*********************************** Non-ptr code ********************************/
void ParticlesBase::pushToIndices(const Int32& value)
{
    editMField(IndicesFieldMask, _mfIndices);
    _mfIndices.push_back(value);
}

void ParticlesBase::insertIntoIndices(UInt32                uiIndex,
                                                   const Int32& value   )
{
    editMField(IndicesFieldMask, _mfIndices);

    MFInt32::iterator fieldIt = _mfIndices.begin();

    fieldIt += uiIndex;

    _mfIndices.insert(fieldIt, value);
}

void ParticlesBase::replaceInIndices(UInt32                uiIndex,
                                                       const Int32& value   )
{
    if(uiIndex >= _mfIndices.size())
        return;

    editMField(IndicesFieldMask, _mfIndices);

    _mfIndices[uiIndex] = value;
}

void ParticlesBase::replaceInIndices(const Int32& pOldElem,
                                                        const Int32& pNewElem)
{
    Int32  elemIdx = _mfIndices.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(IndicesFieldMask, _mfIndices);

        MFInt32::iterator fieldIt = _mfIndices.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void ParticlesBase::removeFromIndices(UInt32 uiIndex)
{
    if(uiIndex < _mfIndices.size())
    {
        editMField(IndicesFieldMask, _mfIndices);

        MFInt32::iterator fieldIt = _mfIndices.begin();

        fieldIt += uiIndex;
        _mfIndices.erase(fieldIt);
    }
}

void ParticlesBase::removeFromIndices(const Int32& value)
{
    Int32 iElemIdx = _mfIndices.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(IndicesFieldMask, _mfIndices);

        MFInt32::iterator fieldIt = _mfIndices.begin();

        fieldIt += iElemIdx;

        _mfIndices.erase(fieldIt);
    }
}

void ParticlesBase::clearIndices(void)
{
    editMField(IndicesFieldMask, _mfIndices);

    _mfIndices.clear();
}
/*********************************** Non-ptr code ********************************/
void ParticlesBase::pushToTextureZs(const Real32& value)
{
    editMField(TextureZsFieldMask, _mfTextureZs);
    _mfTextureZs.push_back(value);
}

void ParticlesBase::insertIntoTextureZs(UInt32                uiIndex,
                                                   const Real32& value   )
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    MFReal32::iterator fieldIt = _mfTextureZs.begin();

    fieldIt += uiIndex;

    _mfTextureZs.insert(fieldIt, value);
}

void ParticlesBase::replaceInTextureZs(UInt32                uiIndex,
                                                       const Real32& value   )
{
    if(uiIndex >= _mfTextureZs.size())
        return;

    editMField(TextureZsFieldMask, _mfTextureZs);

    _mfTextureZs[uiIndex] = value;
}

void ParticlesBase::replaceInTextureZs(const Real32& pOldElem,
                                                        const Real32& pNewElem)
{
    Int32  elemIdx = _mfTextureZs.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(TextureZsFieldMask, _mfTextureZs);

        MFReal32::iterator fieldIt = _mfTextureZs.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void ParticlesBase::removeFromTextureZs(UInt32 uiIndex)
{
    if(uiIndex < _mfTextureZs.size())
    {
        editMField(TextureZsFieldMask, _mfTextureZs);

        MFReal32::iterator fieldIt = _mfTextureZs.begin();

        fieldIt += uiIndex;
        _mfTextureZs.erase(fieldIt);
    }
}

void ParticlesBase::removeFromTextureZs(const Real32& value)
{
    Int32 iElemIdx = _mfTextureZs.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TextureZsFieldMask, _mfTextureZs);

        MFReal32::iterator fieldIt = _mfTextureZs.begin();

        fieldIt += iElemIdx;

        _mfTextureZs.erase(fieldIt);
    }
}

void ParticlesBase::clearTextureZs(void)
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    _mfTextureZs.clear();
}


/*------------------------------ access -----------------------------------*/

UInt32 ParticlesBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        returnValue += _sfMode.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _sfPositions.getBinSize();
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        returnValue += _mfSizes.getBinSize();
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        returnValue += _sfSecPositions.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _sfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _sfNormals.getBinSize();
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        returnValue += _mfIndices.getBinSize();
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        returnValue += _mfTextureZs.getBinSize();
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        returnValue += _sfDrawOrder.getBinSize();
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        returnValue += _sfDynamic.getBinSize();
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        returnValue += _sfPump.getBinSize();
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        returnValue += _sfBsp.getBinSize();
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        returnValue += _sfNumParticles.getBinSize();
    }

    return returnValue;
}

void ParticlesBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyToBin(pMem);
    }
}

void ParticlesBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ParticlesPtr ParticlesBase::create(void)
{
    ParticlesPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        fc = OSG::cast_dynamic<Particles::ObjPtr>(
            getClassType().getPrototype()-> shallowCopy());
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
ParticlesPtr ParticlesBase::createEmpty(void)
{
    ParticlesPtr returnValue;

    newPtr<Particles>(returnValue);

    return returnValue;
}

FieldContainerPtr ParticlesBase::shallowCopy(void) const
{
    ParticlesPtr returnValue;

    newPtr(returnValue, dynamic_cast<const Particles *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

ParticlesBase::ParticlesBase(void) :
    Inherited(),
    _sfMode                   (UInt32(2)),
    _sfPositions              (),
    _mfSizes                  (),
    _sfSecPositions           (),
    _sfColors                 (),
    _sfNormals                (),
    _mfIndices                (),
    _mfTextureZs              (),
    _sfDrawOrder              (UInt32(0)),
    _sfDynamic                (bool(true)),
    _sfPump                   (),
    _sfBsp                    (),
    _sfNumParticles           (Int32(-1))
{
}

ParticlesBase::ParticlesBase(const ParticlesBase &source) :
    Inherited(source),
    _sfMode                   (source._sfMode                   ),
    _sfPositions              (),
    _mfSizes                  (source._mfSizes                  ),
    _sfSecPositions           (),
    _sfColors                 (),
    _sfNormals                (),
    _mfIndices                (source._mfIndices                ),
    _mfTextureZs              (source._mfTextureZs              ),
    _sfDrawOrder              (source._sfDrawOrder              ),
    _sfDynamic                (source._sfDynamic                ),
    _sfPump                   (source._sfPump                   ),
    _sfBsp                    (source._sfBsp                    ),
    _sfNumParticles           (source._sfNumParticles           )
{
}

/*-------------------------- destructors ----------------------------------*/

ParticlesBase::~ParticlesBase(void)
{
}

void ParticlesBase::onCreate(const Particles *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setPositions(source->getPositions());

        this->setSecPositions(source->getSecPositions());

        this->setColors(source->getColors());

        this->setNormals(source->getNormals());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<ParticlesBase *>(&oFrom),
                   whichField,
                   syncMode,
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ParticlesBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void ParticlesBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ParticlesBase::createAspectCopy(void) const
{
    ParticlesPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Particles *>(this));

    return returnValue;
}
#endif

void ParticlesBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Particles *>(this)->setPositions(NullFC);

    static_cast<Particles *>(this)->setSecPositions(NullFC);

    static_cast<Particles *>(this)->setColors(NullFC);

    static_cast<Particles *>(this)->setNormals(NullFC);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfSizes.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfIndices.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfTextureZs.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

#include "OSGSFieldAdaptor.ins"
#include "OSGMFieldAdaptor.ins"

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ParticlesPtr>::_type("ParticlesPtr", "MaterialDrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ParticlesPtr)

OSG_FIELD_DLLEXPORT_DEF2(SFieldAdaptor, ParticlesPtr, SFFieldContainerPtr);
OSG_FIELD_DLLEXPORT_DEF2(MFieldAdaptor, ParticlesPtr, MFFieldContainerPtr);

OSG_END_NAMESPACE

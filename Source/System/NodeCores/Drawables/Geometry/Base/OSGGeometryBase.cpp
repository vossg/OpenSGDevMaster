/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Geometry!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGGeoIntegralProperty.h"     // Types Class
#include "OSGGeoVectorProperty.h"       // Properties Class

#include "OSGGeometryBase.h"
#include "OSGGeometry.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Geometry
    
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var GeoIntegralProperty * GeometryBase::_sfTypes
    The types property contains the primitive's types. Legal values are 
    everything that can be passed to glBegin(). There have to be as many 
    types as lengths.
*/

/*! \var GeoIntegralProperty * GeometryBase::_sfLengths
    The lengths property contains the number of vertices to use for the 
    corresponding primitive. There have to be as many  lengths as types.
*/

/*! \var GeoVectorProperty * GeometryBase::_mfProperties
    The attributes used to render the geometry. The order is based on the 
    the one given in ARB_vertex_program.
*/

/*! \var GeoIntegralProperty * GeometryBase::_mfPropIndices
    The indices property contains the index data. See \ref 
    PageSystemGeoIndexing for a description of the indexing options.
*/

/*! \var UInt32          GeometryBase::_sfPatchVertices
    if primitives are patches set the number of vertices per patch. Evaluated
    if value != 0.
*/

/*! \var bool            GeometryBase::_sfDlistCache
    Flag to activate caching the geometry inside a display list.
*/

/*! \var bool            GeometryBase::_sfUseVAO
    Flag to activate caching the geometry inside a VAO.
*/

/*! \var bool            GeometryBase::_sfUseAttribCalls
    Flag to activate caching the geometry inside a VAO.
*/

/*! \var Int32           GeometryBase::_sfClassicGLId
    The dlist id for the classic rendering mode, if used.
*/

/*! \var Int32           GeometryBase::_sfAttGLId
    The dlist id for the attribute-based rendering mode, if used.
*/

/*! \var Int32           GeometryBase::_sfClassicVaoGLId
    The vao gl id for the attribute-based rendering mode, if used.
*/

/*! \var Int32           GeometryBase::_sfAttribVaoGLId
    The vao gl id for the attribute-based rendering mode, if used.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<Geometry *, nsOSG>::_type(
    "GeometryPtr", 
    "MaterialDrawablePtr", 
    Geometry::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(Geometry *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Geometry *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Geometry *,
                           nsOSG)

DataType &FieldTraits< Geometry *, nsOSG + 1 >::getType(void)
{
    return FieldTraits<Geometry *, nsOSG>::getType();
}


OSG_EXPORT_PTR_SFIELD(ChildPointerSField,
                      Geometry *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


OSG_EXPORT_PTR_MFIELD(ChildPointerMField,
                      Geometry *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void GeometryBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecChildGeoIntegralPropertyPtr::Description(
        SFUnrecChildGeoIntegralPropertyPtr::getClassType(),
        "types",
        "The types property contains the primitive's types. Legal values are \n"
        "everything that can be passed to glBegin(). There have to be as many \n"
        "types as lengths.\n",
        TypesFieldId, TypesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleTypes),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleTypes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoIntegralPropertyPtr::Description(
        SFUnrecChildGeoIntegralPropertyPtr::getClassType(),
        "lengths",
        "The lengths property contains the number of vertices to use for the \n"
        "corresponding primitive. There have to be as many  lengths as types.\n",
        LengthsFieldId, LengthsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleLengths),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleLengths));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecChildGeoVectorPropertyPtr::Description(
        MFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "properties",
        "The attributes used to render the geometry. The order is based on the \n"
        "the one given in ARB_vertex_program.\n",
        PropertiesFieldId, PropertiesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleProperties),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleProperties));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecChildGeoIntegralPropertyPtr::Description(
        MFUnrecChildGeoIntegralPropertyPtr::getClassType(),
        "propIndices",
        "The indices property contains the index data. See \\ref \n"
        "PageSystemGeoIndexing for a description of the indexing options.\n",
        PropIndicesFieldId, PropIndicesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandlePropIndices),
        static_cast<FieldGetMethodSig >(&Geometry::getHandlePropIndices));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "patchVertices",
        "if primitives are patches set the number of vertices per patch. Evaluated\n"
        "if value != 0.\n",
        PatchVerticesFieldId, PatchVerticesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandlePatchVertices),
        static_cast<FieldGetMethodSig >(&Geometry::getHandlePatchVertices));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "dlistCache",
        "Flag to activate caching the geometry inside a display list.\n",
        DlistCacheFieldId, DlistCacheFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleDlistCache),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleDlistCache));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useVAO",
        "Flag to activate caching the geometry inside a VAO.\n",
        UseVAOFieldId, UseVAOFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleUseVAO),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleUseVAO));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useAttribCalls",
        "Flag to activate caching the geometry inside a VAO.\n",
        UseAttribCallsFieldId, UseAttribCallsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleUseAttribCalls),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleUseAttribCalls));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "classicGLId",
        "The dlist id for the classic rendering mode, if used.\n",
        ClassicGLIdFieldId, ClassicGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleClassicGLId),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleClassicGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "attGLId",
        "The dlist id for the attribute-based rendering mode, if used.\n",
        AttGLIdFieldId, AttGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleAttGLId),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleAttGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "classicVaoGLId",
        "The vao gl id for the attribute-based rendering mode, if used.\n",
        ClassicVaoGLIdFieldId, ClassicVaoGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleClassicVaoGLId),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleClassicVaoGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "attribVaoGLId",
        "The vao gl id for the attribute-based rendering mode, if used.\n",
        AttribVaoGLIdFieldId, AttribVaoGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&Geometry::editHandleAttribVaoGLId),
        static_cast<FieldGetMethodSig >(&Geometry::getHandleAttribVaoGLId));

    oType.addInitialDesc(pDesc);
}


GeometryBase::TypeObject GeometryBase::_type(
    GeometryBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&GeometryBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&Geometry::initMethod),
    reinterpret_cast<ExitContainerF>(&Geometry::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&Geometry::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"Geometry\"\n"
    "    parent=\"MaterialDrawable\"\n"
    "    library=\"Drawable\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    childFields=\"both\"\n"
    "    decoratable=\"false\"\n"
    "    isNodeCore=\"true\"\n"
    "    docGroupBase=\"GrpDrawablesGeometry\"\n"
    "    >\n"
    "    <Field\n"
    "        name=\"types\"\n"
    "        type=\"GeoIntegralProperty\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The types property contains the primitive's types. Legal values are \n"
    "        everything that can be passed to glBegin(). There have to be as many \n"
    "        types as lengths.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"lengths\"\n"
    "        type=\"GeoIntegralProperty\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The lengths property contains the number of vertices to use for the \n"
    "        corresponding primitive. There have to be as many  lengths as types.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"properties\"\n"
    "        type=\"GeoVectorProperty\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The attributes used to render the geometry. The order is based on the \n"
    "        the one given in ARB_vertex_program.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"propIndices\"\n"
    "        type=\"GeoIntegralProperty\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The indices property contains the index data. See \\ref \n"
    "        PageSystemGeoIndexing for a description of the indexing options.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"patchVertices\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\tif primitives are patches set the number of vertices per patch. Evaluated\n"
    "    if value != 0.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dlistCache\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\tFlag to activate caching the geometry inside a display list.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"useVAO\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\tFlag to activate caching the geometry inside a VAO.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"useAttribCalls\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "\tFlag to activate caching the geometry inside a VAO.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"classicGLId\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "\tThe dlist id for the classic rendering mode, if used.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"attGLId\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "\tThe dlist id for the attribute-based rendering mode, if used.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"classicVaoGLId\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "\tThe vao gl id for the attribute-based rendering mode, if used.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"attribVaoGLId\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "\tThe vao gl id for the attribute-based rendering mode, if used.\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &GeometryBase::getType(void)
{
    return _type;
}

const FieldContainerType &GeometryBase::getType(void) const
{
    return _type;
}

UInt32 GeometryBase::getContainerSize(void) const
{
    return sizeof(Geometry);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Geometry::_sfTypes field.
const SFUnrecChildGeoIntegralPropertyPtr *GeometryBase::getSFTypes(void) const
{
    return &_sfTypes;
}

SFUnrecChildGeoIntegralPropertyPtr *GeometryBase::editSFTypes          (void)
{
    editSField(TypesFieldMask);

    return &_sfTypes;
}

//! Get the value of the Geometry::_sfTypes field.
GeoIntegralProperty * GeometryBase::getTypes(void) const
{
    return _sfTypes.getValue();
}

//! Set the value of the Geometry::_sfTypes field.
void GeometryBase::setTypes(GeoIntegralProperty * const value)
{
    editSField(TypesFieldMask);

    _sfTypes.setValue(value);
}


//! Get the Geometry::_sfLengths field.
const SFUnrecChildGeoIntegralPropertyPtr *GeometryBase::getSFLengths(void) const
{
    return &_sfLengths;
}

SFUnrecChildGeoIntegralPropertyPtr *GeometryBase::editSFLengths        (void)
{
    editSField(LengthsFieldMask);

    return &_sfLengths;
}

//! Get the value of the Geometry::_sfLengths field.
GeoIntegralProperty * GeometryBase::getLengths(void) const
{
    return _sfLengths.getValue();
}

//! Set the value of the Geometry::_sfLengths field.
void GeometryBase::setLengths(GeoIntegralProperty * const value)
{
    editSField(LengthsFieldMask);

    _sfLengths.setValue(value);
}


//! Get the Geometry::_mfProperties field.
const MFUnrecChildGeoVectorPropertyPtr *GeometryBase::getMFProperties(void) const
{
    return &_mfProperties;
}

MFUnrecChildGeoVectorPropertyPtr *GeometryBase::editMFProperties     (void)
{
    editMField(PropertiesFieldMask, _mfProperties);

    return &_mfProperties;
}
GeoVectorProperty * GeometryBase::getProperties(const UInt32 index) const
{
    return _mfProperties[index];
}

//! Get the Geometry::_mfPropIndices field.
const MFUnrecChildGeoIntegralPropertyPtr *GeometryBase::getMFPropIndices(void) const
{
    return &_mfPropIndices;
}

MFUnrecChildGeoIntegralPropertyPtr *GeometryBase::editMFPropIndices    (void)
{
    editMField(PropIndicesFieldMask, _mfPropIndices);

    return &_mfPropIndices;
}
GeoIntegralProperty * GeometryBase::getPropIndices(const UInt32 index) const
{
    return _mfPropIndices[index];
}

SFUInt32 *GeometryBase::editSFPatchVertices(void)
{
    editSField(PatchVerticesFieldMask);

    return &_sfPatchVertices;
}

const SFUInt32 *GeometryBase::getSFPatchVertices(void) const
{
    return &_sfPatchVertices;
}


SFBool *GeometryBase::editSFDlistCache(void)
{
    editSField(DlistCacheFieldMask);

    return &_sfDlistCache;
}

const SFBool *GeometryBase::getSFDlistCache(void) const
{
    return &_sfDlistCache;
}


SFBool *GeometryBase::editSFUseVAO(void)
{
    editSField(UseVAOFieldMask);

    return &_sfUseVAO;
}

const SFBool *GeometryBase::getSFUseVAO(void) const
{
    return &_sfUseVAO;
}


SFBool *GeometryBase::editSFUseAttribCalls(void)
{
    editSField(UseAttribCallsFieldMask);

    return &_sfUseAttribCalls;
}

const SFBool *GeometryBase::getSFUseAttribCalls(void) const
{
    return &_sfUseAttribCalls;
}


SFInt32 *GeometryBase::editSFClassicGLId(void)
{
    editSField(ClassicGLIdFieldMask);

    return &_sfClassicGLId;
}

const SFInt32 *GeometryBase::getSFClassicGLId(void) const
{
    return &_sfClassicGLId;
}


SFInt32 *GeometryBase::editSFAttGLId(void)
{
    editSField(AttGLIdFieldMask);

    return &_sfAttGLId;
}

const SFInt32 *GeometryBase::getSFAttGLId(void) const
{
    return &_sfAttGLId;
}


SFInt32 *GeometryBase::editSFClassicVaoGLId(void)
{
    editSField(ClassicVaoGLIdFieldMask);

    return &_sfClassicVaoGLId;
}

const SFInt32 *GeometryBase::getSFClassicVaoGLId(void) const
{
    return &_sfClassicVaoGLId;
}


SFInt32 *GeometryBase::editSFAttribVaoGLId(void)
{
    editSField(AttribVaoGLIdFieldMask);

    return &_sfAttribVaoGLId;
}

const SFInt32 *GeometryBase::getSFAttribVaoGLId(void) const
{
    return &_sfAttribVaoGLId;
}




void GeometryBase::pushToProperties(GeoVectorProperty * const value)
{
    editMField(PropertiesFieldMask, _mfProperties);

    _mfProperties.push_back(value);
}

void GeometryBase::assignProperties(const MFUnrecChildGeoVectorPropertyPtr &value)
{
    MFUnrecChildGeoVectorPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecChildGeoVectorPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Geometry *>(this)->clearProperties();

    while(elemIt != elemEnd)
    {
        this->pushToProperties(*elemIt);

        ++elemIt;
    }
}

void GeometryBase::removeFromProperties(UInt32 uiIndex)
{
    if(uiIndex < _mfProperties.size())
    {
        editMField(PropertiesFieldMask, _mfProperties);

        _mfProperties.erase(uiIndex);
    }
}

void GeometryBase::removeObjFromProperties(GeoVectorProperty * const value)
{
    Int32 iElemIdx = _mfProperties.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PropertiesFieldMask, _mfProperties);

        _mfProperties.erase(iElemIdx);
    }
}
void GeometryBase::clearProperties(void)
{
    editMField(PropertiesFieldMask, _mfProperties);


    _mfProperties.clear();
}

void GeometryBase::pushToPropIndices(GeoIntegralProperty * const value)
{
    editMField(PropIndicesFieldMask, _mfPropIndices);

    _mfPropIndices.push_back(value);
}

void GeometryBase::assignPropIndices(const MFUnrecChildGeoIntegralPropertyPtr &value)
{
    MFUnrecChildGeoIntegralPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecChildGeoIntegralPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Geometry *>(this)->clearPropIndices();

    while(elemIt != elemEnd)
    {
        this->pushToPropIndices(*elemIt);

        ++elemIt;
    }
}

void GeometryBase::removeFromPropIndices(UInt32 uiIndex)
{
    if(uiIndex < _mfPropIndices.size())
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);

        _mfPropIndices.erase(uiIndex);
    }
}

void GeometryBase::removeObjFromPropIndices(GeoIntegralProperty * const value)
{
    Int32 iElemIdx = _mfPropIndices.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);

        _mfPropIndices.erase(iElemIdx);
    }
}
void GeometryBase::clearPropIndices(void)
{
    editMField(PropIndicesFieldMask, _mfPropIndices);


    _mfPropIndices.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT GeometryBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        returnValue += _sfTypes.getBinSize();
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        returnValue += _sfLengths.getBinSize();
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        returnValue += _mfProperties.getBinSize();
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        returnValue += _mfPropIndices.getBinSize();
    }
    if(FieldBits::NoField != (PatchVerticesFieldMask & whichField))
    {
        returnValue += _sfPatchVertices.getBinSize();
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        returnValue += _sfDlistCache.getBinSize();
    }
    if(FieldBits::NoField != (UseVAOFieldMask & whichField))
    {
        returnValue += _sfUseVAO.getBinSize();
    }
    if(FieldBits::NoField != (UseAttribCallsFieldMask & whichField))
    {
        returnValue += _sfUseAttribCalls.getBinSize();
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        returnValue += _sfClassicGLId.getBinSize();
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        returnValue += _sfAttGLId.getBinSize();
    }
    if(FieldBits::NoField != (ClassicVaoGLIdFieldMask & whichField))
    {
        returnValue += _sfClassicVaoGLId.getBinSize();
    }
    if(FieldBits::NoField != (AttribVaoGLIdFieldMask & whichField))
    {
        returnValue += _sfAttribVaoGLId.getBinSize();
    }

    return returnValue;
}

void GeometryBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _sfTypes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        _sfLengths.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        _mfProperties.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        _mfPropIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PatchVerticesFieldMask & whichField))
    {
        _sfPatchVertices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        _sfDlistCache.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseVAOFieldMask & whichField))
    {
        _sfUseVAO.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseAttribCallsFieldMask & whichField))
    {
        _sfUseAttribCalls.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        _sfClassicGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        _sfAttGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClassicVaoGLIdFieldMask & whichField))
    {
        _sfClassicVaoGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AttribVaoGLIdFieldMask & whichField))
    {
        _sfAttribVaoGLId.copyToBin(pMem);
    }
}

void GeometryBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        editSField(TypesFieldMask);
        _sfTypes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        editSField(LengthsFieldMask);
        _sfLengths.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        editMField(PropertiesFieldMask, _mfProperties);
        _mfProperties.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);
        _mfPropIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PatchVerticesFieldMask & whichField))
    {
        editSField(PatchVerticesFieldMask);
        _sfPatchVertices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        editSField(DlistCacheFieldMask);
        _sfDlistCache.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseVAOFieldMask & whichField))
    {
        editSField(UseVAOFieldMask);
        _sfUseVAO.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseAttribCallsFieldMask & whichField))
    {
        editSField(UseAttribCallsFieldMask);
        _sfUseAttribCalls.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        editSField(ClassicGLIdFieldMask);
        _sfClassicGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        editSField(AttGLIdFieldMask);
        _sfAttGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClassicVaoGLIdFieldMask & whichField))
    {
        editSField(ClassicVaoGLIdFieldMask);
        _sfClassicVaoGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AttribVaoGLIdFieldMask & whichField))
    {
        editSField(AttribVaoGLIdFieldMask);
        _sfAttribVaoGLId.copyFromBin(pMem);
    }
}

//! create a new instance of the class
GeometryTransitPtr GeometryBase::createLocal(BitVector bFlags)
{
    GeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Geometry>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
GeometryTransitPtr GeometryBase::createDependent(BitVector bFlags)
{
    GeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Geometry>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
GeometryTransitPtr GeometryBase::create(void)
{
    GeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Geometry>(tmpPtr);
    }

    return fc;
}

Geometry *GeometryBase::createEmptyLocal(BitVector bFlags)
{
    Geometry *returnValue;

    newPtr<Geometry>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Geometry *GeometryBase::createEmpty(void)
{
    Geometry *returnValue;

    newPtr<Geometry>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr GeometryBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Geometry *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Geometry *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr GeometryBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Geometry *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Geometry *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr GeometryBase::shallowCopy(void) const
{
    Geometry *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Geometry *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

GeometryBase::GeometryBase(void) :
    Inherited(),
    _sfTypes                  (this,
                          TypesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfLengths                (this,
                          LengthsFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _mfProperties             (this,
                          PropertiesFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfPropIndices            (this,
                          PropIndicesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfPatchVertices          (UInt32(0)),
    _sfDlistCache             (bool(true)),
    _sfUseVAO                 (bool(true)),
    _sfUseAttribCalls         (bool(false)),
    _sfClassicGLId            (Int32(0)),
    _sfAttGLId                (Int32(0)),
    _sfClassicVaoGLId         (Int32(0)),
    _sfAttribVaoGLId          (Int32(0))
{
}

GeometryBase::GeometryBase(const GeometryBase &source) :
    Inherited(source),
    _sfTypes                  (this,
                          TypesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfLengths                (this,
                          LengthsFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _mfProperties             (this,
                          PropertiesFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfPropIndices            (this,
                          PropIndicesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfPatchVertices          (source._sfPatchVertices          ),
    _sfDlistCache             (source._sfDlistCache             ),
    _sfUseVAO                 (source._sfUseVAO                 ),
    _sfUseAttribCalls         (source._sfUseAttribCalls         ),
    _sfClassicGLId            (source._sfClassicGLId            ),
    _sfAttGLId                (source._sfAttGLId                ),
    _sfClassicVaoGLId         (source._sfClassicVaoGLId         ),
    _sfAttribVaoGLId          (source._sfAttribVaoGLId          )
{
}


/*-------------------------- destructors ----------------------------------*/

GeometryBase::~GeometryBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool GeometryBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == TypesFieldId)
    {
        GeoIntegralProperty * pTypedChild =
            dynamic_cast<GeoIntegralProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfTypes.getValue() == pTypedChild)
            {
                editSField(TypesFieldMask);

                _sfTypes.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    if(childFieldId == LengthsFieldId)
    {
        GeoIntegralProperty * pTypedChild =
            dynamic_cast<GeoIntegralProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfLengths.getValue() == pTypedChild)
            {
                editSField(LengthsFieldMask);

                _sfLengths.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    if(childFieldId == PropertiesFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            Int32 iChildIdx = _mfProperties.findIndex(pTypedChild);

            if(iChildIdx != -1)
            {
                editMField(PropertiesFieldMask, _mfProperties);

                _mfProperties.erase(iChildIdx);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    if(childFieldId == PropIndicesFieldId)
    {
        GeoIntegralProperty * pTypedChild =
            dynamic_cast<GeoIntegralProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            Int32 iChildIdx = _mfPropIndices.findIndex(pTypedChild);

            if(iChildIdx != -1)
            {
                editMField(PropIndicesFieldMask, _mfPropIndices);

                _mfPropIndices.erase(iChildIdx);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void GeometryBase::onCreate(const Geometry *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Geometry *pThis = static_cast<Geometry *>(this);

        pThis->setTypes(source->getTypes());

        pThis->setLengths(source->getLengths());

        MFUnrecChildGeoVectorPropertyPtr::const_iterator PropertiesIt  =
            source->_mfProperties.begin();
        MFUnrecChildGeoVectorPropertyPtr::const_iterator PropertiesEnd =
            source->_mfProperties.end  ();

        while(PropertiesIt != PropertiesEnd)
        {
            pThis->pushToProperties(*PropertiesIt);

            ++PropertiesIt;
        }

        MFUnrecChildGeoIntegralPropertyPtr::const_iterator PropIndicesIt  =
            source->_mfPropIndices.begin();
        MFUnrecChildGeoIntegralPropertyPtr::const_iterator PropIndicesEnd =
            source->_mfPropIndices.end  ();

        while(PropIndicesIt != PropIndicesEnd)
        {
            pThis->pushToPropIndices(*PropIndicesIt);

            ++PropIndicesIt;
        }
    }
}

GetFieldHandlePtr GeometryBase::getHandleTypes           (void) const
{
    SFUnrecChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::GetHandle(
             &_sfTypes,
             this->getType().getFieldDesc(TypesFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleTypes          (void)
{
    SFUnrecChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::EditHandle(
             &_sfTypes,
             this->getType().getFieldDesc(TypesFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Geometry::setTypes,
                    static_cast<Geometry *>(this), _1));

    editSField(TypesFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleLengths         (void) const
{
    SFUnrecChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::GetHandle(
             &_sfLengths,
             this->getType().getFieldDesc(LengthsFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleLengths        (void)
{
    SFUnrecChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::EditHandle(
             &_sfLengths,
             this->getType().getFieldDesc(LengthsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Geometry::setLengths,
                    static_cast<Geometry *>(this), _1));

    editSField(LengthsFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleProperties      (void) const
{
    MFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  MFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_mfProperties,
             this->getType().getFieldDesc(PropertiesFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleProperties     (void)
{
    MFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  MFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_mfProperties,
             this->getType().getFieldDesc(PropertiesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Geometry::pushToProperties,
                    static_cast<Geometry *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Geometry::removeFromProperties,
                    static_cast<Geometry *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Geometry::removeObjFromProperties,
                    static_cast<Geometry *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Geometry::clearProperties,
                    static_cast<Geometry *>(this)));

    editMField(PropertiesFieldMask, _mfProperties);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandlePropIndices     (void) const
{
    MFUnrecChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  MFUnrecChildGeoIntegralPropertyPtr::GetHandle(
             &_mfPropIndices,
             this->getType().getFieldDesc(PropIndicesFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandlePropIndices    (void)
{
    MFUnrecChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  MFUnrecChildGeoIntegralPropertyPtr::EditHandle(
             &_mfPropIndices,
             this->getType().getFieldDesc(PropIndicesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Geometry::pushToPropIndices,
                    static_cast<Geometry *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Geometry::removeFromPropIndices,
                    static_cast<Geometry *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Geometry::removeObjFromPropIndices,
                    static_cast<Geometry *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Geometry::clearPropIndices,
                    static_cast<Geometry *>(this)));

    editMField(PropIndicesFieldMask, _mfPropIndices);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandlePatchVertices   (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfPatchVertices,
             this->getType().getFieldDesc(PatchVerticesFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandlePatchVertices  (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfPatchVertices,
             this->getType().getFieldDesc(PatchVerticesFieldId),
             this));


    editSField(PatchVerticesFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleDlistCache      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDlistCache,
             this->getType().getFieldDesc(DlistCacheFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleDlistCache     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDlistCache,
             this->getType().getFieldDesc(DlistCacheFieldId),
             this));


    editSField(DlistCacheFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleUseVAO          (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseVAO,
             this->getType().getFieldDesc(UseVAOFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleUseVAO         (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseVAO,
             this->getType().getFieldDesc(UseVAOFieldId),
             this));


    editSField(UseVAOFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleUseAttribCalls  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseAttribCalls,
             this->getType().getFieldDesc(UseAttribCallsFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleUseAttribCalls (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseAttribCalls,
             this->getType().getFieldDesc(UseAttribCallsFieldId),
             this));


    editSField(UseAttribCallsFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleClassicGLId     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfClassicGLId,
             this->getType().getFieldDesc(ClassicGLIdFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleClassicGLId    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfClassicGLId,
             this->getType().getFieldDesc(ClassicGLIdFieldId),
             this));


    editSField(ClassicGLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleAttGLId         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfAttGLId,
             this->getType().getFieldDesc(AttGLIdFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleAttGLId        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfAttGLId,
             this->getType().getFieldDesc(AttGLIdFieldId),
             this));


    editSField(AttGLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleClassicVaoGLId  (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfClassicVaoGLId,
             this->getType().getFieldDesc(ClassicVaoGLIdFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleClassicVaoGLId (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfClassicVaoGLId,
             this->getType().getFieldDesc(ClassicVaoGLIdFieldId),
             this));


    editSField(ClassicVaoGLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleAttribVaoGLId   (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfAttribVaoGLId,
             this->getType().getFieldDesc(AttribVaoGLIdFieldId),
             const_cast<GeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleAttribVaoGLId  (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfAttribVaoGLId,
             this->getType().getFieldDesc(AttribVaoGLIdFieldId),
             this));


    editSField(AttribVaoGLIdFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void GeometryBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Geometry *pThis = static_cast<Geometry *>(this);

    pThis->execSync(static_cast<Geometry *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *GeometryBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Geometry *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Geometry *>(pRefAspect),
                  dynamic_cast<const Geometry *>(this));

    return returnValue;
}
#endif

void GeometryBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Geometry *>(this)->setTypes(NULL);

    static_cast<Geometry *>(this)->setLengths(NULL);

    static_cast<Geometry *>(this)->clearProperties();

    static_cast<Geometry *>(this)->clearPropIndices();


}


OSG_END_NAMESPACE

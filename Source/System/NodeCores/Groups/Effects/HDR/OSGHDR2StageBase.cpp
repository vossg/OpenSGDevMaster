/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class HDR2Stage!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGLEXT.h"                     // ColorBufferInternalFormat default header
#include "OSGGLEXT.h"                     // ColorBufferPixelFormat default header
#include "OSGGLEXT.h"                     // ColorBufferType default header
#include "OSGGLEXT.h"                     // DepthBufferInternalFormat default header
#include "OSGGLEXT.h"                     // DepthBufferPixelFormat default header
#include "OSGGLEXT.h"                     // DepthBufferType default header
#include "OSGGLEXT.h"                     // LumBufferInternalFormat default header
#include "OSGGLEXT.h"                     // LumBufferPixelFormat default header
#include "OSGGLEXT.h"                     // LumBufferType default header
#include "OSGGLEXT.h"                     // ImageBufferInternalFormat default header
#include "OSGGLEXT.h"                     // ImageBufferPixelFormat default header
#include "OSGGLEXT.h"                     // ImageBufferType default header


#include "OSGHDR2StageBase.h"
#include "OSGHDR2Stage.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::HDR2Stage
    This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the
    average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it
    implements various tone mapping operators allowing to get comfortable with the different techniques available.

    Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement
    local averaging methods (histogram).
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var bool            HDR2StageBase::_sfApplyGamma
    If set gamma correction is performed just before writing to the final
    draw buffer at the end of the pipeline.
*/

/*! \var bool            HDR2StageBase::_sfAccurateGamma
    If set correct gamma calculation is performed, i.e. respect linear near black.
    This parameter is only in use if parameter applyGamma is set to true.
    See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html 
    https://en.wikipedia.org/wiki/SRGB and https://en.wikipedia.org/wiki/Rec._709
    for reference.
*/

/*! \var bool            HDR2StageBase::_sfAdjustLuminance
    Enable or disable time dependent luminance adaptation.
*/

/*! \var Real32          HDR2StageBase::_sfTau
    Adjusted luminance adaptation time parameter.
    Reasonable values are in the interval [0.f, 4.f].
    See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,
    http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,
    and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/
    for reference.
*/

/*! \var bool            HDR2StageBase::_sfPerformBloom
    If true a bloom / blur pass is performed, which can have a performance impact.
*/

/*! \var Real32          HDR2StageBase::_sfBloomThreshold
    The bloom threshold used in the brightness filter pass. Reasonable values are in the interval
    [0.f, 10.f].
*/

/*! \var bool            HDR2StageBase::_sfBloomBackground
    If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render
    background is a solid background it might be preferable to exclude it from the blooming in order
    to avoid background color bleeding into the rendered geometry.
*/

/*! \var Real32          HDR2StageBase::_sfBloomMagnitude
    This value determines how much of the blooming is mixed into the final image. Reasonable values
    are in the interval [0.f, 2.f].
*/

/*! \var Int32           HDR2StageBase::_sfNumTaps
    Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].
*/

/*! \var Real32          HDR2StageBase::_sfBlurGaussSigma
    The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values
    are in the interval [0.5f, 1.5f].
*/

/*! \var UInt32          HDR2StageBase::_sfToneMappingMode
    Tonemapping technique to use. Valid values are 
    NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, 
    REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTE2D_TONE_MAPPING

    For details about the different tone mapping techniques lookup the following references:
    Adaptive Logarithmic Mapping for Displaying High Contrast Scenes
    F. Drago, K. Myszkowski, T. Annen, and N. Chiba
    In Eurographics 2003 
    http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf

    Photographic Tone Reproduction for Digital Images
    Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda
    http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf

    http://filmicgames.com/archives/75
    http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff
*/

/*! \var bool            HDR2StageBase::_sfForceBackground
    If a normal color background is used it might be desirable to let the background not be paritcipating
    in the tone mapping procedure.
*/

/*! \var bool            HDR2StageBase::_sfUse_ITU_R_BT_709
    Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance
    according to the American NTSC coding system.
    See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.
*/

/*! \var UInt32          HDR2StageBase::_sfAutoExposureMode
    Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC.
    If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is
    used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also
    automatically calculated from the average luminance of the scene. The key value is a scalar that controls 
    how brightly or darkly the algorithm will expose your scene.
*/

/*! \var Real32          HDR2StageBase::_sfExposure
    Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying 
    how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.
    Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.
    Reasonable values are in the interval [-10.f, 10.f]. 
*/

/*! \var Real32          HDR2StageBase::_sfKeyValue
    This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the 
    scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used
    for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          HDR2StageBase::_sfWhiteLevel
    This parameter is the smallest luminance that will be mapped to pure white. It is used in the
    following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.
    Reasonable values are in the interval [0.f, 25.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          HDR2StageBase::_sfSaturation
    This parameter allows to control the satuarion of the tone mapped scene. It allows color
    correction applied after tone mapping.
    Reasonable values are in the interval [0.f, 4.f]. 
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var bool            HDR2StageBase::_sfUseLinChromCorrection
    Use a linear chromatic correction function. This works with parameter 'saturation'.
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicShoulderStrenght
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 2.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicLinearStrength
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 5.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicLinearAngle
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicToeStrength
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 2.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicToeNumerator
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 0.5f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicToeDenominator
    Approx77imation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 2.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfFilmicLinearWhite
    Approximation parameter of the Kodak film curve.
    This parameter is only used by the filmic_uncharte2d tone mapping technique.
    Reasonable values are in the interval [0.f, 20.f]. 
    See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfDragoBias
    The bias function is a power function defined over the unit interval, 
    an intuitive parameter dragoBias remaps an input value to a higher or lower value.
    This parameter is only used by the drago_logarithmic tone mapping technique.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.
*/

/*! \var UInt32          HDR2StageBase::_sfTarget
    This convenience parameter allows to redirect the intermediate texture image results
    to the final screen instead of the default COMPOSITE_TEXTURE which represents the
    final rendering result of this stage. This is useful for debugging purpose.
    Reasonable values are SCENE_TEXTURE, INITIAL_LUMINANCE_TEXTURE, ADAPTED_LUMINANCE_TEXTURE,
    BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, EXPOSURE_TEXTURE, DEPTH_TEXTURE,
    LINEARIZED_DEPTH_TEXTURE
*/

/*! \var bool            HDR2StageBase::_sfCarryDepth
    If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferInternalFormat
    Internal format used for hdr color buffer. Defaults to GL_RGBA16F.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferPixelFormat
    Pixel format used for hdr color buffer. Defaults to GL_RGBA.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferType
    Type used for hdr color buffer. Defaults to GL_FLOAT.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferInternalFormat
    Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferPixelFormat
    Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferType
    Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferInternalFormat
    Internal format used for luminance calculation. Defaults to GL_R32F.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferPixelFormat
    Pixel format used for hdr lum buffer. Defaults to GL_RED.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferType
    Type used for hdr lum buffer. Defaults to GL_FLOAT.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferInternalFormat
    Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferPixelFormat
    Pixel format used for hdr image color buffer. Defaults to GL_RGB.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferType
    Type used for hdr image color buffer. Defaults to GL_FLOAT.
*/

/*! \var Int32           HDR2StageBase::_sfNumSamples
    Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.
*/

/*! \var Int32           HDR2StageBase::_sfMipmapLevel
    The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which
    means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other
    values are meant for testing purposes only.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<HDR2Stage *, nsOSG>::_type(
    "HDR2StagePtr", 
    "StagePtr", 
    HDR2Stage::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(HDR2Stage *, nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void HDR2StageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "applyGamma",
        "If set gamma correction is performed just before writing to the final\n"
        "draw buffer at the end of the pipeline.\n",
        ApplyGammaFieldId, ApplyGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleApplyGamma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleApplyGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "accurateGamma",
        "If set correct gamma calculation is performed, i.e. respect linear near black.\n"
        "This parameter is only in use if parameter applyGamma is set to true.\n"
        "See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
        "https://en.wikipedia.org/wiki/SRGB and https://en.wikipedia.org/wiki/Rec._709\n"
        "for reference.\n",
        AccurateGammaFieldId, AccurateGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAccurateGamma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAccurateGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "adjustLuminance",
        "Enable or disable time dependent luminance adaptation.\n",
        AdjustLuminanceFieldId, AdjustLuminanceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAdjustLuminance),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAdjustLuminance));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "tau",
        "Adjusted luminance adaptation time parameter.\n"
        "Reasonable values are in the interval [0.f, 4.f].\n"
        "See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,\n"
        "http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,\n"
        "and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/\n"
        "for reference.\n",
        TauFieldId, TauFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleTau),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleTau));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "performBloom",
        "If true a bloom / blur pass is performed, which can have a performance impact.\n",
        PerformBloomFieldId, PerformBloomFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandlePerformBloom),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandlePerformBloom));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bloomThreshold",
        "The bloom threshold used in the brightness filter pass. Reasonable values are in the interval\n"
        "[0.f, 10.f].\n",
        BloomThresholdFieldId, BloomThresholdFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomThreshold),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomThreshold));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "bloomBackground",
        "If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render\n"
        "background is a solid background it might be preferable to exclude it from the blooming in order\n"
        "to avoid background color bleeding into the rendered geometry.\n",
        BloomBackgroundFieldId, BloomBackgroundFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomBackground),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomBackground));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bloomMagnitude",
        "This value determines how much of the blooming is mixed into the final image. Reasonable values\n"
        "are in the interval [0.f, 2.f].\n",
        BloomMagnitudeFieldId, BloomMagnitudeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomMagnitude),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomMagnitude));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numTaps",
        "Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].\n",
        NumTapsFieldId, NumTapsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleNumTaps),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleNumTaps));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "blurGaussSigma",
        "The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values\n"
        "are in the interval [0.5f, 1.5f].\n",
        BlurGaussSigmaFieldId, BlurGaussSigmaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBlurGaussSigma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBlurGaussSigma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "toneMappingMode",
        "Tonemapping technique to use. Valid values are \n"
        "NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
        "REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTE2D_TONE_MAPPING\n"
        "\n"
        "For details about the different tone mapping techniques lookup the following references:\n"
        "Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
        "F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
        "In Eurographics 2003 \n"
        "http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
        "\n"
        "Photographic Tone Reproduction for Digital Images\n"
        "Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
        "http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
        "\n"
        "http://filmicgames.com/archives/75\n"
        "http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
        "\n"
        "High Dynamic Range Imaging\n"
        "Aquisition, Display, and Image-Based Lighing\n"
        "Erik Reinhard et al.\n"
        "Second Edition 2010\n"
        "ISBN 978-0-12-374914-7\n",
        ToneMappingModeFieldId, ToneMappingModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleToneMappingMode),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleToneMappingMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceBackground",
        "If a normal color background is used it might be desirable to let the background not be paritcipating\n"
        "in the tone mapping procedure.\n",
        ForceBackgroundFieldId, ForceBackgroundFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleForceBackground),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleForceBackground));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "use_ITU_R_BT_709",
        "Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
        "according to the American NTSC coding system.\n"
        "See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n",
        Use_ITU_R_BT_709FieldId, Use_ITU_R_BT_709FieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleUse_ITU_R_BT_709),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleUse_ITU_R_BT_709));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "autoExposureMode",
        "Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC.\n"
        "If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
        "used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
        "automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
        "how brightly or darkly the algorithm will expose your scene.\n",
        AutoExposureModeFieldId, AutoExposureModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAutoExposureMode),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAutoExposureMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "exposure",
        "Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
        "how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
        "Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
        "Reasonable values are in the interval [-10.f, 10.f]. \n",
        ExposureFieldId, ExposureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleExposure),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleExposure));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "keyValue",
        "This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
        "scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
        "for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        KeyValueFieldId, KeyValueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleKeyValue),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleKeyValue));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "whiteLevel",
        "This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
        "following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
        "Reasonable values are in the interval [0.f, 25.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        WhiteLevelFieldId, WhiteLevelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleWhiteLevel),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleWhiteLevel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "saturation",
        "This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
        "correction applied after tone mapping.\n"
        "Reasonable values are in the interval [0.f, 4.f]. \n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        SaturationFieldId, SaturationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleSaturation),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleSaturation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useLinChromCorrection",
        "Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        UseLinChromCorrectionFieldId, UseLinChromCorrectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleUseLinChromCorrection),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleUseLinChromCorrection));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicShoulderStrenght",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 2.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicShoulderStrenghtFieldId, FilmicShoulderStrenghtFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicShoulderStrenght),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicShoulderStrenght));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicLinearStrength",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 5.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicLinearStrengthFieldId, FilmicLinearStrengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicLinearStrength),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicLinearStrength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicLinearAngle",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicLinearAngleFieldId, FilmicLinearAngleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicLinearAngle),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicLinearAngle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicToeStrength",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 2.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicToeStrengthFieldId, FilmicToeStrengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicToeStrength),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicToeStrength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicToeNumerator",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 0.5f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicToeNumeratorFieldId, FilmicToeNumeratorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicToeNumerator),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicToeNumerator));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicToeDenominator",
        "Approx77imation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 2.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicToeDenominatorFieldId, FilmicToeDenominatorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicToeDenominator),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicToeDenominator));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filmicLinearWhite",
        "Approximation parameter of the Kodak film curve.\n"
        "This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 20.f]. \n"
        "See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
        "for reference.\n",
        FilmicLinearWhiteFieldId, FilmicLinearWhiteFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicLinearWhite),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicLinearWhite));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "dragoBias",
        "The bias function is a power function defined over the unit interval, \n"
        "an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
        "This parameter is only used by the drago_logarithmic tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n",
        DragoBiasFieldId, DragoBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDragoBias),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDragoBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "target",
        "This convenience parameter allows to redirect the intermediate texture image results\n"
        "to the final screen instead of the default COMPOSITE_TEXTURE which represents the\n"
        "final rendering result of this stage. This is useful for debugging purpose.\n"
        "Reasonable values are SCENE_TEXTURE, INITIAL_LUMINANCE_TEXTURE, ADAPTED_LUMINANCE_TEXTURE,\n"
        "BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, EXPOSURE_TEXTURE, DEPTH_TEXTURE,\n"
        "LINEARIZED_DEPTH_TEXTURE\n",
        TargetFieldId, TargetFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleTarget),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleTarget));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "carryDepth",
        "If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.\n",
        CarryDepthFieldId, CarryDepthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleCarryDepth),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleCarryDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferInternalFormat",
        "Internal format used for hdr color buffer. Defaults to GL_RGBA16F.\n",
        ColorBufferInternalFormatFieldId, ColorBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferPixelFormat",
        "Pixel format used for hdr color buffer. Defaults to GL_RGBA.\n",
        ColorBufferPixelFormatFieldId, ColorBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferType",
        "Type used for hdr color buffer. Defaults to GL_FLOAT.\n",
        ColorBufferTypeFieldId, ColorBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferInternalFormat",
        "Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.\n",
        DepthBufferInternalFormatFieldId, DepthBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferPixelFormat",
        "Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.\n",
        DepthBufferPixelFormatFieldId, DepthBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferType",
        "Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.\n",
        DepthBufferTypeFieldId, DepthBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferInternalFormat",
        "Internal format used for luminance calculation. Defaults to GL_R32F.\n",
        LumBufferInternalFormatFieldId, LumBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferPixelFormat",
        "Pixel format used for hdr lum buffer. Defaults to GL_RED.\n",
        LumBufferPixelFormatFieldId, LumBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferType",
        "Type used for hdr lum buffer. Defaults to GL_FLOAT.\n",
        LumBufferTypeFieldId, LumBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferInternalFormat",
        "Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.\n",
        ImageBufferInternalFormatFieldId, ImageBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferPixelFormat",
        "Pixel format used for hdr image color buffer. Defaults to GL_RGB.\n",
        ImageBufferPixelFormatFieldId, ImageBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferType",
        "Type used for hdr image color buffer. Defaults to GL_FLOAT.\n",
        ImageBufferTypeFieldId, ImageBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numSamples",
        "Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.\n",
        NumSamplesFieldId, NumSamplesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleNumSamples),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleNumSamples));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "mipmapLevel",
        "The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which\n"
        "means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other\n"
        "values are meant for testing purposes only.\n",
        MipmapLevelFieldId, MipmapLevelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleMipmapLevel),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleMipmapLevel));

    oType.addInitialDesc(pDesc);
}


HDR2StageBase::TypeObject HDR2StageBase::_type(
    HDR2StageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&HDR2StageBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&HDR2Stage::initMethod),
    reinterpret_cast<ExitContainerF>(&HDR2Stage::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&HDR2Stage::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"HDR2Stage\"\n"
    "   parent=\"Stage\"\n"
    "   library=\"EffectGroups\"\n"
    "   pointerfieldtypes=\"none\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   isNodeCore=\"true\"\n"
    "   isBundle=\"false\"\n"
    "   docGroupBase=\"GrpEffectsGroupsHDR\"\n"
    "   >\n"
    "  This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the\n"
    "  average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it\n"
    "  implements various tone mapping operators allowing to get comfortable with the different techniques available.\n"
    "\n"
    "  Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement\n"
    "  local averaging methods (histogram).\n"
    "  <Field\n"
    "\t name=\"applyGamma\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If set gamma correction is performed just before writing to the final\n"
    "        draw buffer at the end of the pipeline.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"accurateGamma\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If set correct gamma calculation is performed, i.e. respect linear near black.\n"
    "        This parameter is only in use if parameter applyGamma is set to true.\n"
    "        See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
    "        https://en.wikipedia.org/wiki/SRGB and https://en.wikipedia.org/wiki/Rec._709\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"adjustLuminance\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Enable or disable time dependent luminance adaptation.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"tau\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1.25f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Adjusted luminance adaptation time parameter.\n"
    "        Reasonable values are in the interval [0.f, 4.f].\n"
    "        See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,\n"
    "        http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,\n"
    "        and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"performBloom\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If true a bloom / blur pass is performed, which can have a performance impact.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"bloomThreshold\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"2.f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        The bloom threshold used in the brightness filter pass. Reasonable values are in the interval\n"
    "        [0.f, 10.f].\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"bloomBackground\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render\n"
    "        background is a solid background it might be preferable to exclude it from the blooming in order\n"
    "        to avoid background color bleeding into the rendered geometry.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"bloomMagnitude\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        This value determines how much of the blooming is mixed into the final image. Reasonable values\n"
    "        are in the interval [0.f, 2.f].\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"numTaps\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"4\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"blurGaussSigma\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.8f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values\n"
    "        are in the interval [0.5f, 1.5f].\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"toneMappingMode\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"4\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Tonemapping technique to use. Valid values are \n"
    "        NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
    "        REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTE2D_TONE_MAPPING\n"
    "\n"
    "        For details about the different tone mapping techniques lookup the following references:\n"
    "        Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
    "        F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
    "        In Eurographics 2003 \n"
    "        http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
    "\n"
    "        Photographic Tone Reproduction for Digital Images\n"
    "        Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
    "        http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
    "\n"
    "        http://filmicgames.com/archives/75\n"
    "        http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
    "\n"
    "        High Dynamic Range Imaging\n"
    "        Aquisition, Display, and Image-Based Lighing\n"
    "        Erik Reinhard et al.\n"
    "        Second Edition 2010\n"
    "        ISBN 978-0-12-374914-7\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"forceBackground\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If a normal color background is used it might be desirable to let the background not be paritcipating\n"
    "        in the tone mapping procedure.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"use_ITU_R_BT_709\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
    "        according to the American NTSC coding system.\n"
    "        See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"autoExposureMode\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"2\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC.\n"
    "        If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
    "        used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
    "        automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
    "        how brightly or darkly the algorithm will expose your scene.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"exposure\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
    "        how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
    "        Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
    "        Reasonable values are in the interval [-10.f, 10.f]. \n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"keyValue\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.18f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
    "        scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
    "        for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"whiteLevel\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"5.f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
    "        following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
    "        Reasonable values are in the interval [0.f, 25.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"saturation\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1.f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
    "        correction applied after tone mapping.\n"
    "        Reasonable values are in the interval [0.f, 4.f]. \n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"useLinChromCorrection\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"filmicShoulderStrenght\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.15f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 2.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicLinearStrength\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.5f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 5.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicLinearAngle\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.1f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicToeStrength\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.2f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 2.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicToeNumerator\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.02f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 0.5f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicToeDenominator\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.3f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approx77imation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 2.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"filmicLinearWhite\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"11.2f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Approximation parameter of the Kodak film curve.\n"
    "        This parameter is only used by the filmic_uncharte2d tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 20.f]. \n"
    "        See http://filmicgames.com/archives/75 and  http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff.\n"
    "        for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"dragoBias\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.85f\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        The bias function is a power function defined over the unit interval, \n"
    "        an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
    "        This parameter is only used by the drago_logarithmic tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"target\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"5\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        This convenience parameter allows to redirect the intermediate texture image results\n"
    "        to the final screen instead of the default COMPOSITE_TEXTURE which represents the\n"
    "        final rendering result of this stage. This is useful for debugging purpose.\n"
    "        Reasonable values are SCENE_TEXTURE, INITIAL_LUMINANCE_TEXTURE, ADAPTED_LUMINANCE_TEXTURE,\n"
    "        BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, EXPOSURE_TEXTURE, DEPTH_TEXTURE,\n"
    "        LINEARIZED_DEPTH_TEXTURE\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"carryDepth\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"colorBufferInternalFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_RGBA16F\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Internal format used for hdr color buffer. Defaults to GL_RGBA16F.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"colorBufferPixelFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_RGBA\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Pixel format used for hdr color buffer. Defaults to GL_RGBA.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"colorBufferType\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_FLOAT\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Type used for hdr color buffer. Defaults to GL_FLOAT.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"depthBufferInternalFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_DEPTH24_STENCIL8\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"depthBufferPixelFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_DEPTH_STENCIL\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"depthBufferType\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_UNSIGNED_INT_24_8\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"lumBufferInternalFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_R32F\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Internal format used for luminance calculation. Defaults to GL_R32F.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"lumBufferPixelFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_RED\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Pixel format used for hdr lum buffer. Defaults to GL_RED.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"lumBufferType\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_FLOAT\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Type used for hdr lum buffer. Defaults to GL_FLOAT.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"imageBufferInternalFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_RGB16F\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"imageBufferPixelFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_RGB\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Pixel format used for hdr image color buffer. Defaults to GL_RGB.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"imageBufferType\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_FLOAT\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Type used for hdr image color buffer. Defaults to GL_FLOAT.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"numSamples\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"4\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"mipmapLevel\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "        The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which\n"
    "        means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other\n"
    "        values are meant for testing purposes only.\n"
    "  </Field>\n"
    "</FieldContainer>\n",
    "This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the\n"
    "average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it\n"
    "implements various tone mapping operators allowing to get comfortable with the different techniques available.\n"
    "\n"
    "Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement\n"
    "local averaging methods (histogram).\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &HDR2StageBase::getType(void)
{
    return _type;
}

const FieldContainerType &HDR2StageBase::getType(void) const
{
    return _type;
}

UInt32 HDR2StageBase::getContainerSize(void) const
{
    return sizeof(HDR2Stage);
}

/*------------------------- decorator get ------------------------------*/


SFBool *HDR2StageBase::editSFApplyGamma(void)
{
    editSField(ApplyGammaFieldMask);

    return &_sfApplyGamma;
}

const SFBool *HDR2StageBase::getSFApplyGamma(void) const
{
    return &_sfApplyGamma;
}


SFBool *HDR2StageBase::editSFAccurateGamma(void)
{
    editSField(AccurateGammaFieldMask);

    return &_sfAccurateGamma;
}

const SFBool *HDR2StageBase::getSFAccurateGamma(void) const
{
    return &_sfAccurateGamma;
}


SFBool *HDR2StageBase::editSFAdjustLuminance(void)
{
    editSField(AdjustLuminanceFieldMask);

    return &_sfAdjustLuminance;
}

const SFBool *HDR2StageBase::getSFAdjustLuminance(void) const
{
    return &_sfAdjustLuminance;
}


SFReal32 *HDR2StageBase::editSFTau(void)
{
    editSField(TauFieldMask);

    return &_sfTau;
}

const SFReal32 *HDR2StageBase::getSFTau(void) const
{
    return &_sfTau;
}


SFBool *HDR2StageBase::editSFPerformBloom(void)
{
    editSField(PerformBloomFieldMask);

    return &_sfPerformBloom;
}

const SFBool *HDR2StageBase::getSFPerformBloom(void) const
{
    return &_sfPerformBloom;
}


SFReal32 *HDR2StageBase::editSFBloomThreshold(void)
{
    editSField(BloomThresholdFieldMask);

    return &_sfBloomThreshold;
}

const SFReal32 *HDR2StageBase::getSFBloomThreshold(void) const
{
    return &_sfBloomThreshold;
}


SFBool *HDR2StageBase::editSFBloomBackground(void)
{
    editSField(BloomBackgroundFieldMask);

    return &_sfBloomBackground;
}

const SFBool *HDR2StageBase::getSFBloomBackground(void) const
{
    return &_sfBloomBackground;
}


SFReal32 *HDR2StageBase::editSFBloomMagnitude(void)
{
    editSField(BloomMagnitudeFieldMask);

    return &_sfBloomMagnitude;
}

const SFReal32 *HDR2StageBase::getSFBloomMagnitude(void) const
{
    return &_sfBloomMagnitude;
}


SFInt32 *HDR2StageBase::editSFNumTaps(void)
{
    editSField(NumTapsFieldMask);

    return &_sfNumTaps;
}

const SFInt32 *HDR2StageBase::getSFNumTaps(void) const
{
    return &_sfNumTaps;
}


SFReal32 *HDR2StageBase::editSFBlurGaussSigma(void)
{
    editSField(BlurGaussSigmaFieldMask);

    return &_sfBlurGaussSigma;
}

const SFReal32 *HDR2StageBase::getSFBlurGaussSigma(void) const
{
    return &_sfBlurGaussSigma;
}


SFUInt32 *HDR2StageBase::editSFToneMappingMode(void)
{
    editSField(ToneMappingModeFieldMask);

    return &_sfToneMappingMode;
}

const SFUInt32 *HDR2StageBase::getSFToneMappingMode(void) const
{
    return &_sfToneMappingMode;
}


SFBool *HDR2StageBase::editSFForceBackground(void)
{
    editSField(ForceBackgroundFieldMask);

    return &_sfForceBackground;
}

const SFBool *HDR2StageBase::getSFForceBackground(void) const
{
    return &_sfForceBackground;
}


SFBool *HDR2StageBase::editSFUse_ITU_R_BT_709(void)
{
    editSField(Use_ITU_R_BT_709FieldMask);

    return &_sfUse_ITU_R_BT_709;
}

const SFBool *HDR2StageBase::getSFUse_ITU_R_BT_709(void) const
{
    return &_sfUse_ITU_R_BT_709;
}


SFUInt32 *HDR2StageBase::editSFAutoExposureMode(void)
{
    editSField(AutoExposureModeFieldMask);

    return &_sfAutoExposureMode;
}

const SFUInt32 *HDR2StageBase::getSFAutoExposureMode(void) const
{
    return &_sfAutoExposureMode;
}


SFReal32 *HDR2StageBase::editSFExposure(void)
{
    editSField(ExposureFieldMask);

    return &_sfExposure;
}

const SFReal32 *HDR2StageBase::getSFExposure(void) const
{
    return &_sfExposure;
}


SFReal32 *HDR2StageBase::editSFKeyValue(void)
{
    editSField(KeyValueFieldMask);

    return &_sfKeyValue;
}

const SFReal32 *HDR2StageBase::getSFKeyValue(void) const
{
    return &_sfKeyValue;
}


SFReal32 *HDR2StageBase::editSFWhiteLevel(void)
{
    editSField(WhiteLevelFieldMask);

    return &_sfWhiteLevel;
}

const SFReal32 *HDR2StageBase::getSFWhiteLevel(void) const
{
    return &_sfWhiteLevel;
}


SFReal32 *HDR2StageBase::editSFSaturation(void)
{
    editSField(SaturationFieldMask);

    return &_sfSaturation;
}

const SFReal32 *HDR2StageBase::getSFSaturation(void) const
{
    return &_sfSaturation;
}


SFBool *HDR2StageBase::editSFUseLinChromCorrection(void)
{
    editSField(UseLinChromCorrectionFieldMask);

    return &_sfUseLinChromCorrection;
}

const SFBool *HDR2StageBase::getSFUseLinChromCorrection(void) const
{
    return &_sfUseLinChromCorrection;
}


SFReal32 *HDR2StageBase::editSFFilmicShoulderStrenght(void)
{
    editSField(FilmicShoulderStrenghtFieldMask);

    return &_sfFilmicShoulderStrenght;
}

const SFReal32 *HDR2StageBase::getSFFilmicShoulderStrenght(void) const
{
    return &_sfFilmicShoulderStrenght;
}


SFReal32 *HDR2StageBase::editSFFilmicLinearStrength(void)
{
    editSField(FilmicLinearStrengthFieldMask);

    return &_sfFilmicLinearStrength;
}

const SFReal32 *HDR2StageBase::getSFFilmicLinearStrength(void) const
{
    return &_sfFilmicLinearStrength;
}


SFReal32 *HDR2StageBase::editSFFilmicLinearAngle(void)
{
    editSField(FilmicLinearAngleFieldMask);

    return &_sfFilmicLinearAngle;
}

const SFReal32 *HDR2StageBase::getSFFilmicLinearAngle(void) const
{
    return &_sfFilmicLinearAngle;
}


SFReal32 *HDR2StageBase::editSFFilmicToeStrength(void)
{
    editSField(FilmicToeStrengthFieldMask);

    return &_sfFilmicToeStrength;
}

const SFReal32 *HDR2StageBase::getSFFilmicToeStrength(void) const
{
    return &_sfFilmicToeStrength;
}


SFReal32 *HDR2StageBase::editSFFilmicToeNumerator(void)
{
    editSField(FilmicToeNumeratorFieldMask);

    return &_sfFilmicToeNumerator;
}

const SFReal32 *HDR2StageBase::getSFFilmicToeNumerator(void) const
{
    return &_sfFilmicToeNumerator;
}


SFReal32 *HDR2StageBase::editSFFilmicToeDenominator(void)
{
    editSField(FilmicToeDenominatorFieldMask);

    return &_sfFilmicToeDenominator;
}

const SFReal32 *HDR2StageBase::getSFFilmicToeDenominator(void) const
{
    return &_sfFilmicToeDenominator;
}


SFReal32 *HDR2StageBase::editSFFilmicLinearWhite(void)
{
    editSField(FilmicLinearWhiteFieldMask);

    return &_sfFilmicLinearWhite;
}

const SFReal32 *HDR2StageBase::getSFFilmicLinearWhite(void) const
{
    return &_sfFilmicLinearWhite;
}


SFReal32 *HDR2StageBase::editSFDragoBias(void)
{
    editSField(DragoBiasFieldMask);

    return &_sfDragoBias;
}

const SFReal32 *HDR2StageBase::getSFDragoBias(void) const
{
    return &_sfDragoBias;
}


SFUInt32 *HDR2StageBase::editSFTarget(void)
{
    editSField(TargetFieldMask);

    return &_sfTarget;
}

const SFUInt32 *HDR2StageBase::getSFTarget(void) const
{
    return &_sfTarget;
}


SFBool *HDR2StageBase::editSFCarryDepth(void)
{
    editSField(CarryDepthFieldMask);

    return &_sfCarryDepth;
}

const SFBool *HDR2StageBase::getSFCarryDepth(void) const
{
    return &_sfCarryDepth;
}


SFGLenum *HDR2StageBase::editSFColorBufferInternalFormat(void)
{
    editSField(ColorBufferInternalFormatFieldMask);

    return &_sfColorBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFColorBufferInternalFormat(void) const
{
    return &_sfColorBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFColorBufferPixelFormat(void)
{
    editSField(ColorBufferPixelFormatFieldMask);

    return &_sfColorBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFColorBufferPixelFormat(void) const
{
    return &_sfColorBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFColorBufferType(void)
{
    editSField(ColorBufferTypeFieldMask);

    return &_sfColorBufferType;
}

const SFGLenum *HDR2StageBase::getSFColorBufferType(void) const
{
    return &_sfColorBufferType;
}


SFGLenum *HDR2StageBase::editSFDepthBufferInternalFormat(void)
{
    editSField(DepthBufferInternalFormatFieldMask);

    return &_sfDepthBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferInternalFormat(void) const
{
    return &_sfDepthBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFDepthBufferPixelFormat(void)
{
    editSField(DepthBufferPixelFormatFieldMask);

    return &_sfDepthBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferPixelFormat(void) const
{
    return &_sfDepthBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFDepthBufferType(void)
{
    editSField(DepthBufferTypeFieldMask);

    return &_sfDepthBufferType;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferType(void) const
{
    return &_sfDepthBufferType;
}


SFGLenum *HDR2StageBase::editSFLumBufferInternalFormat(void)
{
    editSField(LumBufferInternalFormatFieldMask);

    return &_sfLumBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFLumBufferInternalFormat(void) const
{
    return &_sfLumBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFLumBufferPixelFormat(void)
{
    editSField(LumBufferPixelFormatFieldMask);

    return &_sfLumBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFLumBufferPixelFormat(void) const
{
    return &_sfLumBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFLumBufferType(void)
{
    editSField(LumBufferTypeFieldMask);

    return &_sfLumBufferType;
}

const SFGLenum *HDR2StageBase::getSFLumBufferType(void) const
{
    return &_sfLumBufferType;
}


SFGLenum *HDR2StageBase::editSFImageBufferInternalFormat(void)
{
    editSField(ImageBufferInternalFormatFieldMask);

    return &_sfImageBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFImageBufferInternalFormat(void) const
{
    return &_sfImageBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFImageBufferPixelFormat(void)
{
    editSField(ImageBufferPixelFormatFieldMask);

    return &_sfImageBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFImageBufferPixelFormat(void) const
{
    return &_sfImageBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFImageBufferType(void)
{
    editSField(ImageBufferTypeFieldMask);

    return &_sfImageBufferType;
}

const SFGLenum *HDR2StageBase::getSFImageBufferType(void) const
{
    return &_sfImageBufferType;
}


SFInt32 *HDR2StageBase::editSFNumSamples(void)
{
    editSField(NumSamplesFieldMask);

    return &_sfNumSamples;
}

const SFInt32 *HDR2StageBase::getSFNumSamples(void) const
{
    return &_sfNumSamples;
}


SFInt32 *HDR2StageBase::editSFMipmapLevel(void)
{
    editSField(MipmapLevelFieldMask);

    return &_sfMipmapLevel;
}

const SFInt32 *HDR2StageBase::getSFMipmapLevel(void) const
{
    return &_sfMipmapLevel;
}






/*------------------------------ access -----------------------------------*/

SizeT HDR2StageBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        returnValue += _sfApplyGamma.getBinSize();
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        returnValue += _sfAccurateGamma.getBinSize();
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        returnValue += _sfAdjustLuminance.getBinSize();
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        returnValue += _sfTau.getBinSize();
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        returnValue += _sfPerformBloom.getBinSize();
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        returnValue += _sfBloomThreshold.getBinSize();
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        returnValue += _sfBloomBackground.getBinSize();
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        returnValue += _sfBloomMagnitude.getBinSize();
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        returnValue += _sfNumTaps.getBinSize();
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        returnValue += _sfBlurGaussSigma.getBinSize();
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        returnValue += _sfToneMappingMode.getBinSize();
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        returnValue += _sfForceBackground.getBinSize();
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        returnValue += _sfUse_ITU_R_BT_709.getBinSize();
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        returnValue += _sfAutoExposureMode.getBinSize();
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        returnValue += _sfExposure.getBinSize();
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        returnValue += _sfKeyValue.getBinSize();
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        returnValue += _sfWhiteLevel.getBinSize();
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        returnValue += _sfSaturation.getBinSize();
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        returnValue += _sfUseLinChromCorrection.getBinSize();
    }
    if(FieldBits::NoField != (FilmicShoulderStrenghtFieldMask & whichField))
    {
        returnValue += _sfFilmicShoulderStrenght.getBinSize();
    }
    if(FieldBits::NoField != (FilmicLinearStrengthFieldMask & whichField))
    {
        returnValue += _sfFilmicLinearStrength.getBinSize();
    }
    if(FieldBits::NoField != (FilmicLinearAngleFieldMask & whichField))
    {
        returnValue += _sfFilmicLinearAngle.getBinSize();
    }
    if(FieldBits::NoField != (FilmicToeStrengthFieldMask & whichField))
    {
        returnValue += _sfFilmicToeStrength.getBinSize();
    }
    if(FieldBits::NoField != (FilmicToeNumeratorFieldMask & whichField))
    {
        returnValue += _sfFilmicToeNumerator.getBinSize();
    }
    if(FieldBits::NoField != (FilmicToeDenominatorFieldMask & whichField))
    {
        returnValue += _sfFilmicToeDenominator.getBinSize();
    }
    if(FieldBits::NoField != (FilmicLinearWhiteFieldMask & whichField))
    {
        returnValue += _sfFilmicLinearWhite.getBinSize();
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        returnValue += _sfDragoBias.getBinSize();
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        returnValue += _sfTarget.getBinSize();
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        returnValue += _sfCarryDepth.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfColorBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfColorBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        returnValue += _sfColorBufferType.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfDepthBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfDepthBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        returnValue += _sfDepthBufferType.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfLumBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfLumBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        returnValue += _sfLumBufferType.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfImageBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfImageBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        returnValue += _sfImageBufferType.getBinSize();
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        returnValue += _sfNumSamples.getBinSize();
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        returnValue += _sfMipmapLevel.getBinSize();
    }

    return returnValue;
}

void HDR2StageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        _sfApplyGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        _sfAccurateGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        _sfAdjustLuminance.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        _sfTau.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        _sfPerformBloom.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        _sfBloomThreshold.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        _sfBloomBackground.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        _sfBloomMagnitude.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        _sfNumTaps.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        _sfBlurGaussSigma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        _sfToneMappingMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        _sfForceBackground.copyToBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        _sfUse_ITU_R_BT_709.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        _sfAutoExposureMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        _sfExposure.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        _sfKeyValue.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        _sfWhiteLevel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        _sfSaturation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        _sfUseLinChromCorrection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicShoulderStrenghtFieldMask & whichField))
    {
        _sfFilmicShoulderStrenght.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearStrengthFieldMask & whichField))
    {
        _sfFilmicLinearStrength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearAngleFieldMask & whichField))
    {
        _sfFilmicLinearAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeStrengthFieldMask & whichField))
    {
        _sfFilmicToeStrength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeNumeratorFieldMask & whichField))
    {
        _sfFilmicToeNumerator.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeDenominatorFieldMask & whichField))
    {
        _sfFilmicToeDenominator.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearWhiteFieldMask & whichField))
    {
        _sfFilmicLinearWhite.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        _sfDragoBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        _sfCarryDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        _sfColorBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        _sfColorBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        _sfColorBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        _sfDepthBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        _sfDepthBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        _sfDepthBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        _sfLumBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        _sfLumBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        _sfLumBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        _sfImageBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        _sfImageBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        _sfImageBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        _sfNumSamples.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        _sfMipmapLevel.copyToBin(pMem);
    }
}

void HDR2StageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        editSField(ApplyGammaFieldMask);
        _sfApplyGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        editSField(AccurateGammaFieldMask);
        _sfAccurateGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        editSField(AdjustLuminanceFieldMask);
        _sfAdjustLuminance.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        editSField(TauFieldMask);
        _sfTau.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        editSField(PerformBloomFieldMask);
        _sfPerformBloom.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        editSField(BloomThresholdFieldMask);
        _sfBloomThreshold.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        editSField(BloomBackgroundFieldMask);
        _sfBloomBackground.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        editSField(BloomMagnitudeFieldMask);
        _sfBloomMagnitude.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        editSField(NumTapsFieldMask);
        _sfNumTaps.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        editSField(BlurGaussSigmaFieldMask);
        _sfBlurGaussSigma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        editSField(ToneMappingModeFieldMask);
        _sfToneMappingMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        editSField(ForceBackgroundFieldMask);
        _sfForceBackground.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        editSField(Use_ITU_R_BT_709FieldMask);
        _sfUse_ITU_R_BT_709.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        editSField(AutoExposureModeFieldMask);
        _sfAutoExposureMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        editSField(ExposureFieldMask);
        _sfExposure.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        editSField(KeyValueFieldMask);
        _sfKeyValue.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        editSField(WhiteLevelFieldMask);
        _sfWhiteLevel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        editSField(SaturationFieldMask);
        _sfSaturation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        editSField(UseLinChromCorrectionFieldMask);
        _sfUseLinChromCorrection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicShoulderStrenghtFieldMask & whichField))
    {
        editSField(FilmicShoulderStrenghtFieldMask);
        _sfFilmicShoulderStrenght.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearStrengthFieldMask & whichField))
    {
        editSField(FilmicLinearStrengthFieldMask);
        _sfFilmicLinearStrength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearAngleFieldMask & whichField))
    {
        editSField(FilmicLinearAngleFieldMask);
        _sfFilmicLinearAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeStrengthFieldMask & whichField))
    {
        editSField(FilmicToeStrengthFieldMask);
        _sfFilmicToeStrength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeNumeratorFieldMask & whichField))
    {
        editSField(FilmicToeNumeratorFieldMask);
        _sfFilmicToeNumerator.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicToeDenominatorFieldMask & whichField))
    {
        editSField(FilmicToeDenominatorFieldMask);
        _sfFilmicToeDenominator.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicLinearWhiteFieldMask & whichField))
    {
        editSField(FilmicLinearWhiteFieldMask);
        _sfFilmicLinearWhite.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        editSField(DragoBiasFieldMask);
        _sfDragoBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        editSField(TargetFieldMask);
        _sfTarget.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        editSField(CarryDepthFieldMask);
        _sfCarryDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        editSField(ColorBufferInternalFormatFieldMask);
        _sfColorBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        editSField(ColorBufferPixelFormatFieldMask);
        _sfColorBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        editSField(ColorBufferTypeFieldMask);
        _sfColorBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        editSField(DepthBufferInternalFormatFieldMask);
        _sfDepthBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        editSField(DepthBufferPixelFormatFieldMask);
        _sfDepthBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        editSField(DepthBufferTypeFieldMask);
        _sfDepthBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        editSField(LumBufferInternalFormatFieldMask);
        _sfLumBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        editSField(LumBufferPixelFormatFieldMask);
        _sfLumBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        editSField(LumBufferTypeFieldMask);
        _sfLumBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        editSField(ImageBufferInternalFormatFieldMask);
        _sfImageBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        editSField(ImageBufferPixelFormatFieldMask);
        _sfImageBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        editSField(ImageBufferTypeFieldMask);
        _sfImageBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        editSField(NumSamplesFieldMask);
        _sfNumSamples.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        editSField(MipmapLevelFieldMask);
        _sfMipmapLevel.copyFromBin(pMem);
    }
}

//! create a new instance of the class
HDR2StageTransitPtr HDR2StageBase::createLocal(BitVector bFlags)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
HDR2StageTransitPtr HDR2StageBase::createDependent(BitVector bFlags)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
HDR2StageTransitPtr HDR2StageBase::create(void)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

HDR2Stage *HDR2StageBase::createEmptyLocal(BitVector bFlags)
{
    HDR2Stage *returnValue;

    newPtr<HDR2Stage>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
HDR2Stage *HDR2StageBase::createEmpty(void)
{
    HDR2Stage *returnValue;

    newPtr<HDR2Stage>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr HDR2StageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const HDR2Stage *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr HDR2StageBase::shallowCopyDependent(
    BitVector bFlags) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const HDR2Stage *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr HDR2StageBase::shallowCopy(void) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const HDR2Stage *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

HDR2StageBase::HDR2StageBase(void) :
    Inherited(),
    _sfApplyGamma             (bool(true)),
    _sfAccurateGamma          (bool(true)),
    _sfAdjustLuminance        (bool(true)),
    _sfTau                    (Real32(1.25f)),
    _sfPerformBloom           (bool(true)),
    _sfBloomThreshold         (Real32(2.f)),
    _sfBloomBackground        (bool(true)),
    _sfBloomMagnitude         (Real32(0.f)),
    _sfNumTaps                (Int32(4)),
    _sfBlurGaussSigma         (Real32(0.8f)),
    _sfToneMappingMode        (UInt32(4)),
    _sfForceBackground        (bool(false)),
    _sfUse_ITU_R_BT_709       (bool(true)),
    _sfAutoExposureMode       (UInt32(2)),
    _sfExposure               (Real32(0.f)),
    _sfKeyValue               (Real32(0.18f)),
    _sfWhiteLevel             (Real32(5.f)),
    _sfSaturation             (Real32(1.f)),
    _sfUseLinChromCorrection  (bool(true)),
    _sfFilmicShoulderStrenght (Real32(0.15f)),
    _sfFilmicLinearStrength   (Real32(0.5f)),
    _sfFilmicLinearAngle      (Real32(0.1f)),
    _sfFilmicToeStrength      (Real32(0.2f)),
    _sfFilmicToeNumerator     (Real32(0.02f)),
    _sfFilmicToeDenominator   (Real32(0.3f)),
    _sfFilmicLinearWhite      (Real32(11.2f)),
    _sfDragoBias              (Real32(0.85f)),
    _sfTarget                 (UInt32(5)),
    _sfCarryDepth             (bool(true)),
    _sfColorBufferInternalFormat(GLenum(GL_RGBA16F)),
    _sfColorBufferPixelFormat (GLenum(GL_RGBA)),
    _sfColorBufferType        (GLenum(GL_FLOAT)),
    _sfDepthBufferInternalFormat(GLenum(GL_DEPTH24_STENCIL8)),
    _sfDepthBufferPixelFormat (GLenum(GL_DEPTH_STENCIL)),
    _sfDepthBufferType        (GLenum(GL_UNSIGNED_INT_24_8)),
    _sfLumBufferInternalFormat(GLenum(GL_R32F)),
    _sfLumBufferPixelFormat   (GLenum(GL_RED)),
    _sfLumBufferType          (GLenum(GL_FLOAT)),
    _sfImageBufferInternalFormat(GLenum(GL_RGB16F)),
    _sfImageBufferPixelFormat (GLenum(GL_RGB)),
    _sfImageBufferType        (GLenum(GL_FLOAT)),
    _sfNumSamples             (Int32(4)),
    _sfMipmapLevel            (Int32(-1))
{
}

HDR2StageBase::HDR2StageBase(const HDR2StageBase &source) :
    Inherited(source),
    _sfApplyGamma             (source._sfApplyGamma             ),
    _sfAccurateGamma          (source._sfAccurateGamma          ),
    _sfAdjustLuminance        (source._sfAdjustLuminance        ),
    _sfTau                    (source._sfTau                    ),
    _sfPerformBloom           (source._sfPerformBloom           ),
    _sfBloomThreshold         (source._sfBloomThreshold         ),
    _sfBloomBackground        (source._sfBloomBackground        ),
    _sfBloomMagnitude         (source._sfBloomMagnitude         ),
    _sfNumTaps                (source._sfNumTaps                ),
    _sfBlurGaussSigma         (source._sfBlurGaussSigma         ),
    _sfToneMappingMode        (source._sfToneMappingMode        ),
    _sfForceBackground        (source._sfForceBackground        ),
    _sfUse_ITU_R_BT_709       (source._sfUse_ITU_R_BT_709       ),
    _sfAutoExposureMode       (source._sfAutoExposureMode       ),
    _sfExposure               (source._sfExposure               ),
    _sfKeyValue               (source._sfKeyValue               ),
    _sfWhiteLevel             (source._sfWhiteLevel             ),
    _sfSaturation             (source._sfSaturation             ),
    _sfUseLinChromCorrection  (source._sfUseLinChromCorrection  ),
    _sfFilmicShoulderStrenght (source._sfFilmicShoulderStrenght ),
    _sfFilmicLinearStrength   (source._sfFilmicLinearStrength   ),
    _sfFilmicLinearAngle      (source._sfFilmicLinearAngle      ),
    _sfFilmicToeStrength      (source._sfFilmicToeStrength      ),
    _sfFilmicToeNumerator     (source._sfFilmicToeNumerator     ),
    _sfFilmicToeDenominator   (source._sfFilmicToeDenominator   ),
    _sfFilmicLinearWhite      (source._sfFilmicLinearWhite      ),
    _sfDragoBias              (source._sfDragoBias              ),
    _sfTarget                 (source._sfTarget                 ),
    _sfCarryDepth             (source._sfCarryDepth             ),
    _sfColorBufferInternalFormat(source._sfColorBufferInternalFormat),
    _sfColorBufferPixelFormat (source._sfColorBufferPixelFormat ),
    _sfColorBufferType        (source._sfColorBufferType        ),
    _sfDepthBufferInternalFormat(source._sfDepthBufferInternalFormat),
    _sfDepthBufferPixelFormat (source._sfDepthBufferPixelFormat ),
    _sfDepthBufferType        (source._sfDepthBufferType        ),
    _sfLumBufferInternalFormat(source._sfLumBufferInternalFormat),
    _sfLumBufferPixelFormat   (source._sfLumBufferPixelFormat   ),
    _sfLumBufferType          (source._sfLumBufferType          ),
    _sfImageBufferInternalFormat(source._sfImageBufferInternalFormat),
    _sfImageBufferPixelFormat (source._sfImageBufferPixelFormat ),
    _sfImageBufferType        (source._sfImageBufferType        ),
    _sfNumSamples             (source._sfNumSamples             ),
    _sfMipmapLevel            (source._sfMipmapLevel            )
{
}


/*-------------------------- destructors ----------------------------------*/

HDR2StageBase::~HDR2StageBase(void)
{
}


GetFieldHandlePtr HDR2StageBase::getHandleApplyGamma      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleApplyGamma     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             this));


    editSField(ApplyGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAccurateGamma   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAccurateGamma  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             this));


    editSField(AccurateGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAdjustLuminance (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAdjustLuminance,
             this->getType().getFieldDesc(AdjustLuminanceFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAdjustLuminance(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAdjustLuminance,
             this->getType().getFieldDesc(AdjustLuminanceFieldId),
             this));


    editSField(AdjustLuminanceFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleTau             (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfTau,
             this->getType().getFieldDesc(TauFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleTau            (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfTau,
             this->getType().getFieldDesc(TauFieldId),
             this));


    editSField(TauFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandlePerformBloom    (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfPerformBloom,
             this->getType().getFieldDesc(PerformBloomFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandlePerformBloom   (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfPerformBloom,
             this->getType().getFieldDesc(PerformBloomFieldId),
             this));


    editSField(PerformBloomFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomThreshold  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBloomThreshold,
             this->getType().getFieldDesc(BloomThresholdFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomThreshold (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBloomThreshold,
             this->getType().getFieldDesc(BloomThresholdFieldId),
             this));


    editSField(BloomThresholdFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomBackground (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfBloomBackground,
             this->getType().getFieldDesc(BloomBackgroundFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomBackground(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfBloomBackground,
             this->getType().getFieldDesc(BloomBackgroundFieldId),
             this));


    editSField(BloomBackgroundFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomMagnitude  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBloomMagnitude,
             this->getType().getFieldDesc(BloomMagnitudeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomMagnitude (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBloomMagnitude,
             this->getType().getFieldDesc(BloomMagnitudeFieldId),
             this));


    editSField(BloomMagnitudeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleNumTaps         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumTaps,
             this->getType().getFieldDesc(NumTapsFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleNumTaps        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumTaps,
             this->getType().getFieldDesc(NumTapsFieldId),
             this));


    editSField(NumTapsFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBlurGaussSigma  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBlurGaussSigma,
             this->getType().getFieldDesc(BlurGaussSigmaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBlurGaussSigma (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBlurGaussSigma,
             this->getType().getFieldDesc(BlurGaussSigmaFieldId),
             this));


    editSField(BlurGaussSigmaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleToneMappingMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleToneMappingMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             this));


    editSField(ToneMappingModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleForceBackground (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceBackground,
             this->getType().getFieldDesc(ForceBackgroundFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleForceBackground(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceBackground,
             this->getType().getFieldDesc(ForceBackgroundFieldId),
             this));


    editSField(ForceBackgroundFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleUse_ITU_R_BT_709 (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleUse_ITU_R_BT_709(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             this));


    editSField(Use_ITU_R_BT_709FieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAutoExposureMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAutoExposureMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             this));


    editSField(AutoExposureModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleExposure        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleExposure       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             this));


    editSField(ExposureFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleKeyValue        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleKeyValue       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             this));


    editSField(KeyValueFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleWhiteLevel      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleWhiteLevel     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             this));


    editSField(WhiteLevelFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleSaturation      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleSaturation     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             this));


    editSField(SaturationFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleUseLinChromCorrection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleUseLinChromCorrection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             this));


    editSField(UseLinChromCorrectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicShoulderStrenght (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicShoulderStrenght,
             this->getType().getFieldDesc(FilmicShoulderStrenghtFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicShoulderStrenght(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicShoulderStrenght,
             this->getType().getFieldDesc(FilmicShoulderStrenghtFieldId),
             this));


    editSField(FilmicShoulderStrenghtFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicLinearStrength (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicLinearStrength,
             this->getType().getFieldDesc(FilmicLinearStrengthFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicLinearStrength(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicLinearStrength,
             this->getType().getFieldDesc(FilmicLinearStrengthFieldId),
             this));


    editSField(FilmicLinearStrengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicLinearAngle (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicLinearAngle,
             this->getType().getFieldDesc(FilmicLinearAngleFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicLinearAngle(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicLinearAngle,
             this->getType().getFieldDesc(FilmicLinearAngleFieldId),
             this));


    editSField(FilmicLinearAngleFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicToeStrength (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicToeStrength,
             this->getType().getFieldDesc(FilmicToeStrengthFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicToeStrength(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicToeStrength,
             this->getType().getFieldDesc(FilmicToeStrengthFieldId),
             this));


    editSField(FilmicToeStrengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicToeNumerator (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicToeNumerator,
             this->getType().getFieldDesc(FilmicToeNumeratorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicToeNumerator(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicToeNumerator,
             this->getType().getFieldDesc(FilmicToeNumeratorFieldId),
             this));


    editSField(FilmicToeNumeratorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicToeDenominator (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicToeDenominator,
             this->getType().getFieldDesc(FilmicToeDenominatorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicToeDenominator(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicToeDenominator,
             this->getType().getFieldDesc(FilmicToeDenominatorFieldId),
             this));


    editSField(FilmicToeDenominatorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicLinearWhite (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilmicLinearWhite,
             this->getType().getFieldDesc(FilmicLinearWhiteFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicLinearWhite(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilmicLinearWhite,
             this->getType().getFieldDesc(FilmicLinearWhiteFieldId),
             this));


    editSField(FilmicLinearWhiteFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDragoBias       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDragoBias      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             this));


    editSField(DragoBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleTarget          (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleTarget         (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             this));


    editSField(TargetFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleCarryDepth      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfCarryDepth,
             this->getType().getFieldDesc(CarryDepthFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleCarryDepth     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfCarryDepth,
             this->getType().getFieldDesc(CarryDepthFieldId),
             this));


    editSField(CarryDepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferInternalFormat,
             this->getType().getFieldDesc(ColorBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferInternalFormat,
             this->getType().getFieldDesc(ColorBufferInternalFormatFieldId),
             this));


    editSField(ColorBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferPixelFormat,
             this->getType().getFieldDesc(ColorBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferPixelFormat,
             this->getType().getFieldDesc(ColorBufferPixelFormatFieldId),
             this));


    editSField(ColorBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferType,
             this->getType().getFieldDesc(ColorBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferType,
             this->getType().getFieldDesc(ColorBufferTypeFieldId),
             this));


    editSField(ColorBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferInternalFormat,
             this->getType().getFieldDesc(DepthBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferInternalFormat,
             this->getType().getFieldDesc(DepthBufferInternalFormatFieldId),
             this));


    editSField(DepthBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferPixelFormat,
             this->getType().getFieldDesc(DepthBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferPixelFormat,
             this->getType().getFieldDesc(DepthBufferPixelFormatFieldId),
             this));


    editSField(DepthBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferType,
             this->getType().getFieldDesc(DepthBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferType,
             this->getType().getFieldDesc(DepthBufferTypeFieldId),
             this));


    editSField(DepthBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferInternalFormat,
             this->getType().getFieldDesc(LumBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferInternalFormat,
             this->getType().getFieldDesc(LumBufferInternalFormatFieldId),
             this));


    editSField(LumBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferPixelFormat,
             this->getType().getFieldDesc(LumBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferPixelFormat,
             this->getType().getFieldDesc(LumBufferPixelFormatFieldId),
             this));


    editSField(LumBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferType   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferType,
             this->getType().getFieldDesc(LumBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferType  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferType,
             this->getType().getFieldDesc(LumBufferTypeFieldId),
             this));


    editSField(LumBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferInternalFormat,
             this->getType().getFieldDesc(ImageBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferInternalFormat,
             this->getType().getFieldDesc(ImageBufferInternalFormatFieldId),
             this));


    editSField(ImageBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferPixelFormat,
             this->getType().getFieldDesc(ImageBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferPixelFormat,
             this->getType().getFieldDesc(ImageBufferPixelFormatFieldId),
             this));


    editSField(ImageBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferType,
             this->getType().getFieldDesc(ImageBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferType,
             this->getType().getFieldDesc(ImageBufferTypeFieldId),
             this));


    editSField(ImageBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleNumSamples      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumSamples,
             this->getType().getFieldDesc(NumSamplesFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleNumSamples     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumSamples,
             this->getType().getFieldDesc(NumSamplesFieldId),
             this));


    editSField(NumSamplesFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleMipmapLevel     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfMipmapLevel,
             this->getType().getFieldDesc(MipmapLevelFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleMipmapLevel    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfMipmapLevel,
             this->getType().getFieldDesc(MipmapLevelFieldId),
             this));


    editSField(MipmapLevelFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void HDR2StageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    HDR2Stage *pThis = static_cast<HDR2Stage *>(this);

    pThis->execSync(static_cast<HDR2Stage *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *HDR2StageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    HDR2Stage *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const HDR2Stage *>(pRefAspect),
                  dynamic_cast<const HDR2Stage *>(this));

    return returnValue;
}
#endif

void HDR2StageBase::resolveLinks(void)
{
    Inherited::resolveLinks();


}


OSG_END_NAMESPACE

/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureEnvChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTUREENVCHUNKINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>                        // EnvMode default header
#include <OSGGL.h>                        // EnvCombineRGB default header
#include <OSGGL.h>                        // EnvCombineAlpha default header
#include <OSGGL.h>                        // EnvSource0RGB default header
#include <OSGGLEXT.h>                     // EnvSource1RGB default header
#include <OSGGLEXT.h>                     // EnvSource2RGB default header
#include <OSGGL.h>                        // EnvSource0Alpha default header
#include <OSGGLEXT.h>                     // EnvSource1Alpha default header
#include <OSGGLEXT.h>                     // EnvSource2Alpha default header
#include <OSGGL.h>                        // EnvOperand0RGB default header
#include <OSGGL.h>                        // EnvOperand1RGB default header
#include <OSGGL.h>                        // EnvOperand2RGB default header
#include <OSGGL.h>                        // EnvOperand0Alpha default header
#include <OSGGL.h>                        // EnvOperand1Alpha default header
#include <OSGGL.h>                        // EnvOperand2Alpha default header
#include <OSGGL.h>                        // PointSprite default header
#include <OSGGL.h>                        // ShaderOperation default header
#include <OSGGL.h>                        // ShaderInput default header
#include <OSGGL.h>                        // ShaderRGBADotProduct default header


#include "OSGTextureEnvChunkBase.h"
#include "OSGTextureEnvChunk.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::TextureEnvChunk
    \ingroup GrpSystemState
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvMode
    Texture environment mode, default GL_REPLACE.
*/

/*! \var Color4f         TextureEnvChunkBase::_sfEnvColor
    Texture environment color default transparent black.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvCombineRGB
    Texture environment rgb combine mode, default GL_MODULATE.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvCombineAlpha
    Texture environment alpha combine mode, default GL_MODULATE.
*/

/*! \var Real32          TextureEnvChunkBase::_sfEnvScaleRGB
    Texture environment combine rgb scale factor, default 1.f.
*/

/*! \var Real32          TextureEnvChunkBase::_sfEnvScaleAlpha
    Texture environment combine alpha scale factor, default 1.f.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource0RGB
    Texture environment combine source 0 rgb, default GL_TEXTURE.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource1RGB
    Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource2RGB
    Texture environment combine source 2 rgb, default GL_CONSTANT_EXT.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource0Alpha
    Texture environment combine source 0 alpha, default GL_TEXTURE.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource1Alpha
    Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvSource2Alpha
    Texture environment combine source 2 alpha, default GL_CONSTANT_EXT.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand0RGB
    Texture environment combine operand 0 rgb, default GL_SRC_COLOR.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand1RGB
    Texture environment combine operand 1 rgb, default GL_SRC_COLOR.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand2RGB
    Texture environment combine operand 2 rgb, default GL_SRC_ALPHA.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand0Alpha
    Texture environment combine operand 0 alpha, default GL_SRC_ALPHA.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand1Alpha
    Texture environment combine operand 1 alpha, default GL_SRC_ALPHA.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfEnvOperand2Alpha
    Texture environment combine operand 2 alpha, default GL_SRC_ALPHA.
*/

/*! \var bool            TextureEnvChunkBase::_sfPointSprite
    Flag to use this texture for Point Sprites.
*/

/*! \var GLenum          TextureEnvChunkBase::_sfShaderOperation
    Shader operation of this texture unit, default GL_NONE. If unit 0 uses
    GL_NONE, shading is switched off. (GL_SHADER_OPERATION_NV).
*/

/*! \var GLenum          TextureEnvChunkBase::_sfShaderInput
    Input texture unit for this shader's operation. (GL_TEXTURE_SHADER_NV)
*/

/*! \var Real32          TextureEnvChunkBase::_mfShaderOffsetMatrix
    The 2x2 transformation matrix for offset textures. (GL_OFFSET_TEXTURE_MATRIX_NV)
*/

/*! \var Real32          TextureEnvChunkBase::_sfShaderOffsetScale
    The scaling factor for scaled offset textures. (GL_OFFSET_TEXTURE_SCALE_NV)
*/

/*! \var Real32          TextureEnvChunkBase::_sfShaderOffsetBias
    The bias factor for scaled offset textures. (GL_OFFSET_TEXTURE_BIAS_NV)
*/

/*! \var GLenum          TextureEnvChunkBase::_sfShaderRGBADotProduct
    The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.
*/

/*! \var UInt8           TextureEnvChunkBase::_sfShaderCullModes
    The CULL_MODES_NV value, coded into a single byte. The first 4 bits of
    the byte are used to indicate the wnated cull modes, a value of 0 
    signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for 
    the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 
    (mask 8) for Q.
*/

/*! \var Vec3f           TextureEnvChunkBase::_sfShaderConstEye
    The CONST_EYE_NV value, i.e. the constant eye position used by the 
    DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.
*/

/*! \var Real32          TextureEnvChunkBase::_sfLodBias
    Bias of LOD calculation for texture access.
*/


void TextureEnvChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvModeF)(void) const;

    GetSFEnvModeF GetSFEnvMode = &TextureEnvChunkBase::getSFEnvMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envMode",
        "Texture environment mode, default GL_REPLACE.\n",
        EnvModeFieldId, EnvModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFColor4f *(TextureEnvChunkBase::*GetSFEnvColorF)(void) const;

    GetSFEnvColorF GetSFEnvColor = &TextureEnvChunkBase::getSFEnvColor;
#endif

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "envColor",
        "Texture environment color default transparent black.\n",
        EnvColorFieldId, EnvColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvCombineRGBF)(void) const;

    GetSFEnvCombineRGBF GetSFEnvCombineRGB = &TextureEnvChunkBase::getSFEnvCombineRGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envCombineRGB",
        "Texture environment rgb combine mode, default GL_MODULATE.\n",
        EnvCombineRGBFieldId, EnvCombineRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvCombineRGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvCombineRGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvCombineRGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvCombineAlphaF)(void) const;

    GetSFEnvCombineAlphaF GetSFEnvCombineAlpha = &TextureEnvChunkBase::getSFEnvCombineAlpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envCombineAlpha",
        "Texture environment alpha combine mode, default GL_MODULATE.\n",
        EnvCombineAlphaFieldId, EnvCombineAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvCombineAlpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvCombineAlpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvCombineAlpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureEnvChunkBase::*GetSFEnvScaleRGBF)(void) const;

    GetSFEnvScaleRGBF GetSFEnvScaleRGB = &TextureEnvChunkBase::getSFEnvScaleRGB;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "envScaleRGB",
        "Texture environment combine rgb scale factor, default 1.f.\n",
        EnvScaleRGBFieldId, EnvScaleRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvScaleRGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvScaleRGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvScaleRGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureEnvChunkBase::*GetSFEnvScaleAlphaF)(void) const;

    GetSFEnvScaleAlphaF GetSFEnvScaleAlpha = &TextureEnvChunkBase::getSFEnvScaleAlpha;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "envScaleAlpha",
        "Texture environment combine alpha scale factor, default 1.f.\n",
        EnvScaleAlphaFieldId, EnvScaleAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvScaleAlpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvScaleAlpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvScaleAlpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource0RGBF)(void) const;

    GetSFEnvSource0RGBF GetSFEnvSource0RGB = &TextureEnvChunkBase::getSFEnvSource0RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource0RGB",
        "Texture environment combine source 0 rgb, default GL_TEXTURE.\n",
        EnvSource0RGBFieldId, EnvSource0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource0RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource0RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource0RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource1RGBF)(void) const;

    GetSFEnvSource1RGBF GetSFEnvSource1RGB = &TextureEnvChunkBase::getSFEnvSource1RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource1RGB",
        "Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT.\n",
        EnvSource1RGBFieldId, EnvSource1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource1RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource1RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource1RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource2RGBF)(void) const;

    GetSFEnvSource2RGBF GetSFEnvSource2RGB = &TextureEnvChunkBase::getSFEnvSource2RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource2RGB",
        "Texture environment combine source 2 rgb, default GL_CONSTANT_EXT.\n",
        EnvSource2RGBFieldId, EnvSource2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource2RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource2RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource2RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource0AlphaF)(void) const;

    GetSFEnvSource0AlphaF GetSFEnvSource0Alpha = &TextureEnvChunkBase::getSFEnvSource0Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource0Alpha",
        "Texture environment combine source 0 alpha, default GL_TEXTURE.\n",
        EnvSource0AlphaFieldId, EnvSource0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource0Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource0Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource0Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource1AlphaF)(void) const;

    GetSFEnvSource1AlphaF GetSFEnvSource1Alpha = &TextureEnvChunkBase::getSFEnvSource1Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource1Alpha",
        "Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT.\n",
        EnvSource1AlphaFieldId, EnvSource1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource1Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource1Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource1Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvSource2AlphaF)(void) const;

    GetSFEnvSource2AlphaF GetSFEnvSource2Alpha = &TextureEnvChunkBase::getSFEnvSource2Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource2Alpha",
        "Texture environment combine source 2 alpha, default GL_CONSTANT_EXT.\n",
        EnvSource2AlphaFieldId, EnvSource2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvSource2Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource2Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvSource2Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand0RGBF)(void) const;

    GetSFEnvOperand0RGBF GetSFEnvOperand0RGB = &TextureEnvChunkBase::getSFEnvOperand0RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand0RGB",
        "Texture environment combine operand 0 rgb, default GL_SRC_COLOR.\n",
        EnvOperand0RGBFieldId, EnvOperand0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand0RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand0RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand0RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand1RGBF)(void) const;

    GetSFEnvOperand1RGBF GetSFEnvOperand1RGB = &TextureEnvChunkBase::getSFEnvOperand1RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand1RGB",
        "Texture environment combine operand 1 rgb, default GL_SRC_COLOR.\n",
        EnvOperand1RGBFieldId, EnvOperand1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand1RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand1RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand1RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand2RGBF)(void) const;

    GetSFEnvOperand2RGBF GetSFEnvOperand2RGB = &TextureEnvChunkBase::getSFEnvOperand2RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand2RGB",
        "Texture environment combine operand 2 rgb, default GL_SRC_ALPHA.\n",
        EnvOperand2RGBFieldId, EnvOperand2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand2RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand2RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand2RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand0AlphaF)(void) const;

    GetSFEnvOperand0AlphaF GetSFEnvOperand0Alpha = &TextureEnvChunkBase::getSFEnvOperand0Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand0Alpha",
        "Texture environment combine operand 0 alpha, default GL_SRC_ALPHA.\n",
        EnvOperand0AlphaFieldId, EnvOperand0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand0Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand0Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand0Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand1AlphaF)(void) const;

    GetSFEnvOperand1AlphaF GetSFEnvOperand1Alpha = &TextureEnvChunkBase::getSFEnvOperand1Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand1Alpha",
        "Texture environment combine operand 1 alpha, default GL_SRC_ALPHA.\n",
        EnvOperand1AlphaFieldId, EnvOperand1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand1Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand1Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand1Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFEnvOperand2AlphaF)(void) const;

    GetSFEnvOperand2AlphaF GetSFEnvOperand2Alpha = &TextureEnvChunkBase::getSFEnvOperand2Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand2Alpha",
        "Texture environment combine operand 2 alpha, default GL_SRC_ALPHA.\n",
        EnvOperand2AlphaFieldId, EnvOperand2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFEnvOperand2Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand2Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFEnvOperand2Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(TextureEnvChunkBase::*GetSFPointSpriteF)(void) const;

    GetSFPointSpriteF GetSFPointSprite = &TextureEnvChunkBase::getSFPointSprite;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "pointSprite",
        "Flag to use this texture for Point Sprites.\n",
        PointSpriteFieldId, PointSpriteFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFPointSprite),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPointSprite));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFPointSprite));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFShaderOperationF)(void) const;

    GetSFShaderOperationF GetSFShaderOperation = &TextureEnvChunkBase::getSFShaderOperation;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderOperation",
        "Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n"
        "GL_NONE, shading is switched off. (GL_SHADER_OPERATION_NV).\n",
        ShaderOperationFieldId, ShaderOperationFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderOperation),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOperation));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderOperation));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFShaderInputF)(void) const;

    GetSFShaderInputF GetSFShaderInput = &TextureEnvChunkBase::getSFShaderInput;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderInput",
        "Input texture unit for this shader's operation. (GL_TEXTURE_SHADER_NV)\n",
        ShaderInputFieldId, ShaderInputFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderInput),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderInput));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderInput));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFReal32 *(TextureEnvChunkBase::*GetMFShaderOffsetMatrixF)(void) const;

    GetMFShaderOffsetMatrixF GetMFShaderOffsetMatrix = &TextureEnvChunkBase::getMFShaderOffsetMatrix;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "shaderOffsetMatrix",
        "The 2x2 transformation matrix for offset textures. (GL_OFFSET_TEXTURE_MATRIX_NV)\n",
        ShaderOffsetMatrixFieldId, ShaderOffsetMatrixFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editMFShaderOffsetMatrix),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFShaderOffsetMatrix));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getMFShaderOffsetMatrix));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureEnvChunkBase::*GetSFShaderOffsetScaleF)(void) const;

    GetSFShaderOffsetScaleF GetSFShaderOffsetScale = &TextureEnvChunkBase::getSFShaderOffsetScale;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shaderOffsetScale",
        "The scaling factor for scaled offset textures. (GL_OFFSET_TEXTURE_SCALE_NV)\n",
        ShaderOffsetScaleFieldId, ShaderOffsetScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderOffsetScale),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOffsetScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderOffsetScale));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureEnvChunkBase::*GetSFShaderOffsetBiasF)(void) const;

    GetSFShaderOffsetBiasF GetSFShaderOffsetBias = &TextureEnvChunkBase::getSFShaderOffsetBias;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shaderOffsetBias",
        "The bias factor for scaled offset textures. (GL_OFFSET_TEXTURE_BIAS_NV)\n",
        ShaderOffsetBiasFieldId, ShaderOffsetBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderOffsetBias),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOffsetBias));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderOffsetBias));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureEnvChunkBase::*GetSFShaderRGBADotProductF)(void) const;

    GetSFShaderRGBADotProductF GetSFShaderRGBADotProduct = &TextureEnvChunkBase::getSFShaderRGBADotProduct;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderRGBADotProduct",
        "The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n",
        ShaderRGBADotProductFieldId, ShaderRGBADotProductFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderRGBADotProduct),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderRGBADotProduct));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderRGBADotProduct));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt8 *(TextureEnvChunkBase::*GetSFShaderCullModesF)(void) const;

    GetSFShaderCullModesF GetSFShaderCullModes = &TextureEnvChunkBase::getSFShaderCullModes;
#endif

    pDesc = new SFUInt8::Description(
        SFUInt8::getClassType(),
        "shaderCullModes",
        "The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n"
        "the byte are used to indicate the wnated cull modes, a value of 0 \n"
        "signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n"
        "the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n"
        "(mask 8) for Q.\n",
        ShaderCullModesFieldId, ShaderCullModesFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderCullModes),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderCullModes));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderCullModes));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFVec3f *(TextureEnvChunkBase::*GetSFShaderConstEyeF)(void) const;

    GetSFShaderConstEyeF GetSFShaderConstEye = &TextureEnvChunkBase::getSFShaderConstEye;
#endif

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "shaderConstEye",
        "The CONST_EYE_NV value, i.e. the constant eye position used by the \n"
        "DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n",
        ShaderConstEyeFieldId, ShaderConstEyeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFShaderConstEye),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderConstEye));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFShaderConstEye));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureEnvChunkBase::*GetSFLodBiasF)(void) const;

    GetSFLodBiasF GetSFLodBias = &TextureEnvChunkBase::getSFLodBias;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lodBias",
        "Bias of LOD calculation for texture access.\n",
        LodBiasFieldId, LodBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureEnvChunkBase::editSFLodBias),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFLodBias));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureEnvChunkBase::getSFLodBias));
#endif

    oType.addInitialDesc(pDesc);
}


TextureEnvChunkBase::TypeObject TextureEnvChunkBase::_type(true,
    TextureEnvChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &TextureEnvChunkBase::createEmpty,
    TextureEnvChunk::initMethod,
    (InitalInsertDescFunc) &TextureEnvChunkBase::classDescInserter,
    false,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"TextureEnvChunk\"\n"
    "\tparent=\"StateChunk\"\n"
    "\tlibrary=\"System\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    ">\n"
    "\\ingroup GrpSystemState\n"
    "\t<Field\n"
    "\t\tname=\"envMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPLACE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_ADD, GL_COMBINE\"\n"
    "\t>\n"
    "        Texture environment mode, default GL_REPLACE.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0,0,0,0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment color default transparent black.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envCombineRGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_MODULATE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_REPLACE, GL_MODULATE, GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_SUBTRACT, GL_DOT3_RGB, GL_DOT3_RGBA\"\n"
    "\t>\n"
    "        Texture environment rgb combine mode, default GL_MODULATE.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envCombineAlpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_MODULATE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_REPLACE, GL_MODULATE, GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_SUBTRACT\"\n"
    "\t>\n"
    "        Texture environment alpha combine mode, default GL_MODULATE.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envScaleRGB\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine rgb scale factor, default 1.f.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envScaleAlpha\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine alpha scale factor, default 1.f.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource0RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TEXTURE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 0 rgb, default GL_TEXTURE.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource1RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_PREVIOUS_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource2RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_CONSTANT_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 2 rgb, default GL_CONSTANT_EXT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource0Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TEXTURE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 0 alpha, default GL_TEXTURE.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource1Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_PREVIOUS_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource2Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_CONSTANT_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 2 alpha, default GL_CONSTANT_EXT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand0RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_COLOR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 0 rgb, default GL_SRC_COLOR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand1RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_COLOR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 1 rgb, default GL_SRC_COLOR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand2RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 2 rgb, default GL_SRC_ALPHA.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand0Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 0 alpha, default GL_SRC_ALPHA.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand1Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 1 alpha, default GL_SRC_ALPHA.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand2Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 2 alpha, default GL_SRC_ALPHA.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pointSprite\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_FALSE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Flag to use this texture for Point Sprites.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOperation\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n"
    "        GL_NONE, shading is switched off. (GL_SHADER_OPERATION_NV).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderInput\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Input texture unit for this shader's operation. (GL_TEXTURE_SHADER_NV)\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetMatrix\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The 2x2 transformation matrix for offset textures. (GL_OFFSET_TEXTURE_MATRIX_NV)\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetScale\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"1.f\"\n"
    "\t>\n"
    "        The scaling factor for scaled offset textures. (GL_OFFSET_TEXTURE_SCALE_NV)\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetBias\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0.f\"\n"
    "\t>\n"
    "        The bias factor for scaled offset textures. (GL_OFFSET_TEXTURE_BIAS_NV)\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderRGBADotProduct\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderCullModes\"\n"
    "\t\ttype=\"UInt8\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t>\n"
    "        The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n"
    "        the byte are used to indicate the wnated cull modes, a value of 0 \n"
    "        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n"
    "        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n"
    "        (mask 8) for Q.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderConstEye\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The CONST_EYE_NV value, i.e. the constant eye position used by the \n"
    "        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"lodBias\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0.f\"\n"
    "\t\tdefaultHeader=\"\"\n"
    "\t>\n"
    "        Bias of LOD calculation for texture access.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemState\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureEnvChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &TextureEnvChunkBase::getType(void) const
{
    return _type;
}

UInt32 TextureEnvChunkBase::getContainerSize(void) const
{
    return sizeof(TextureEnvChunk);
}

/*------------------------- decorator get ------------------------------*/


SFGLenum *TextureEnvChunkBase::editSFEnvMode(void)
{
    editSField(EnvModeFieldMask);

    return &_sfEnvMode;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvMode(void) const
{
    return &_sfEnvMode;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvMode        (void)
{
    return this->editSFEnvMode        ();
}
#endif

SFColor4f *TextureEnvChunkBase::editSFEnvColor(void)
{
    editSField(EnvColorFieldMask);

    return &_sfEnvColor;
}

const SFColor4f *TextureEnvChunkBase::getSFEnvColor(void) const
{
    return &_sfEnvColor;
}

#ifdef OSG_1_COMPAT
SFColor4f           *TextureEnvChunkBase::getSFEnvColor       (void)
{
    return this->editSFEnvColor       ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvCombineRGB(void)
{
    editSField(EnvCombineRGBFieldMask);

    return &_sfEnvCombineRGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvCombineRGB(void) const
{
    return &_sfEnvCombineRGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvCombineRGB  (void)
{
    return this->editSFEnvCombineRGB  ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvCombineAlpha(void)
{
    editSField(EnvCombineAlphaFieldMask);

    return &_sfEnvCombineAlpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvCombineAlpha(void) const
{
    return &_sfEnvCombineAlpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvCombineAlpha(void)
{
    return this->editSFEnvCombineAlpha();
}
#endif

SFReal32 *TextureEnvChunkBase::editSFEnvScaleRGB(void)
{
    editSField(EnvScaleRGBFieldMask);

    return &_sfEnvScaleRGB;
}

const SFReal32 *TextureEnvChunkBase::getSFEnvScaleRGB(void) const
{
    return &_sfEnvScaleRGB;
}

#ifdef OSG_1_COMPAT
SFReal32            *TextureEnvChunkBase::getSFEnvScaleRGB    (void)
{
    return this->editSFEnvScaleRGB    ();
}
#endif

SFReal32 *TextureEnvChunkBase::editSFEnvScaleAlpha(void)
{
    editSField(EnvScaleAlphaFieldMask);

    return &_sfEnvScaleAlpha;
}

const SFReal32 *TextureEnvChunkBase::getSFEnvScaleAlpha(void) const
{
    return &_sfEnvScaleAlpha;
}

#ifdef OSG_1_COMPAT
SFReal32            *TextureEnvChunkBase::getSFEnvScaleAlpha  (void)
{
    return this->editSFEnvScaleAlpha  ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource0RGB(void)
{
    editSField(EnvSource0RGBFieldMask);

    return &_sfEnvSource0RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource0RGB(void) const
{
    return &_sfEnvSource0RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource0RGB  (void)
{
    return this->editSFEnvSource0RGB  ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource1RGB(void)
{
    editSField(EnvSource1RGBFieldMask);

    return &_sfEnvSource1RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource1RGB(void) const
{
    return &_sfEnvSource1RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource1RGB  (void)
{
    return this->editSFEnvSource1RGB  ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource2RGB(void)
{
    editSField(EnvSource2RGBFieldMask);

    return &_sfEnvSource2RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource2RGB(void) const
{
    return &_sfEnvSource2RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource2RGB  (void)
{
    return this->editSFEnvSource2RGB  ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource0Alpha(void)
{
    editSField(EnvSource0AlphaFieldMask);

    return &_sfEnvSource0Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource0Alpha(void) const
{
    return &_sfEnvSource0Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource0Alpha(void)
{
    return this->editSFEnvSource0Alpha();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource1Alpha(void)
{
    editSField(EnvSource1AlphaFieldMask);

    return &_sfEnvSource1Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource1Alpha(void) const
{
    return &_sfEnvSource1Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource1Alpha(void)
{
    return this->editSFEnvSource1Alpha();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvSource2Alpha(void)
{
    editSField(EnvSource2AlphaFieldMask);

    return &_sfEnvSource2Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvSource2Alpha(void) const
{
    return &_sfEnvSource2Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvSource2Alpha(void)
{
    return this->editSFEnvSource2Alpha();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand0RGB(void)
{
    editSField(EnvOperand0RGBFieldMask);

    return &_sfEnvOperand0RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand0RGB(void) const
{
    return &_sfEnvOperand0RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand0RGB (void)
{
    return this->editSFEnvOperand0RGB ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand1RGB(void)
{
    editSField(EnvOperand1RGBFieldMask);

    return &_sfEnvOperand1RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand1RGB(void) const
{
    return &_sfEnvOperand1RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand1RGB (void)
{
    return this->editSFEnvOperand1RGB ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand2RGB(void)
{
    editSField(EnvOperand2RGBFieldMask);

    return &_sfEnvOperand2RGB;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand2RGB(void) const
{
    return &_sfEnvOperand2RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand2RGB (void)
{
    return this->editSFEnvOperand2RGB ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand0Alpha(void)
{
    editSField(EnvOperand0AlphaFieldMask);

    return &_sfEnvOperand0Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand0Alpha(void) const
{
    return &_sfEnvOperand0Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand0Alpha(void)
{
    return this->editSFEnvOperand0Alpha();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand1Alpha(void)
{
    editSField(EnvOperand1AlphaFieldMask);

    return &_sfEnvOperand1Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand1Alpha(void) const
{
    return &_sfEnvOperand1Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand1Alpha(void)
{
    return this->editSFEnvOperand1Alpha();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFEnvOperand2Alpha(void)
{
    editSField(EnvOperand2AlphaFieldMask);

    return &_sfEnvOperand2Alpha;
}

const SFGLenum *TextureEnvChunkBase::getSFEnvOperand2Alpha(void) const
{
    return &_sfEnvOperand2Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFEnvOperand2Alpha(void)
{
    return this->editSFEnvOperand2Alpha();
}
#endif

SFBool *TextureEnvChunkBase::editSFPointSprite(void)
{
    editSField(PointSpriteFieldMask);

    return &_sfPointSprite;
}

const SFBool *TextureEnvChunkBase::getSFPointSprite(void) const
{
    return &_sfPointSprite;
}

#ifdef OSG_1_COMPAT
SFBool              *TextureEnvChunkBase::getSFPointSprite    (void)
{
    return this->editSFPointSprite    ();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFShaderOperation(void)
{
    editSField(ShaderOperationFieldMask);

    return &_sfShaderOperation;
}

const SFGLenum *TextureEnvChunkBase::getSFShaderOperation(void) const
{
    return &_sfShaderOperation;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFShaderOperation(void)
{
    return this->editSFShaderOperation();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFShaderInput(void)
{
    editSField(ShaderInputFieldMask);

    return &_sfShaderInput;
}

const SFGLenum *TextureEnvChunkBase::getSFShaderInput(void) const
{
    return &_sfShaderInput;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFShaderInput    (void)
{
    return this->editSFShaderInput    ();
}
#endif

MFReal32 *TextureEnvChunkBase::editMFShaderOffsetMatrix(void)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    return &_mfShaderOffsetMatrix;
}

const MFReal32 *TextureEnvChunkBase::getMFShaderOffsetMatrix(void) const
{
    return &_mfShaderOffsetMatrix;
}

#ifdef OSG_1_COMPAT
MFReal32            *TextureEnvChunkBase::getMFShaderOffsetMatrix(void)
{
    return this->editMFShaderOffsetMatrix();
}
#endif

SFReal32 *TextureEnvChunkBase::editSFShaderOffsetScale(void)
{
    editSField(ShaderOffsetScaleFieldMask);

    return &_sfShaderOffsetScale;
}

const SFReal32 *TextureEnvChunkBase::getSFShaderOffsetScale(void) const
{
    return &_sfShaderOffsetScale;
}

#ifdef OSG_1_COMPAT
SFReal32            *TextureEnvChunkBase::getSFShaderOffsetScale(void)
{
    return this->editSFShaderOffsetScale();
}
#endif

SFReal32 *TextureEnvChunkBase::editSFShaderOffsetBias(void)
{
    editSField(ShaderOffsetBiasFieldMask);

    return &_sfShaderOffsetBias;
}

const SFReal32 *TextureEnvChunkBase::getSFShaderOffsetBias(void) const
{
    return &_sfShaderOffsetBias;
}

#ifdef OSG_1_COMPAT
SFReal32            *TextureEnvChunkBase::getSFShaderOffsetBias(void)
{
    return this->editSFShaderOffsetBias();
}
#endif

SFGLenum *TextureEnvChunkBase::editSFShaderRGBADotProduct(void)
{
    editSField(ShaderRGBADotProductFieldMask);

    return &_sfShaderRGBADotProduct;
}

const SFGLenum *TextureEnvChunkBase::getSFShaderRGBADotProduct(void) const
{
    return &_sfShaderRGBADotProduct;
}

#ifdef OSG_1_COMPAT
SFGLenum            *TextureEnvChunkBase::getSFShaderRGBADotProduct(void)
{
    return this->editSFShaderRGBADotProduct();
}
#endif

SFUInt8 *TextureEnvChunkBase::editSFShaderCullModes(void)
{
    editSField(ShaderCullModesFieldMask);

    return &_sfShaderCullModes;
}

const SFUInt8 *TextureEnvChunkBase::getSFShaderCullModes(void) const
{
    return &_sfShaderCullModes;
}

#ifdef OSG_1_COMPAT
SFUInt8             *TextureEnvChunkBase::getSFShaderCullModes(void)
{
    return this->editSFShaderCullModes();
}
#endif

SFVec3f *TextureEnvChunkBase::editSFShaderConstEye(void)
{
    editSField(ShaderConstEyeFieldMask);

    return &_sfShaderConstEye;
}

const SFVec3f *TextureEnvChunkBase::getSFShaderConstEye(void) const
{
    return &_sfShaderConstEye;
}

#ifdef OSG_1_COMPAT
SFVec3f             *TextureEnvChunkBase::getSFShaderConstEye (void)
{
    return this->editSFShaderConstEye ();
}
#endif

SFReal32 *TextureEnvChunkBase::editSFLodBias(void)
{
    editSField(LodBiasFieldMask);

    return &_sfLodBias;
}

const SFReal32 *TextureEnvChunkBase::getSFLodBias(void) const
{
    return &_sfLodBias;
}

#ifdef OSG_1_COMPAT
SFReal32            *TextureEnvChunkBase::getSFLodBias        (void)
{
    return this->editSFLodBias        ();
}
#endif



/*********************************** Non-ptr code ********************************/
void TextureEnvChunkBase::pushToShaderOffsetMatrix(const Real32& value)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);
    _mfShaderOffsetMatrix.push_back(value);
}

void TextureEnvChunkBase::insertIntoShaderOffsetMatrix(UInt32                uiIndex,
                                                   const Real32& value   )
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    MFReal32::iterator fieldIt = _mfShaderOffsetMatrix.begin();

    fieldIt += uiIndex;

    _mfShaderOffsetMatrix.insert(fieldIt, value);
}

void TextureEnvChunkBase::replaceInShaderOffsetMatrix(UInt32                uiIndex,
                                                       const Real32& value   )
{
    if(uiIndex >= _mfShaderOffsetMatrix.size())
        return;

    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    _mfShaderOffsetMatrix[uiIndex] = value;
}

void TextureEnvChunkBase::replaceInShaderOffsetMatrix(const Real32& pOldElem,
                                                        const Real32& pNewElem)
{
    Int32  elemIdx = _mfShaderOffsetMatrix.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

        MFReal32::iterator fieldIt = _mfShaderOffsetMatrix.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void TextureEnvChunkBase::removeFromShaderOffsetMatrix(UInt32 uiIndex)
{
    if(uiIndex < _mfShaderOffsetMatrix.size())
    {
        editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

        MFReal32::iterator fieldIt = _mfShaderOffsetMatrix.begin();

        fieldIt += uiIndex;
        _mfShaderOffsetMatrix.erase(fieldIt);
    }
}

void TextureEnvChunkBase::removeFromShaderOffsetMatrix(const Real32& value)
{
    Int32 iElemIdx = _mfShaderOffsetMatrix.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

        MFReal32::iterator fieldIt = _mfShaderOffsetMatrix.begin();

        fieldIt += iElemIdx;

        _mfShaderOffsetMatrix.erase(fieldIt);
    }
}

void TextureEnvChunkBase::clearShaderOffsetMatrix(void)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    _mfShaderOffsetMatrix.clear();
}


/*------------------------------ access -----------------------------------*/

UInt32 TextureEnvChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        returnValue += _sfEnvMode.getBinSize();
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        returnValue += _sfEnvColor.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        returnValue += _sfEnvCombineRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvCombineAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        returnValue += _sfEnvScaleRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvScaleAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        returnValue += _sfPointSprite.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        returnValue += _sfShaderOperation.getBinSize();
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        returnValue += _sfShaderInput.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        returnValue += _mfShaderOffsetMatrix.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetScale.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        returnValue += _sfShaderRGBADotProduct.getBinSize();
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        returnValue += _sfShaderCullModes.getBinSize();
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        returnValue += _sfShaderConstEye.getBinSize();
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        returnValue += _sfLodBias.getBinSize();
    }

    return returnValue;
}

void TextureEnvChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyToBin(pMem);
    }
}

void TextureEnvChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
TextureEnvChunkPtr TextureEnvChunkBase::createEmpty(void)
{
    TextureEnvChunkPtr returnValue;

    newPtr<TextureEnvChunk>(returnValue);

    return returnValue;
}

FieldContainerPtr TextureEnvChunkBase::shallowCopy(void) const
{
    TextureEnvChunkPtr returnValue;

    newPtr(returnValue, dynamic_cast<const TextureEnvChunk *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

TextureEnvChunkBase::TextureEnvChunkBase(void) :
    Inherited(),
    _sfEnvMode                (GLenum(GL_REPLACE)),
    _sfEnvColor               (Color4f(0,0,0,0)),
    _sfEnvCombineRGB          (GLenum(GL_MODULATE)),
    _sfEnvCombineAlpha        (GLenum(GL_MODULATE)),
    _sfEnvScaleRGB            (Real32(1.0f)),
    _sfEnvScaleAlpha          (Real32(1.0f)),
    _sfEnvSource0RGB          (GLenum(GL_TEXTURE)),
    _sfEnvSource1RGB          (GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2RGB          (GLenum(GL_CONSTANT_EXT)),
    _sfEnvSource0Alpha        (GLenum(GL_TEXTURE)),
    _sfEnvSource1Alpha        (GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2Alpha        (GLenum(GL_CONSTANT_EXT)),
    _sfEnvOperand0RGB         (GLenum(GL_SRC_COLOR)),
    _sfEnvOperand1RGB         (GLenum(GL_SRC_COLOR)),
    _sfEnvOperand2RGB         (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand0Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand1Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand2Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfPointSprite            (bool(GL_FALSE)),
    _sfShaderOperation        (GLenum(GL_NONE)),
    _sfShaderInput            (GLenum(GL_NONE)),
    _mfShaderOffsetMatrix     (),
    _sfShaderOffsetScale      (Real32(1.f)),
    _sfShaderOffsetBias       (Real32(0.f)),
    _sfShaderRGBADotProduct   (GLenum(GL_NONE)),
    _sfShaderCullModes        (UInt8(0)),
    _sfShaderConstEye         (),
    _sfLodBias                (Real32(0.f))
{
}

TextureEnvChunkBase::TextureEnvChunkBase(const TextureEnvChunkBase &source) :
    Inherited(source),
    _sfEnvMode                (source._sfEnvMode                ),
    _sfEnvColor               (source._sfEnvColor               ),
    _sfEnvCombineRGB          (source._sfEnvCombineRGB          ),
    _sfEnvCombineAlpha        (source._sfEnvCombineAlpha        ),
    _sfEnvScaleRGB            (source._sfEnvScaleRGB            ),
    _sfEnvScaleAlpha          (source._sfEnvScaleAlpha          ),
    _sfEnvSource0RGB          (source._sfEnvSource0RGB          ),
    _sfEnvSource1RGB          (source._sfEnvSource1RGB          ),
    _sfEnvSource2RGB          (source._sfEnvSource2RGB          ),
    _sfEnvSource0Alpha        (source._sfEnvSource0Alpha        ),
    _sfEnvSource1Alpha        (source._sfEnvSource1Alpha        ),
    _sfEnvSource2Alpha        (source._sfEnvSource2Alpha        ),
    _sfEnvOperand0RGB         (source._sfEnvOperand0RGB         ),
    _sfEnvOperand1RGB         (source._sfEnvOperand1RGB         ),
    _sfEnvOperand2RGB         (source._sfEnvOperand2RGB         ),
    _sfEnvOperand0Alpha       (source._sfEnvOperand0Alpha       ),
    _sfEnvOperand1Alpha       (source._sfEnvOperand1Alpha       ),
    _sfEnvOperand2Alpha       (source._sfEnvOperand2Alpha       ),
    _sfPointSprite            (source._sfPointSprite            ),
    _sfShaderOperation        (source._sfShaderOperation        ),
    _sfShaderInput            (source._sfShaderInput            ),
    _mfShaderOffsetMatrix     (source._mfShaderOffsetMatrix     ),
    _sfShaderOffsetScale      (source._sfShaderOffsetScale      ),
    _sfShaderOffsetBias       (source._sfShaderOffsetBias       ),
    _sfShaderRGBADotProduct   (source._sfShaderRGBADotProduct   ),
    _sfShaderCullModes        (source._sfShaderCullModes        ),
    _sfShaderConstEye         (source._sfShaderConstEye         ),
    _sfLodBias                (source._sfLodBias                )
{
}

/*-------------------------- destructors ----------------------------------*/

TextureEnvChunkBase::~TextureEnvChunkBase(void)
{
}


#ifdef OSG_MT_FIELDCONTAINERPTR
void TextureEnvChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<TextureEnvChunkBase *>(&oFrom),
                   whichField,
                   syncMode,
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void TextureEnvChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<TextureEnvChunkBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void TextureEnvChunkBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr TextureEnvChunkBase::createAspectCopy(void) const
{
    TextureEnvChunkPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const TextureEnvChunk *>(this));

    return returnValue;
}
#endif

void TextureEnvChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();
}


OSG_END_NAMESPACE

#include "OSGSFieldAdaptor.ins"
#include "OSGMFieldAdaptor.ins"

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureEnvChunkPtr>::_type("TextureEnvChunkPtr", "StateChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureEnvChunkPtr)

OSG_FIELD_DLLEXPORT_DEF2(SFieldAdaptor, TextureEnvChunkPtr, SFFieldContainerPtr);
OSG_FIELD_DLLEXPORT_DEF2(MFieldAdaptor, TextureEnvChunkPtr, MFFieldContainerPtr);

OSG_END_NAMESPACE

/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class ShaderStorageBufferObjStdLayoutChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"




#include "OSGShaderStorageBufferObjStdLayoutChunkBase.h"
#include "OSGShaderStorageBufferObjStdLayoutChunk.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::ShaderStorageBufferObjStdLayoutChunk
    See \ref PageSystemShaderStorageBufferObjStdLayoutChunk for a description.

    This chunk wraps the OpenGL shader storage buffer object extension (ARB_shader_storage_buffer_object). 
    Basically, it holds a raw memory buffer and a buffer object binding point. The raw memory 
    buffer is expected to be provided by the chunk user in either an OpenGL std140 or std430 compatible format. 
    Any shader, binding a shader storage block to the very same binding point, is expected to respect 
    the corresponding block layout.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var GLenum          ShaderStorageBufferObjStdLayoutChunkBase::_sfGLId
    The OpenGL object id for this shader storage buffer object.
*/

/*! \var GLenum          ShaderStorageBufferObjStdLayoutChunkBase::_sfUsage
    Specifies the expected usage pattern of the data store. The symbolic constant must be 
    GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, 
    GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, 
    GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
*/

/*! \var UInt8           ShaderStorageBufferObjStdLayoutChunkBase::_mfBuffer
    The shader storage buffer storage. The layout of this memory block is governed by the
    shader storage block layout according to OpenGL std140 or std430 specification.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<ShaderStorageBufferObjStdLayoutChunk *, nsOSG>::_type(
    "ShaderStorageBufferObjStdLayoutChunkPtr", 
    "ShaderStorageBufferObjBaseChunkPtr", 
    ShaderStorageBufferObjStdLayoutChunk::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(ShaderStorageBufferObjStdLayoutChunk *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           ShaderStorageBufferObjStdLayoutChunk *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           ShaderStorageBufferObjStdLayoutChunk *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void ShaderStorageBufferObjStdLayoutChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "GLId",
        "The OpenGL object id for this shader storage buffer object.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&ShaderStorageBufferObjStdLayoutChunk::editHandleGLId),
        static_cast<FieldGetMethodSig >(&ShaderStorageBufferObjStdLayoutChunk::getHandleGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "usage",
        "Specifies the expected usage pattern of the data store. The symbolic constant must be \n"
        "GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, \n"
        "GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, \n"
        "GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.\n",
        UsageFieldId, UsageFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShaderStorageBufferObjStdLayoutChunk::editHandleUsage),
        static_cast<FieldGetMethodSig >(&ShaderStorageBufferObjStdLayoutChunk::getHandleUsage));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "buffer",
        "The shader storage buffer storage. The layout of this memory block is governed by the\n"
        "shader storage block layout according to OpenGL std140 or std430 specification.\n",
        BufferFieldId, BufferFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShaderStorageBufferObjStdLayoutChunk::editHandleBuffer),
        static_cast<FieldGetMethodSig >(&ShaderStorageBufferObjStdLayoutChunk::getHandleBuffer));

    oType.addInitialDesc(pDesc);
}


ShaderStorageBufferObjStdLayoutChunkBase::TypeObject ShaderStorageBufferObjStdLayoutChunkBase::_type(
    ShaderStorageBufferObjStdLayoutChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&ShaderStorageBufferObjStdLayoutChunkBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&ShaderStorageBufferObjStdLayoutChunk::initMethod),
    reinterpret_cast<ExitContainerF>(&ShaderStorageBufferObjStdLayoutChunk::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&ShaderStorageBufferObjStdLayoutChunk::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"ShaderStorageBufferObjStdLayoutChunk\"\n"
    "    parent=\"ShaderStorageBufferObjBaseChunk\"\n"
    "    library=\"System\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    docGroupBase=\"GrpSystemState\"\n"
    "    >\n"
    "    See \\ref PageSystemShaderStorageBufferObjStdLayoutChunk for a description.\n"
    "\n"
    "    This chunk wraps the OpenGL shader storage buffer object extension (ARB_shader_storage_buffer_object). \n"
    "    Basically, it holds a raw memory buffer and a buffer object binding point. The raw memory \n"
    "    buffer is expected to be provided by the chunk user in either an OpenGL std140 or std430 compatible format. \n"
    "    Any shader, binding a shader storage block to the very same binding point, is expected to respect \n"
    "    the corresponding block layout.\n"
    "\n"
    "    <Field\n"
    "        name=\"GLId\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "            The OpenGL object id for this shader storage buffer object.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"usage\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"GL_STATIC_DRAW\"\n"
    "        potential_values=\"GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, GL_DYNAMIC_COPY\"\n"
    "\t>\n"
    "                Specifies the expected usage pattern of the data store. The symbolic constant must be \n"
    "                 GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, \n"
    "                 GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, \n"
    "                 GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.\n"
    "    </Field>\n"
    "<Field\n"
    "        name=\"buffer\"\n"
    "        type=\"UInt8\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tThe shader storage buffer storage. The layout of this memory block is governed by the\n"
    "                shader storage block layout according to OpenGL std140 or std430 specification.\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    "See \\ref PageSystemShaderStorageBufferObjStdLayoutChunk for a description.\n"
    "\n"
    "This chunk wraps the OpenGL shader storage buffer object extension (ARB_shader_storage_buffer_object). \n"
    "Basically, it holds a raw memory buffer and a buffer object binding point. The raw memory \n"
    "buffer is expected to be provided by the chunk user in either an OpenGL std140 or std430 compatible format. \n"
    "Any shader, binding a shader storage block to the very same binding point, is expected to respect \n"
    "the corresponding block layout.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ShaderStorageBufferObjStdLayoutChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &ShaderStorageBufferObjStdLayoutChunkBase::getType(void) const
{
    return _type;
}

UInt32 ShaderStorageBufferObjStdLayoutChunkBase::getContainerSize(void) const
{
    return sizeof(ShaderStorageBufferObjStdLayoutChunk);
}

/*------------------------- decorator get ------------------------------*/


SFGLenum *ShaderStorageBufferObjStdLayoutChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *ShaderStorageBufferObjStdLayoutChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}


SFGLenum *ShaderStorageBufferObjStdLayoutChunkBase::editSFUsage(void)
{
    editSField(UsageFieldMask);

    return &_sfUsage;
}

const SFGLenum *ShaderStorageBufferObjStdLayoutChunkBase::getSFUsage(void) const
{
    return &_sfUsage;
}


MFUInt8 *ShaderStorageBufferObjStdLayoutChunkBase::editMFBuffer(void)
{
    editMField(BufferFieldMask, _mfBuffer);

    return &_mfBuffer;
}

const MFUInt8 *ShaderStorageBufferObjStdLayoutChunkBase::getMFBuffer(void) const
{
    return &_mfBuffer;
}






/*------------------------------ access -----------------------------------*/

SizeT ShaderStorageBufferObjStdLayoutChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (UsageFieldMask & whichField))
    {
        returnValue += _sfUsage.getBinSize();
    }
    if(FieldBits::NoField != (BufferFieldMask & whichField))
    {
        returnValue += _mfBuffer.getBinSize();
    }

    return returnValue;
}

void ShaderStorageBufferObjStdLayoutChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UsageFieldMask & whichField))
    {
        _sfUsage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BufferFieldMask & whichField))
    {
        _mfBuffer.copyToBin(pMem);
    }
}

void ShaderStorageBufferObjStdLayoutChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        editSField(GLIdFieldMask);
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UsageFieldMask & whichField))
    {
        editSField(UsageFieldMask);
        _sfUsage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BufferFieldMask & whichField))
    {
        editMField(BufferFieldMask, _mfBuffer);
        _mfBuffer.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ShaderStorageBufferObjStdLayoutChunkTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::createLocal(BitVector bFlags)
{
    ShaderStorageBufferObjStdLayoutChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<ShaderStorageBufferObjStdLayoutChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
ShaderStorageBufferObjStdLayoutChunkTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::createDependent(BitVector bFlags)
{
    ShaderStorageBufferObjStdLayoutChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<ShaderStorageBufferObjStdLayoutChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ShaderStorageBufferObjStdLayoutChunkTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::create(void)
{
    ShaderStorageBufferObjStdLayoutChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<ShaderStorageBufferObjStdLayoutChunk>(tmpPtr);
    }

    return fc;
}

ShaderStorageBufferObjStdLayoutChunk *ShaderStorageBufferObjStdLayoutChunkBase::createEmptyLocal(BitVector bFlags)
{
    ShaderStorageBufferObjStdLayoutChunk *returnValue;

    newPtr<ShaderStorageBufferObjStdLayoutChunk>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
ShaderStorageBufferObjStdLayoutChunk *ShaderStorageBufferObjStdLayoutChunkBase::createEmpty(void)
{
    ShaderStorageBufferObjStdLayoutChunk *returnValue;

    newPtr<ShaderStorageBufferObjStdLayoutChunk>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ShaderStorageBufferObjStdLayoutChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ShaderStorageBufferObjStdLayoutChunk *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::shallowCopyDependent(
    BitVector bFlags) const
{
    ShaderStorageBufferObjStdLayoutChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ShaderStorageBufferObjStdLayoutChunk *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr ShaderStorageBufferObjStdLayoutChunkBase::shallowCopy(void) const
{
    ShaderStorageBufferObjStdLayoutChunk *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const ShaderStorageBufferObjStdLayoutChunk *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ShaderStorageBufferObjStdLayoutChunkBase::ShaderStorageBufferObjStdLayoutChunkBase(void) :
    Inherited(),
    _sfGLId                   (GLenum(0)),
    _sfUsage                  (GLenum(GL_STATIC_DRAW)),
    _mfBuffer                 ()
{
}

ShaderStorageBufferObjStdLayoutChunkBase::ShaderStorageBufferObjStdLayoutChunkBase(const ShaderStorageBufferObjStdLayoutChunkBase &source) :
    Inherited(source),
    _sfGLId                   (source._sfGLId                   ),
    _sfUsage                  (source._sfUsage                  ),
    _mfBuffer                 (source._mfBuffer                 )
{
}


/*-------------------------- destructors ----------------------------------*/

ShaderStorageBufferObjStdLayoutChunkBase::~ShaderStorageBufferObjStdLayoutChunkBase(void)
{
}


GetFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::getHandleGLId            (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             const_cast<ShaderStorageBufferObjStdLayoutChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::editHandleGLId           (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             this));


    editSField(GLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::getHandleUsage           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfUsage,
             this->getType().getFieldDesc(UsageFieldId),
             const_cast<ShaderStorageBufferObjStdLayoutChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::editHandleUsage          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfUsage,
             this->getType().getFieldDesc(UsageFieldId),
             this));


    editSField(UsageFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::getHandleBuffer          (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfBuffer,
             this->getType().getFieldDesc(BufferFieldId),
             const_cast<ShaderStorageBufferObjStdLayoutChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShaderStorageBufferObjStdLayoutChunkBase::editHandleBuffer         (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfBuffer,
             this->getType().getFieldDesc(BufferFieldId),
             this));


    editMField(BufferFieldMask, _mfBuffer);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ShaderStorageBufferObjStdLayoutChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    ShaderStorageBufferObjStdLayoutChunk *pThis = static_cast<ShaderStorageBufferObjStdLayoutChunk *>(this);

    pThis->execSync(static_cast<ShaderStorageBufferObjStdLayoutChunk *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ShaderStorageBufferObjStdLayoutChunkBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    ShaderStorageBufferObjStdLayoutChunk *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const ShaderStorageBufferObjStdLayoutChunk *>(pRefAspect),
                  dynamic_cast<const ShaderStorageBufferObjStdLayoutChunk *>(this));

    return returnValue;
}
#endif

void ShaderStorageBufferObjStdLayoutChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfBuffer.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

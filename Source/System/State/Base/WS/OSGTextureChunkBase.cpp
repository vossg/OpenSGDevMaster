/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTURECHUNKINST

#include <stdlib.h>
#include <stdio.h>

#include <OSGConfig.h>


#include <OSGGL.h>   // InternalFormat default header
#include <OSGGL.h>   // ExternalFormat default header
#include <OSGGL.h>   // MinFilter default header
#include <OSGGL.h>   // MagFilter default header
#include <OSGGL.h>   // WrapS default header
#include <OSGGL.h>   // WrapT default header
#include <OSGGL.h>   // WrapR default header
#include <OSGGL.h>   // EnvMode default header
#include <OSGGL.h>   // EnvCombineRGB default header
#include <OSGGL.h>   // EnvCombineAlpha default header
#include <OSGGL.h>   // EnvSource0RGB default header
#include <OSGGLEXT.h>   // EnvSource1RGB default header
#include <OSGGLEXT.h>   // EnvSource2RGB default header
#include <OSGGL.h>   // EnvSource0Alpha default header
#include <OSGGLEXT.h>   // EnvSource1Alpha default header
#include <OSGGLEXT.h>   // EnvSource2Alpha default header
#include <OSGGL.h>   // EnvOperand0RGB default header
#include <OSGGL.h>   // EnvOperand1RGB default header
#include <OSGGL.h>   // EnvOperand2RGB default header
#include <OSGGL.h>   // EnvOperand0Alpha default header
#include <OSGGL.h>   // EnvOperand1Alpha default header
#include <OSGGL.h>   // EnvOperand2Alpha default header
#include <OSGGL.h>   // PointSprite default header
#include <OSGGL.h>   // ShaderOperation default header
#include <OSGGL.h>   // ShaderInput default header
#include <OSGGL.h>   // ShaderRGBADotProduct default header
#include <OSGGL.h>   // Target default header
#include <OSGGL.h>   // CompareMode default header
#include <OSGGL.h>   // CompareFunc default header
#include <OSGGL.h>   // DepthMode default header

#include <OSGImage.h> // Image Class

#include "OSGTextureChunkBase.h"
#include "OSGTextureChunk.h"

OSG_USING_NAMESPACE

// Field descriptions

/*! \var ImagePtr TextureChunkBase::_sfImage
    
*/
/*! \var GLenum TextureChunkBase::_sfInternalFormat
    	The internal texture format.

*/
/*! \var GLenum TextureChunkBase::_sfExternalFormat
    	    The external texture format - overwrites 
        external format of image when set to a value not equal to 
        GL_NONE (which is the default).

*/
/*! \var bool TextureChunkBase::_sfScale
            Specifies whether the image should be scaled to the next power of two,
        thus filling the whole texture coordinate range, or if it should be put
        in the lower left corner, leaving the rest of the texture undefined.
        This is mainly used for rapidly changing non power of two textures, to
        get around the scaling overhead.

*/
/*! \var UInt32 TextureChunkBase::_sfFrame
            Select the frame of the image to be used. See OSG::Image about details
        concerning multi-frame images.
        \hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap
        creation is slow right now. \endhint

*/
/*! \var GLenum TextureChunkBase::_sfMinFilter
            The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.

*/
/*! \var GLenum TextureChunkBase::_sfMagFilter
            The magnification filter, default GL_LINEAR.

*/
/*! \var GLenum TextureChunkBase::_sfWrapS
            Texture coordinate S wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureChunkBase::_sfWrapT
            Texture coordinate T wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureChunkBase::_sfWrapR
            Texture coordinate R wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureChunkBase::_sfEnvMode
            Texture environment mode, default GL_REPLACE

*/
/*! \var Color4f TextureChunkBase::_sfEnvColor
            Texture environment color default transparent black.

*/
/*! \var GLenum TextureChunkBase::_sfEnvCombineRGB
            Texture environment rgb combine mode, default GL_MODULATE

*/
/*! \var GLenum TextureChunkBase::_sfEnvCombineAlpha
            Texture environment alpha combine mode, default GL_MODULATE

*/
/*! \var Real32 TextureChunkBase::_sfEnvScaleRGB
            Texture environment combine rgb scale factor, default 1.f

*/
/*! \var Real32 TextureChunkBase::_sfEnvScaleAlpha
            Texture environment combine alpha scale factor, default 1.f

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource0RGB
            Texture environment combine source 0 rgb, default GL_TEXTURE

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource1RGB
            Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource2RGB
            Texture environment combine source 2 rgb, default GL_CONSTANT_EXT

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource0Alpha
            Texture environment combine source 0 alpha, default GL_TEXTURE

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource1Alpha
            Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT

*/
/*! \var GLenum TextureChunkBase::_sfEnvSource2Alpha
            Texture environment combine source 2 alpha, default GL_CONSTANT_EXT

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand0RGB
            Texture environment combine operand 0 rgb, default GL_SRC_COLOR

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand1RGB
            Texture environment combine operand 1 rgb, default GL_SRC_COLOR

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand2RGB
            Texture environment combine operand 2 rgb, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand0Alpha
            Texture environment combine operand 0 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand1Alpha
            Texture environment combine operand 1 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureChunkBase::_sfEnvOperand2Alpha
            Texture environment combine operand 2 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureChunkBase::_sfGLId
            The OpenGL texture id for this texture.

*/
/*! \var Int32 TextureChunkBase::_sfIgnoreGLForAspect
    	    Don't do any GL calls for aspect of given id.

*/
/*! \var bool TextureChunkBase::_sfPointSprite
            Flag to use this texture for Point Sprites.

*/
/*! \var Real32 TextureChunkBase::_sfPriority
            Priority of this texture, between 0 and 1, the default is 0.

*/
/*! \var GLenum TextureChunkBase::_sfShaderOperation
            Shader operation of this texture unit, default GL_NONE. If unit 0 uses
        GL_NONE, shading is switched off.

*/
/*! \var GLenum TextureChunkBase::_sfShaderInput
            Input texture unit for this shader's operation.

*/
/*! \var Real32 TextureChunkBase::_mfShaderOffsetMatrix
            The 2x2 transformation matrix for offset textures.

*/
/*! \var Real32 TextureChunkBase::_sfShaderOffsetScale
            The scaling factor for scaled offset textures.

*/
/*! \var Real32 TextureChunkBase::_sfShaderOffsetBias
            The bias factor for scaled offset textures.

*/
/*! \var GLenum TextureChunkBase::_sfShaderRGBADotProduct
            The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.

*/
/*! \var UInt8 TextureChunkBase::_sfShaderCullModes
            The CULL_MODES_NV value, coded into a single byte. The first 4 bits of
        the byte are used to indicate the wnated cull modes, a value of 0 
        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for 
        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 
        (mask 8) for Q.

*/
/*! \var Vec3f TextureChunkBase::_sfShaderConstEye
            The CONST_EYE_NV value, i.e. the constant eye position used by the 
        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.

*/
/*! \var Real32 TextureChunkBase::_sfLodBias
            Bias of LOD calculation for texture access.
    

*/
/*! \var GLenum TextureChunkBase::_sfTarget
            Texture target. Overwrite automatically determined texture target
        based on the parameters of the assigned image if set to anything 
        else than GL_NONE. Used for nVidia's rectangle textures. Be careful
        when using it!
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyLeft
            Left coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMinX
            Minimum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMaxX
            Maximum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMinY
            Minimum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMaxY
            Maximum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMinZ
            Minimum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureChunkBase::_sfDirtyMaxZ
            Maximum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Real32 TextureChunkBase::_sfAnisotropy
            Anisotropic filtering the default 1.0f means isotropic filtering.
        

*/
/*! \var Color4f TextureChunkBase::_sfBorderColor
    	Texture border color

*/
/*! \var GLenum TextureChunkBase::_sfCompareMode
    
*/
/*! \var GLenum TextureChunkBase::_sfCompareFunc
    
*/
/*! \var GLenum TextureChunkBase::_sfDepthMode
    
*/

void TextureChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL; 


    pDesc = new SFImagePtr::Description(
        SFImagePtr::getClassType(), 
        "image", 
        ImageFieldId, ImageFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&TextureChunkBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFImage));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFInternalFormatF)(void) const;

    GetSFInternalFormatF GetSFInternalFormat = &TextureChunkBase::getSFInternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "internalFormat", 
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFInternalFormat),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFInternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFInternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFExternalFormatF)(void) const;

    GetSFExternalFormatF GetSFExternalFormat = &TextureChunkBase::getSFExternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "externalFormat", 
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFExternalFormat),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFExternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFExternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(TextureChunkBase::*GetSFScaleF)(void) const;

    GetSFScaleF GetSFScale = &TextureChunkBase::getSFScale;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "scale", 
        ScaleFieldId, ScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFScale),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFScale));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(TextureChunkBase::*GetSFFrameF)(void) const;

    GetSFFrameF GetSFFrame = &TextureChunkBase::getSFFrame;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "frame", 
        FrameFieldId, FrameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFFrame),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrame));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFFrame));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFMinFilterF)(void) const;

    GetSFMinFilterF GetSFMinFilter = &TextureChunkBase::getSFMinFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "minFilter", 
        MinFilterFieldId, MinFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFMinFilter),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMinFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFMinFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFMagFilterF)(void) const;

    GetSFMagFilterF GetSFMagFilter = &TextureChunkBase::getSFMagFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "magFilter", 
        MagFilterFieldId, MagFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFMagFilter),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMagFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFMagFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFWrapSF)(void) const;

    GetSFWrapSF GetSFWrapS = &TextureChunkBase::getSFWrapS;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapS", 
        WrapSFieldId, WrapSFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFWrapS),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapS));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFWrapS));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFWrapTF)(void) const;

    GetSFWrapTF GetSFWrapT = &TextureChunkBase::getSFWrapT;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapT", 
        WrapTFieldId, WrapTFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFWrapT),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapT));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFWrapT));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFWrapRF)(void) const;

    GetSFWrapRF GetSFWrapR = &TextureChunkBase::getSFWrapR;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapR", 
        WrapRFieldId, WrapRFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFWrapR),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapR));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFWrapR));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvModeF)(void) const;

    GetSFEnvModeF GetSFEnvMode = &TextureChunkBase::getSFEnvMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envMode", 
        EnvModeFieldId, EnvModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFColor4f *(TextureChunkBase::*GetSFEnvColorF)(void) const;

    GetSFEnvColorF GetSFEnvColor = &TextureChunkBase::getSFEnvColor;
#endif

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(), 
        "envColor", 
        EnvColorFieldId, EnvColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvCombineRGBF)(void) const;

    GetSFEnvCombineRGBF GetSFEnvCombineRGB = &TextureChunkBase::getSFEnvCombineRGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envCombineRGB", 
        EnvCombineRGBFieldId, EnvCombineRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvCombineRGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvCombineRGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvCombineRGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvCombineAlphaF)(void) const;

    GetSFEnvCombineAlphaF GetSFEnvCombineAlpha = &TextureChunkBase::getSFEnvCombineAlpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envCombineAlpha", 
        EnvCombineAlphaFieldId, EnvCombineAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvCombineAlpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvCombineAlpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvCombineAlpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFEnvScaleRGBF)(void) const;

    GetSFEnvScaleRGBF GetSFEnvScaleRGB = &TextureChunkBase::getSFEnvScaleRGB;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "envScaleRGB", 
        EnvScaleRGBFieldId, EnvScaleRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvScaleRGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvScaleRGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvScaleRGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFEnvScaleAlphaF)(void) const;

    GetSFEnvScaleAlphaF GetSFEnvScaleAlpha = &TextureChunkBase::getSFEnvScaleAlpha;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "envScaleAlpha", 
        EnvScaleAlphaFieldId, EnvScaleAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvScaleAlpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvScaleAlpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvScaleAlpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource0RGBF)(void) const;

    GetSFEnvSource0RGBF GetSFEnvSource0RGB = &TextureChunkBase::getSFEnvSource0RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource0RGB", 
        EnvSource0RGBFieldId, EnvSource0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource0RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource0RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource0RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource1RGBF)(void) const;

    GetSFEnvSource1RGBF GetSFEnvSource1RGB = &TextureChunkBase::getSFEnvSource1RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource1RGB", 
        EnvSource1RGBFieldId, EnvSource1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource1RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource1RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource1RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource2RGBF)(void) const;

    GetSFEnvSource2RGBF GetSFEnvSource2RGB = &TextureChunkBase::getSFEnvSource2RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource2RGB", 
        EnvSource2RGBFieldId, EnvSource2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource2RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource2RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource2RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource0AlphaF)(void) const;

    GetSFEnvSource0AlphaF GetSFEnvSource0Alpha = &TextureChunkBase::getSFEnvSource0Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource0Alpha", 
        EnvSource0AlphaFieldId, EnvSource0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource0Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource0Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource0Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource1AlphaF)(void) const;

    GetSFEnvSource1AlphaF GetSFEnvSource1Alpha = &TextureChunkBase::getSFEnvSource1Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource1Alpha", 
        EnvSource1AlphaFieldId, EnvSource1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource1Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource1Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource1Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvSource2AlphaF)(void) const;

    GetSFEnvSource2AlphaF GetSFEnvSource2Alpha = &TextureChunkBase::getSFEnvSource2Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource2Alpha", 
        EnvSource2AlphaFieldId, EnvSource2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvSource2Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvSource2Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvSource2Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand0RGBF)(void) const;

    GetSFEnvOperand0RGBF GetSFEnvOperand0RGB = &TextureChunkBase::getSFEnvOperand0RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand0RGB", 
        EnvOperand0RGBFieldId, EnvOperand0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand0RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand0RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand0RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand1RGBF)(void) const;

    GetSFEnvOperand1RGBF GetSFEnvOperand1RGB = &TextureChunkBase::getSFEnvOperand1RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand1RGB", 
        EnvOperand1RGBFieldId, EnvOperand1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand1RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand1RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand1RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand2RGBF)(void) const;

    GetSFEnvOperand2RGBF GetSFEnvOperand2RGB = &TextureChunkBase::getSFEnvOperand2RGB;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand2RGB", 
        EnvOperand2RGBFieldId, EnvOperand2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand2RGB),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand2RGB));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand2RGB));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand0AlphaF)(void) const;

    GetSFEnvOperand0AlphaF GetSFEnvOperand0Alpha = &TextureChunkBase::getSFEnvOperand0Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand0Alpha", 
        EnvOperand0AlphaFieldId, EnvOperand0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand0Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand0Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand0Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand1AlphaF)(void) const;

    GetSFEnvOperand1AlphaF GetSFEnvOperand1Alpha = &TextureChunkBase::getSFEnvOperand1Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand1Alpha", 
        EnvOperand1AlphaFieldId, EnvOperand1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand1Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand1Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand1Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFEnvOperand2AlphaF)(void) const;

    GetSFEnvOperand2AlphaF GetSFEnvOperand2Alpha = &TextureChunkBase::getSFEnvOperand2Alpha;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand2Alpha", 
        EnvOperand2AlphaFieldId, EnvOperand2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFEnvOperand2Alpha),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFEnvOperand2Alpha));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFEnvOperand2Alpha));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFGLIdF)(void) const;

    GetSFGLIdF GetSFGLId = &TextureChunkBase::getSFGLId;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "GLId", 
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFGLId),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFGLId));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFGLId));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFIgnoreGLForAspectF)(void) const;

    GetSFIgnoreGLForAspectF GetSFIgnoreGLForAspect = &TextureChunkBase::getSFIgnoreGLForAspect;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "IgnoreGLForAspect", 
        IgnoreGLForAspectFieldId, IgnoreGLForAspectFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFIgnoreGLForAspect),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFIgnoreGLForAspect));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFIgnoreGLForAspect));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(TextureChunkBase::*GetSFPointSpriteF)(void) const;

    GetSFPointSpriteF GetSFPointSprite = &TextureChunkBase::getSFPointSprite;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "pointSprite", 
        PointSpriteFieldId, PointSpriteFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFPointSprite),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPointSprite));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFPointSprite));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFPriorityF)(void) const;

    GetSFPriorityF GetSFPriority = &TextureChunkBase::getSFPriority;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "priority", 
        PriorityFieldId, PriorityFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFPriority),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPriority));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFPriority));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFShaderOperationF)(void) const;

    GetSFShaderOperationF GetSFShaderOperation = &TextureChunkBase::getSFShaderOperation;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderOperation", 
        ShaderOperationFieldId, ShaderOperationFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderOperation),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOperation));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderOperation));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFShaderInputF)(void) const;

    GetSFShaderInputF GetSFShaderInput = &TextureChunkBase::getSFShaderInput;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderInput", 
        ShaderInputFieldId, ShaderInputFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderInput),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderInput));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderInput));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFReal32 *(TextureChunkBase::*GetMFShaderOffsetMatrixF)(void) const;

    GetMFShaderOffsetMatrixF GetMFShaderOffsetMatrix = &TextureChunkBase::getMFShaderOffsetMatrix;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(), 
        "shaderOffsetMatrix", 
        ShaderOffsetMatrixFieldId, ShaderOffsetMatrixFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editMFShaderOffsetMatrix),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFShaderOffsetMatrix));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getMFShaderOffsetMatrix));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFShaderOffsetScaleF)(void) const;

    GetSFShaderOffsetScaleF GetSFShaderOffsetScale = &TextureChunkBase::getSFShaderOffsetScale;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "shaderOffsetScale", 
        ShaderOffsetScaleFieldId, ShaderOffsetScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderOffsetScale),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOffsetScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderOffsetScale));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFShaderOffsetBiasF)(void) const;

    GetSFShaderOffsetBiasF GetSFShaderOffsetBias = &TextureChunkBase::getSFShaderOffsetBias;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "shaderOffsetBias", 
        ShaderOffsetBiasFieldId, ShaderOffsetBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderOffsetBias),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderOffsetBias));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderOffsetBias));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFShaderRGBADotProductF)(void) const;

    GetSFShaderRGBADotProductF GetSFShaderRGBADotProduct = &TextureChunkBase::getSFShaderRGBADotProduct;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderRGBADotProduct", 
        ShaderRGBADotProductFieldId, ShaderRGBADotProductFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderRGBADotProduct),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderRGBADotProduct));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderRGBADotProduct));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt8 *(TextureChunkBase::*GetSFShaderCullModesF)(void) const;

    GetSFShaderCullModesF GetSFShaderCullModes = &TextureChunkBase::getSFShaderCullModes;
#endif

    pDesc = new SFUInt8::Description(
        SFUInt8::getClassType(), 
        "shaderCullModes", 
        ShaderCullModesFieldId, ShaderCullModesFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderCullModes),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderCullModes));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderCullModes));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFVec3f *(TextureChunkBase::*GetSFShaderConstEyeF)(void) const;

    GetSFShaderConstEyeF GetSFShaderConstEye = &TextureChunkBase::getSFShaderConstEye;
#endif

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(), 
        "shaderConstEye", 
        ShaderConstEyeFieldId, ShaderConstEyeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFShaderConstEye),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFShaderConstEye));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFShaderConstEye));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFLodBiasF)(void) const;

    GetSFLodBiasF GetSFLodBias = &TextureChunkBase::getSFLodBias;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "lodBias", 
        LodBiasFieldId, LodBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFLodBias),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFLodBias));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFLodBias));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFTargetF)(void) const;

    GetSFTargetF GetSFTarget = &TextureChunkBase::getSFTarget;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "target", 
        TargetFieldId, TargetFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFTarget),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFTarget));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFTarget));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyLeftF)(void) const;

    GetSFDirtyLeftF GetSFDirtyLeft = &TextureChunkBase::getSFDirtyLeft;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyLeft", 
        DirtyLeftFieldId, DirtyLeftFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyLeft),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyLeft));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyLeft));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMinXF)(void) const;

    GetSFDirtyMinXF GetSFDirtyMinX = &TextureChunkBase::getSFDirtyMinX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinX", 
        DirtyMinXFieldId, DirtyMinXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMinX),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMinX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMaxXF)(void) const;

    GetSFDirtyMaxXF GetSFDirtyMaxX = &TextureChunkBase::getSFDirtyMaxX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxX", 
        DirtyMaxXFieldId, DirtyMaxXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMaxX),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMaxX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMinYF)(void) const;

    GetSFDirtyMinYF GetSFDirtyMinY = &TextureChunkBase::getSFDirtyMinY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinY", 
        DirtyMinYFieldId, DirtyMinYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMinY),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMinY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMaxYF)(void) const;

    GetSFDirtyMaxYF GetSFDirtyMaxY = &TextureChunkBase::getSFDirtyMaxY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxY", 
        DirtyMaxYFieldId, DirtyMaxYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMaxY),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMaxY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMinZF)(void) const;

    GetSFDirtyMinZF GetSFDirtyMinZ = &TextureChunkBase::getSFDirtyMinZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinZ", 
        DirtyMinZFieldId, DirtyMinZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMinZ),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMinZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureChunkBase::*GetSFDirtyMaxZF)(void) const;

    GetSFDirtyMaxZF GetSFDirtyMaxZ = &TextureChunkBase::getSFDirtyMaxZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxZ", 
        DirtyMaxZFieldId, DirtyMaxZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDirtyMaxZ),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDirtyMaxZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureChunkBase::*GetSFAnisotropyF)(void) const;

    GetSFAnisotropyF GetSFAnisotropy = &TextureChunkBase::getSFAnisotropy;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "anisotropy", 
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFAnisotropy),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFAnisotropy));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFAnisotropy));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFColor4f *(TextureChunkBase::*GetSFBorderColorF)(void) const;

    GetSFBorderColorF GetSFBorderColor = &TextureChunkBase::getSFBorderColor;
#endif

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(), 
        "borderColor", 
        BorderColorFieldId, BorderColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFBorderColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBorderColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFBorderColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFCompareModeF)(void) const;

    GetSFCompareModeF GetSFCompareMode = &TextureChunkBase::getSFCompareMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareMode", 
        CompareModeFieldId, CompareModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFCompareMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFCompareMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFCompareFuncF)(void) const;

    GetSFCompareFuncF GetSFCompareFunc = &TextureChunkBase::getSFCompareFunc;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareFunc", 
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFCompareFunc),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareFunc));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFCompareFunc));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureChunkBase::*GetSFDepthModeF)(void) const;

    GetSFDepthModeF GetSFDepthMode = &TextureChunkBase::getSFDepthMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "depthMode", 
        DepthModeFieldId, DepthModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureChunkBase::editSFDepthMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDepthMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureChunkBase::getSFDepthMode));
#endif

    oType.addInitialDesc(pDesc);
}


TextureChunkBase::TypeObject TextureChunkBase::_type(true,
    TextureChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &TextureChunkBase::createEmpty,
    TextureChunk::initMethod,
    (InitalInsertDescFunc) &TextureChunkBase::classDescInserter,
    false);

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureChunkBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &TextureChunkBase::getType(void) const 
{
    return _type;
} 

UInt32 TextureChunkBase::getContainerSize(void) const 
{ 
    return sizeof(TextureChunk); 
}

/*------------------------- decorator get ------------------------------*/


//! Get the TextureChunk::_sfImage field.
const SFImagePtr *TextureChunkBase::getSFImage(void) const
{
    return &_sfImage;
}

SFGLenum *TextureChunkBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureChunkBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFInternalFormat(void)
{
    return this->editSFInternalFormat();
}
#endif

SFGLenum *TextureChunkBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureChunkBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFExternalFormat(void)
{
    return this->editSFExternalFormat();
}
#endif

SFBool *TextureChunkBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFBool *TextureChunkBase::getSFScale(void) const
{
    return &_sfScale;
}

#ifdef OSG_1_COMPAT
SFBool *TextureChunkBase::getSFScale(void)
{
    return this->editSFScale();
}
#endif

SFUInt32 *TextureChunkBase::editSFFrame(void)
{
    editSField(FrameFieldMask);

    return &_sfFrame;
}

const SFUInt32 *TextureChunkBase::getSFFrame(void) const
{
    return &_sfFrame;
}

#ifdef OSG_1_COMPAT
SFUInt32 *TextureChunkBase::getSFFrame(void)
{
    return this->editSFFrame();
}
#endif

SFGLenum *TextureChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFMinFilter(void)
{
    return this->editSFMinFilter();
}
#endif

SFGLenum *TextureChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFMagFilter(void)
{
    return this->editSFMagFilter();
}
#endif

SFGLenum *TextureChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFWrapS(void)
{
    return this->editSFWrapS();
}
#endif

SFGLenum *TextureChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFWrapT(void)
{
    return this->editSFWrapT();
}
#endif

SFGLenum *TextureChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFWrapR(void)
{
    return this->editSFWrapR();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvMode(void)
{
    editSField(EnvModeFieldMask);

    return &_sfEnvMode;
}

const SFGLenum *TextureChunkBase::getSFEnvMode(void) const
{
    return &_sfEnvMode;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvMode(void)
{
    return this->editSFEnvMode();
}
#endif

SFColor4f *TextureChunkBase::editSFEnvColor(void)
{
    editSField(EnvColorFieldMask);

    return &_sfEnvColor;
}

const SFColor4f *TextureChunkBase::getSFEnvColor(void) const
{
    return &_sfEnvColor;
}

#ifdef OSG_1_COMPAT
SFColor4f *TextureChunkBase::getSFEnvColor(void)
{
    return this->editSFEnvColor();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvCombineRGB(void)
{
    editSField(EnvCombineRGBFieldMask);

    return &_sfEnvCombineRGB;
}

const SFGLenum *TextureChunkBase::getSFEnvCombineRGB(void) const
{
    return &_sfEnvCombineRGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvCombineRGB(void)
{
    return this->editSFEnvCombineRGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvCombineAlpha(void)
{
    editSField(EnvCombineAlphaFieldMask);

    return &_sfEnvCombineAlpha;
}

const SFGLenum *TextureChunkBase::getSFEnvCombineAlpha(void) const
{
    return &_sfEnvCombineAlpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvCombineAlpha(void)
{
    return this->editSFEnvCombineAlpha();
}
#endif

SFReal32 *TextureChunkBase::editSFEnvScaleRGB(void)
{
    editSField(EnvScaleRGBFieldMask);

    return &_sfEnvScaleRGB;
}

const SFReal32 *TextureChunkBase::getSFEnvScaleRGB(void) const
{
    return &_sfEnvScaleRGB;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFEnvScaleRGB(void)
{
    return this->editSFEnvScaleRGB();
}
#endif

SFReal32 *TextureChunkBase::editSFEnvScaleAlpha(void)
{
    editSField(EnvScaleAlphaFieldMask);

    return &_sfEnvScaleAlpha;
}

const SFReal32 *TextureChunkBase::getSFEnvScaleAlpha(void) const
{
    return &_sfEnvScaleAlpha;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFEnvScaleAlpha(void)
{
    return this->editSFEnvScaleAlpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource0RGB(void)
{
    editSField(EnvSource0RGBFieldMask);

    return &_sfEnvSource0RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvSource0RGB(void) const
{
    return &_sfEnvSource0RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource0RGB(void)
{
    return this->editSFEnvSource0RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource1RGB(void)
{
    editSField(EnvSource1RGBFieldMask);

    return &_sfEnvSource1RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvSource1RGB(void) const
{
    return &_sfEnvSource1RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource1RGB(void)
{
    return this->editSFEnvSource1RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource2RGB(void)
{
    editSField(EnvSource2RGBFieldMask);

    return &_sfEnvSource2RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvSource2RGB(void) const
{
    return &_sfEnvSource2RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource2RGB(void)
{
    return this->editSFEnvSource2RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource0Alpha(void)
{
    editSField(EnvSource0AlphaFieldMask);

    return &_sfEnvSource0Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvSource0Alpha(void) const
{
    return &_sfEnvSource0Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource0Alpha(void)
{
    return this->editSFEnvSource0Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource1Alpha(void)
{
    editSField(EnvSource1AlphaFieldMask);

    return &_sfEnvSource1Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvSource1Alpha(void) const
{
    return &_sfEnvSource1Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource1Alpha(void)
{
    return this->editSFEnvSource1Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvSource2Alpha(void)
{
    editSField(EnvSource2AlphaFieldMask);

    return &_sfEnvSource2Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvSource2Alpha(void) const
{
    return &_sfEnvSource2Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvSource2Alpha(void)
{
    return this->editSFEnvSource2Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand0RGB(void)
{
    editSField(EnvOperand0RGBFieldMask);

    return &_sfEnvOperand0RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand0RGB(void) const
{
    return &_sfEnvOperand0RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand0RGB(void)
{
    return this->editSFEnvOperand0RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand1RGB(void)
{
    editSField(EnvOperand1RGBFieldMask);

    return &_sfEnvOperand1RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand1RGB(void) const
{
    return &_sfEnvOperand1RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand1RGB(void)
{
    return this->editSFEnvOperand1RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand2RGB(void)
{
    editSField(EnvOperand2RGBFieldMask);

    return &_sfEnvOperand2RGB;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand2RGB(void) const
{
    return &_sfEnvOperand2RGB;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand2RGB(void)
{
    return this->editSFEnvOperand2RGB();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand0Alpha(void)
{
    editSField(EnvOperand0AlphaFieldMask);

    return &_sfEnvOperand0Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand0Alpha(void) const
{
    return &_sfEnvOperand0Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand0Alpha(void)
{
    return this->editSFEnvOperand0Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand1Alpha(void)
{
    editSField(EnvOperand1AlphaFieldMask);

    return &_sfEnvOperand1Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand1Alpha(void) const
{
    return &_sfEnvOperand1Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand1Alpha(void)
{
    return this->editSFEnvOperand1Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFEnvOperand2Alpha(void)
{
    editSField(EnvOperand2AlphaFieldMask);

    return &_sfEnvOperand2Alpha;
}

const SFGLenum *TextureChunkBase::getSFEnvOperand2Alpha(void) const
{
    return &_sfEnvOperand2Alpha;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFEnvOperand2Alpha(void)
{
    return this->editSFEnvOperand2Alpha();
}
#endif

SFGLenum *TextureChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *TextureChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFGLId(void)
{
    return this->editSFGLId();
}
#endif

SFInt32 *TextureChunkBase::editSFIgnoreGLForAspect(void)
{
    editSField(IgnoreGLForAspectFieldMask);

    return &_sfIgnoreGLForAspect;
}

const SFInt32 *TextureChunkBase::getSFIgnoreGLForAspect(void) const
{
    return &_sfIgnoreGLForAspect;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFIgnoreGLForAspect(void)
{
    return this->editSFIgnoreGLForAspect();
}
#endif

SFBool *TextureChunkBase::editSFPointSprite(void)
{
    editSField(PointSpriteFieldMask);

    return &_sfPointSprite;
}

const SFBool *TextureChunkBase::getSFPointSprite(void) const
{
    return &_sfPointSprite;
}

#ifdef OSG_1_COMPAT
SFBool *TextureChunkBase::getSFPointSprite(void)
{
    return this->editSFPointSprite();
}
#endif

SFReal32 *TextureChunkBase::editSFPriority(void)
{
    editSField(PriorityFieldMask);

    return &_sfPriority;
}

const SFReal32 *TextureChunkBase::getSFPriority(void) const
{
    return &_sfPriority;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFPriority(void)
{
    return this->editSFPriority();
}
#endif

SFGLenum *TextureChunkBase::editSFShaderOperation(void)
{
    editSField(ShaderOperationFieldMask);

    return &_sfShaderOperation;
}

const SFGLenum *TextureChunkBase::getSFShaderOperation(void) const
{
    return &_sfShaderOperation;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFShaderOperation(void)
{
    return this->editSFShaderOperation();
}
#endif

SFGLenum *TextureChunkBase::editSFShaderInput(void)
{
    editSField(ShaderInputFieldMask);

    return &_sfShaderInput;
}

const SFGLenum *TextureChunkBase::getSFShaderInput(void) const
{
    return &_sfShaderInput;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFShaderInput(void)
{
    return this->editSFShaderInput();
}
#endif

MFReal32 *TextureChunkBase::editMFShaderOffsetMatrix(void)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    return &_mfShaderOffsetMatrix;
}

const MFReal32 *TextureChunkBase::getMFShaderOffsetMatrix(void) const
{
    return &_mfShaderOffsetMatrix;
}

#ifdef OSG_1_COMPAT
MFReal32 *TextureChunkBase::getMFShaderOffsetMatrix(void)
{
    return this->editMFShaderOffsetMatrix();
}
#endif

SFReal32 *TextureChunkBase::editSFShaderOffsetScale(void)
{
    editSField(ShaderOffsetScaleFieldMask);

    return &_sfShaderOffsetScale;
}

const SFReal32 *TextureChunkBase::getSFShaderOffsetScale(void) const
{
    return &_sfShaderOffsetScale;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFShaderOffsetScale(void)
{
    return this->editSFShaderOffsetScale();
}
#endif

SFReal32 *TextureChunkBase::editSFShaderOffsetBias(void)
{
    editSField(ShaderOffsetBiasFieldMask);

    return &_sfShaderOffsetBias;
}

const SFReal32 *TextureChunkBase::getSFShaderOffsetBias(void) const
{
    return &_sfShaderOffsetBias;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFShaderOffsetBias(void)
{
    return this->editSFShaderOffsetBias();
}
#endif

SFGLenum *TextureChunkBase::editSFShaderRGBADotProduct(void)
{
    editSField(ShaderRGBADotProductFieldMask);

    return &_sfShaderRGBADotProduct;
}

const SFGLenum *TextureChunkBase::getSFShaderRGBADotProduct(void) const
{
    return &_sfShaderRGBADotProduct;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFShaderRGBADotProduct(void)
{
    return this->editSFShaderRGBADotProduct();
}
#endif

SFUInt8 *TextureChunkBase::editSFShaderCullModes(void)
{
    editSField(ShaderCullModesFieldMask);

    return &_sfShaderCullModes;
}

const SFUInt8 *TextureChunkBase::getSFShaderCullModes(void) const
{
    return &_sfShaderCullModes;
}

#ifdef OSG_1_COMPAT
SFUInt8 *TextureChunkBase::getSFShaderCullModes(void)
{
    return this->editSFShaderCullModes();
}
#endif

SFVec3f *TextureChunkBase::editSFShaderConstEye(void)
{
    editSField(ShaderConstEyeFieldMask);

    return &_sfShaderConstEye;
}

const SFVec3f *TextureChunkBase::getSFShaderConstEye(void) const
{
    return &_sfShaderConstEye;
}

#ifdef OSG_1_COMPAT
SFVec3f *TextureChunkBase::getSFShaderConstEye(void)
{
    return this->editSFShaderConstEye();
}
#endif

SFReal32 *TextureChunkBase::editSFLodBias(void)
{
    editSField(LodBiasFieldMask);

    return &_sfLodBias;
}

const SFReal32 *TextureChunkBase::getSFLodBias(void) const
{
    return &_sfLodBias;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFLodBias(void)
{
    return this->editSFLodBias();
}
#endif

SFGLenum *TextureChunkBase::editSFTarget(void)
{
    editSField(TargetFieldMask);

    return &_sfTarget;
}

const SFGLenum *TextureChunkBase::getSFTarget(void) const
{
    return &_sfTarget;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFTarget(void)
{
    return this->editSFTarget();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyLeft(void)
{
    editSField(DirtyLeftFieldMask);

    return &_sfDirtyLeft;
}

const SFInt32 *TextureChunkBase::getSFDirtyLeft(void) const
{
    return &_sfDirtyLeft;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyLeft(void)
{
    return this->editSFDirtyLeft();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMinX(void)
{
    editSField(DirtyMinXFieldMask);

    return &_sfDirtyMinX;
}

const SFInt32 *TextureChunkBase::getSFDirtyMinX(void) const
{
    return &_sfDirtyMinX;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMinX(void)
{
    return this->editSFDirtyMinX();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMaxX(void)
{
    editSField(DirtyMaxXFieldMask);

    return &_sfDirtyMaxX;
}

const SFInt32 *TextureChunkBase::getSFDirtyMaxX(void) const
{
    return &_sfDirtyMaxX;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMaxX(void)
{
    return this->editSFDirtyMaxX();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMinY(void)
{
    editSField(DirtyMinYFieldMask);

    return &_sfDirtyMinY;
}

const SFInt32 *TextureChunkBase::getSFDirtyMinY(void) const
{
    return &_sfDirtyMinY;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMinY(void)
{
    return this->editSFDirtyMinY();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMaxY(void)
{
    editSField(DirtyMaxYFieldMask);

    return &_sfDirtyMaxY;
}

const SFInt32 *TextureChunkBase::getSFDirtyMaxY(void) const
{
    return &_sfDirtyMaxY;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMaxY(void)
{
    return this->editSFDirtyMaxY();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMinZ(void)
{
    editSField(DirtyMinZFieldMask);

    return &_sfDirtyMinZ;
}

const SFInt32 *TextureChunkBase::getSFDirtyMinZ(void) const
{
    return &_sfDirtyMinZ;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMinZ(void)
{
    return this->editSFDirtyMinZ();
}
#endif

SFInt32 *TextureChunkBase::editSFDirtyMaxZ(void)
{
    editSField(DirtyMaxZFieldMask);

    return &_sfDirtyMaxZ;
}

const SFInt32 *TextureChunkBase::getSFDirtyMaxZ(void) const
{
    return &_sfDirtyMaxZ;
}

#ifdef OSG_1_COMPAT
SFInt32 *TextureChunkBase::getSFDirtyMaxZ(void)
{
    return this->editSFDirtyMaxZ();
}
#endif

SFReal32 *TextureChunkBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureChunkBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}

#ifdef OSG_1_COMPAT
SFReal32 *TextureChunkBase::getSFAnisotropy(void)
{
    return this->editSFAnisotropy();
}
#endif

SFColor4f *TextureChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}

#ifdef OSG_1_COMPAT
SFColor4f *TextureChunkBase::getSFBorderColor(void)
{
    return this->editSFBorderColor();
}
#endif

SFGLenum *TextureChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *TextureChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFCompareMode(void)
{
    return this->editSFCompareMode();
}
#endif

SFGLenum *TextureChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *TextureChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFCompareFunc(void)
{
    return this->editSFCompareFunc();
}
#endif

SFGLenum *TextureChunkBase::editSFDepthMode(void)
{
    editSField(DepthModeFieldMask);

    return &_sfDepthMode;
}

const SFGLenum *TextureChunkBase::getSFDepthMode(void) const
{
    return &_sfDepthMode;
}

#ifdef OSG_1_COMPAT
SFGLenum *TextureChunkBase::getSFDepthMode(void)
{
    return this->editSFDepthMode();
}
#endif


void TextureChunkBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureChunk *>(this)->setImage(
            cast_dynamic<ImagePtr>(pNewElement));
    }
}

void TextureChunkBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void TextureChunkBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void TextureChunkBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void TextureChunkBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void TextureChunkBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void TextureChunkBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureChunk *>(this)->setImage(NullFC);
    }
}




/*------------------------------ access -----------------------------------*/

UInt32 TextureChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        returnValue += _sfEnvMode.getBinSize();
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        returnValue += _sfEnvColor.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        returnValue += _sfEnvCombineRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvCombineAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        returnValue += _sfEnvScaleRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvScaleAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        returnValue += _sfIgnoreGLForAspect.getBinSize();
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        returnValue += _sfPointSprite.getBinSize();
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        returnValue += _sfPriority.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        returnValue += _sfShaderOperation.getBinSize();
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        returnValue += _sfShaderInput.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        returnValue += _mfShaderOffsetMatrix.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetScale.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        returnValue += _sfShaderRGBADotProduct.getBinSize();
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        returnValue += _sfShaderCullModes.getBinSize();
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        returnValue += _sfShaderConstEye.getBinSize();
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        returnValue += _sfLodBias.getBinSize();
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        returnValue += _sfTarget.getBinSize();
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        returnValue += _sfDirtyLeft.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        returnValue += _sfDirtyMinX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        returnValue += _sfDirtyMinY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        returnValue += _sfDirtyMinZ.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxZ.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        returnValue += _sfDepthMode.getBinSize();
    }

    return returnValue;
}

void TextureChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyToBin(pMem);
    }
}

void TextureChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
TextureChunkPtr TextureChunkBase::createEmpty(void) 
{ 
    TextureChunkPtr returnValue; 
    
    newPtr<TextureChunk>(returnValue); 

    return returnValue; 
}

FieldContainerPtr TextureChunkBase::shallowCopy(void) const 
{ 
    TextureChunkPtr returnValue; 

    newPtr(returnValue, dynamic_cast<const TextureChunk *>(this)); 

    return returnValue; 
}



/*------------------------- constructors ----------------------------------*/

TextureChunkBase::TextureChunkBase(void) :
    Inherited(),
    _sfImage(),
    _sfInternalFormat(GLenum(GL_NONE)),
    _sfExternalFormat(GLenum(GL_NONE)),
    _sfScale(bool(true)),
    _sfFrame(UInt32(0)),
    _sfMinFilter(GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter(GLenum(GL_LINEAR)),
    _sfWrapS(GLenum(GL_REPEAT)),
    _sfWrapT(GLenum(GL_REPEAT)),
    _sfWrapR(GLenum(GL_REPEAT)),
    _sfEnvMode(GLenum(GL_REPLACE)),
    _sfEnvColor(Color4f(0,0,0,0)),
    _sfEnvCombineRGB(GLenum(GL_MODULATE)),
    _sfEnvCombineAlpha(GLenum(GL_MODULATE)),
    _sfEnvScaleRGB(Real32(1.0f)),
    _sfEnvScaleAlpha(Real32(1.0f)),
    _sfEnvSource0RGB(GLenum(GL_TEXTURE)),
    _sfEnvSource1RGB(GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2RGB(GLenum(GL_CONSTANT_EXT)),
    _sfEnvSource0Alpha(GLenum(GL_TEXTURE)),
    _sfEnvSource1Alpha(GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2Alpha(GLenum(GL_CONSTANT_EXT)),
    _sfEnvOperand0RGB(GLenum(GL_SRC_COLOR)),
    _sfEnvOperand1RGB(GLenum(GL_SRC_COLOR)),
    _sfEnvOperand2RGB(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand0Alpha(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand1Alpha(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand2Alpha(GLenum(GL_SRC_ALPHA)),
    _sfGLId(GLenum(0)),
    _sfIgnoreGLForAspect(Int32(-1)),
    _sfPointSprite(bool(GL_FALSE)),
    _sfPriority(Real32(1.f)),
    _sfShaderOperation(GLenum(GL_NONE)),
    _sfShaderInput(GLenum(GL_NONE)),
    _mfShaderOffsetMatrix(),
    _sfShaderOffsetScale(Real32(1.f)),
    _sfShaderOffsetBias(Real32(0.f)),
    _sfShaderRGBADotProduct(GLenum(GL_NONE)),
    _sfShaderCullModes(UInt8(0)),
    _sfShaderConstEye(),
    _sfLodBias(Real32(0.f)),
    _sfTarget(GLenum(GL_NONE)),
    _sfDirtyLeft(Int32(-1)),
    _sfDirtyMinX(Int32(-1)),
    _sfDirtyMaxX(Int32(-1)),
    _sfDirtyMinY(Int32(-1)),
    _sfDirtyMaxY(Int32(-1)),
    _sfDirtyMinZ(Int32(-1)),
    _sfDirtyMaxZ(Int32(-1)),
    _sfAnisotropy(Real32(1.0f)),
    _sfBorderColor(Color4f(0,0,0,0)),
    _sfCompareMode(GLenum(GL_NONE)),
    _sfCompareFunc(GLenum(GL_LEQUAL)),
    _sfDepthMode(GLenum(GL_LUMINANCE))
{
}

TextureChunkBase::TextureChunkBase(const TextureChunkBase &source) :
    Inherited(source),
    _sfImage(),
    _sfInternalFormat(source._sfInternalFormat),
    _sfExternalFormat(source._sfExternalFormat),
    _sfScale(source._sfScale),
    _sfFrame(source._sfFrame),
    _sfMinFilter(source._sfMinFilter),
    _sfMagFilter(source._sfMagFilter),
    _sfWrapS(source._sfWrapS),
    _sfWrapT(source._sfWrapT),
    _sfWrapR(source._sfWrapR),
    _sfEnvMode(source._sfEnvMode),
    _sfEnvColor(source._sfEnvColor),
    _sfEnvCombineRGB(source._sfEnvCombineRGB),
    _sfEnvCombineAlpha(source._sfEnvCombineAlpha),
    _sfEnvScaleRGB(source._sfEnvScaleRGB),
    _sfEnvScaleAlpha(source._sfEnvScaleAlpha),
    _sfEnvSource0RGB(source._sfEnvSource0RGB),
    _sfEnvSource1RGB(source._sfEnvSource1RGB),
    _sfEnvSource2RGB(source._sfEnvSource2RGB),
    _sfEnvSource0Alpha(source._sfEnvSource0Alpha),
    _sfEnvSource1Alpha(source._sfEnvSource1Alpha),
    _sfEnvSource2Alpha(source._sfEnvSource2Alpha),
    _sfEnvOperand0RGB(source._sfEnvOperand0RGB),
    _sfEnvOperand1RGB(source._sfEnvOperand1RGB),
    _sfEnvOperand2RGB(source._sfEnvOperand2RGB),
    _sfEnvOperand0Alpha(source._sfEnvOperand0Alpha),
    _sfEnvOperand1Alpha(source._sfEnvOperand1Alpha),
    _sfEnvOperand2Alpha(source._sfEnvOperand2Alpha),
    _sfGLId(source._sfGLId),
    _sfIgnoreGLForAspect(source._sfIgnoreGLForAspect),
    _sfPointSprite(source._sfPointSprite),
    _sfPriority(source._sfPriority),
    _sfShaderOperation(source._sfShaderOperation),
    _sfShaderInput(source._sfShaderInput),
    _mfShaderOffsetMatrix(source._mfShaderOffsetMatrix),
    _sfShaderOffsetScale(source._sfShaderOffsetScale),
    _sfShaderOffsetBias(source._sfShaderOffsetBias),
    _sfShaderRGBADotProduct(source._sfShaderRGBADotProduct),
    _sfShaderCullModes(source._sfShaderCullModes),
    _sfShaderConstEye(source._sfShaderConstEye),
    _sfLodBias(source._sfLodBias),
    _sfTarget(source._sfTarget),
    _sfDirtyLeft(source._sfDirtyLeft),
    _sfDirtyMinX(source._sfDirtyMinX),
    _sfDirtyMaxX(source._sfDirtyMaxX),
    _sfDirtyMinY(source._sfDirtyMinY),
    _sfDirtyMaxY(source._sfDirtyMaxY),
    _sfDirtyMinZ(source._sfDirtyMinZ),
    _sfDirtyMaxZ(source._sfDirtyMaxZ),
    _sfAnisotropy(source._sfAnisotropy),
    _sfBorderColor(source._sfBorderColor),
    _sfCompareMode(source._sfCompareMode),
    _sfCompareFunc(source._sfCompareFunc),
    _sfDepthMode(source._sfDepthMode)
{
}

/*-------------------------- destructors ----------------------------------*/

TextureChunkBase::~TextureChunkBase(void)
{
}

void TextureChunkBase::onCreate(const TextureChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setImage(source->getImage());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void TextureChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<TextureChunkBase *>(&oFrom),
                   whichField, 
                   syncMode, 
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void TextureChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<TextureChunkBase *>(&oFrom), 
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void TextureChunkBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr TextureChunkBase::createAspectCopy(void) const
{
    TextureChunkPtr returnValue; 

    newAspectCopy(returnValue, 
                  dynamic_cast<const TextureChunk *>(this)); 

    return returnValue; 
}
#endif

void TextureChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureChunk *>(this)->setImage(NullFC);
}


#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureChunkPtr>::_type("TextureChunkPtr", "TextureBaseChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureChunkPtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, TextureChunkPtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, TextureChunkPtr);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGTEXTURECHUNKBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGTEXTURECHUNKBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGTEXTURECHUNKFIELDS_HEADER_CVSID;
}

/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MultiLightChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGNode.h"                    // Beacon Class

#include "OSGMultiLightChunkBase.h"
#include "OSGMultiLightChunk.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MultiLightChunk
    See \ref PageSystemMultiLightChunk for a description.

    This chunk represents a number of lights that are exposed to shader code
    in form of a buffer in OpenGL std430 layout format.
    A shader, binding a shader storage block to the very same binding point, 
    is expected to respect the corresponding block layout. The layout is regulated
    by the hasXXX fields of the chunk. If one is set to false the corresponding
    struct entry is omitted.

    struct Light
    {
    mat4  worldToLightSpaceMatrix;
    mat4  lightToWorldSpaceMatrix;
    mat4  eyeToLightSpaceMatrix;
    mat4  lightToEyeSpaceMatrix;
    mat4  lightPerspectiveMatrix;
    mat4  invLightPerspectiveMatrix;
    vec3  position;
    vec3  direction;
    vec3  color;
    vec3  ambientIntensity;
    vec3  diffuseIntensity;
    vec3  specularIntensity;
    float intensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    float rangeCutOn;
    float rangeCutOff;
    float rangeNearZone;
    float rangeFarZone;
    float cosSpotlightAngle;
    float spotlightAngle;
    float spotExponent;
    float innerSuperEllipsesWidth;
    float innerSuperEllipsesHeight;
    float outerSuperEllipsesWidth;
    float outerSuperEllipsesHeight;
    float superEllipsesRoundness;
    float superEllipsesTwist;
    int   type;
    bool  enabled;
    };

    layout (std430) buffer Lights
    {
    Light light[];
    } lights;

    The chunk provides a convenient function that allows to adjust the struct layout
    for standard OpenGL lights 

    struct Light
    {
    vec3  position;
    vec3  direction;
    vec3  ambientIntensity;
    vec3  diffuseIntensity;
    vec3  specularIntensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    float cosSpotlightAngle;
    float spotExponent;
    int   type;
    bool  enabled;
    };

    or for simple range lights:

    struct Light
    {
    vec3  position;
    vec3  direction;
    vec3  color;
    float intensity;
    float rangeCutOff;
    float cosSpotlightAngle;
    int   type;
    bool  enabled;
    };
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var bool            MultiLightChunkBase::_sfHasWorldToLightSpaceMatrix
    This flag determines if the worldToLightSpaceMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  worldToLightSpaceMatrix;" 
    entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasLightToWorldSpaceMatrix
    This flag determines if the lightToWorldSpaceMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  lightToWorldSpaceMatrix;" 
    entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasEyeToLightSpaceMatrix
    This flag determines if the eyeToLightSpaceMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  eyeToLightSpaceMatrix;" 
    entry is contained in the shader struct for the Light.
    Attention: If this flag is set the light shader storage block has to
    be updated with every redraw operation.
*/

/*! \var bool            MultiLightChunkBase::_sfHasLightToEyeSpaceMatrix
    This flag determines if the lightToEyeSpaceMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  lightToEyeSpaceMatrix;" 
    entry is contained in the shader struct for the Light.
    Attention: If this flag is set the light shader storage block has to
    be updated with every redraw operation.
*/

/*! \var bool            MultiLightChunkBase::_sfHasLightPerspectiveMatrix
    This flag determines if the lightPerspectiveMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  lightPerspectiveMatrix;" 
    entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasInvLightPerspectiveMatrix
    This flag determines if the lightToEyeSpaceMatrix attribute is part of 
    the shader storage block, i.e. if the "mat4  invLightToEyeSpaceMatrix;" 
    entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasColor
    This flag determines if the color attribute is part of the shader storage block, i.e.
    if the "vec3  color;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasIntensity
    This flag determines if the intensity attribute is part of the shader storage block, i.e.
    if the "float intensity;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasSeparateIntensities
    This flag determines if the color intensity attributes are part of the shader storage block, i.e.
    if the "vec3  Ia;", "vec3  Id;" and "vec3 Is;" entries are contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasAttenuation
    This flag determines if the attenuation attributes are part of the shader storage block, i.e.
    if the "float constantAttenuation;", "float linearAttenuation;" and "float quadraticAttenuation;"
    entries are contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfAutoCalcRanges
    If this flag is active and the lights have attenuations, then the cut on and cut off ranges
    are automatically calculated. They are, however, not provided automatically to the shader.
    For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.
*/

/*! \var bool            MultiLightChunkBase::_sfHasRangeCutOn
    This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.
    if the "float rangeCutOn;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasRangeCutOff
    This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.
    if the "float hasRangeCutOff;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasRangeNearZone
    This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.
    if the "float hasRangeNearZone;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasRangeFarZone
    This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.
    if the "float hasRangeFarZone;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasCosSpotlightAngle
    This flag determines if the cosine of the spot light angle attribute is part of the shader storage block, i.e.
    if the "float  cosSpotlightAngle;" entry is contained in the shader struct for the Light. If neither this flag
    nor the hasSpotlightAngle flag is true, then this flag is treated as if it has value true.
*/

/*! \var bool            MultiLightChunkBase::_sfHasSpotlightAngle
    This flag determines if the spot light angle attribute is part of the shader storage block, i.e.
    if the "float  spotlightAngle;" entry is contained in the shader struct for the Light. If neither this flag
    nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle flag is treated as if it has value true.
*/

/*! \var bool            MultiLightChunkBase::_sfHasSpotExponent
    This flag determines if the spot expenent attribute is part of the shader storage block, i.e.
    if the "float  spotExponent;" entry is contained in the shader struct for the Light.
*/

/*! \var bool            MultiLightChunkBase::_sfHasCinemaLight
    This flag determines if the cinema light attributes are part of the shader storage block, i.e.
    if the "float innerSuperEllipsesWidth;", ... entries are contained in the shader struct for the Light.
    If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone
    flags, because cinema lights are described the corresponding attributes.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Pnt3f           MultiLightChunkBase::_mfPosition
    The light's position for point and spotlights in beacon space.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfDirection
    The light's direction for directional and spotlights in beacon space.
*/

/*! \var Color3f         MultiLightChunkBase::_mfColor
    The light's color.
*/

/*! \var Real32          MultiLightChunkBase::_mfIntensity
    The light's intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfAmbientIntensity
    The light's ambient intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfDiffuseIntensity
    The light's diffuse intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfSpecularIntensity
    The light's specular intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfAttenuation
    The light's attenuation consiting of the constant, linear and quadratic attenuation parts.
*/

/*! \var Real32          MultiLightChunkBase::_mfSpotlightAngle
    The spot angle in degree.
*/

/*! \var Real32          MultiLightChunkBase::_mfSpotExponent
    The spot angle in degree.
*/

/*! \var Real32          MultiLightChunkBase::_mfInnerSuperEllipsesWidth
    The cinema light is described among others by an inner ellipses. This is
    the width of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfInnerSuperEllipsesHeight
    The cinema light is described among others by an inner ellipses. This is
    the height of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfOuterSuperEllipsesWidth
    The cinema light is described among others by an outer ellipses. This is
    the width of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfOuterSuperEllipsesHeight
    The cinema light is described among others by an outer ellipses. This is
    the height of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfSuperEllipsesRoundness
    The cinema light is described among others by a roundness parameter. 
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfSuperEllipsesTwist
    The twist angle in degree by which the superellipses is rotatet in the xy-plane.
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeCutOn
    The cinema light is described among others by a rangeCutOn parameter.
    In the interval rangeCutOn to rangeCutOff the lighted fragments are
    fully lit.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeCutOff
    The cinema light is described among others by a rangeCutOff parameter.
    In the interval rangeCutOn to rangeCutOff the lighted fragments are
    fully lit.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeNearZone
    The cinema light is described among others by a rangeNearZone parameter.
    In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are
    partly lit.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeFarZone
    In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are
    partly lit.
*/

/*! \var UInt8           MultiLightChunkBase::_mfType
    Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.
*/

/*! \var bool            MultiLightChunkBase::_mfEnabled
    The on/off state of the light.
*/

/*! \var Node *          MultiLightChunkBase::_mfBeacon
    The light's beacon determining its position or direction.
*/

/*! \var Matrix          MultiLightChunkBase::_mfBeaconMatrix
    The beacon matrices used for the last render pass.
*/

/*! \var bool            MultiLightChunkBase::_sfEyeSpace
    The lights position and direction are transformed to eye space before loading into the shader. 
    On default they are provided in world space.
*/

/*! \var Real32          MultiLightChunkBase::_sfLastCamNear
    The camera last near value.
*/

/*! \var Real32          MultiLightChunkBase::_sfLastCamFar
    The camera last far value.
*/

/*! \var Matrix          MultiLightChunkBase::_sfLastCamToWorld
    The camera last to world matrix.
*/

/*! \var std::string     MultiLightChunkBase::_sfLightBlockName
    The shader storage buffer block name for the light buffer.
*/

/*! \var std::string     MultiLightChunkBase::_sfLightVariableName
    The shader variable name for the light buffer.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MultiLightChunk *, nsOSG>::_type(
    "MultiLightChunkPtr", 
    "ShaderStorageBufferObjStdLayoutChunkPtr", 
    MultiLightChunk::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MultiLightChunk *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MultiLightChunk *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MultiLightChunk *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MultiLightChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasWorldToLightSpaceMatrix",
        "This flag determines if the worldToLightSpaceMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  worldToLightSpaceMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n",
        HasWorldToLightSpaceMatrixFieldId, HasWorldToLightSpaceMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasWorldToLightSpaceMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasWorldToLightSpaceMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasLightToWorldSpaceMatrix",
        "This flag determines if the lightToWorldSpaceMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  lightToWorldSpaceMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n",
        HasLightToWorldSpaceMatrixFieldId, HasLightToWorldSpaceMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasLightToWorldSpaceMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasLightToWorldSpaceMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasEyeToLightSpaceMatrix",
        "This flag determines if the eyeToLightSpaceMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  eyeToLightSpaceMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n"
        "Attention: If this flag is set the light shader storage block has to\n"
        "be updated with every redraw operation.\n",
        HasEyeToLightSpaceMatrixFieldId, HasEyeToLightSpaceMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasEyeToLightSpaceMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasEyeToLightSpaceMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasLightToEyeSpaceMatrix",
        "This flag determines if the lightToEyeSpaceMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  lightToEyeSpaceMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n"
        "Attention: If this flag is set the light shader storage block has to\n"
        "be updated with every redraw operation.\n",
        HasLightToEyeSpaceMatrixFieldId, HasLightToEyeSpaceMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasLightToEyeSpaceMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasLightToEyeSpaceMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasLightPerspectiveMatrix",
        "This flag determines if the lightPerspectiveMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  lightPerspectiveMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n",
        HasLightPerspectiveMatrixFieldId, HasLightPerspectiveMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasLightPerspectiveMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasLightPerspectiveMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasInvLightPerspectiveMatrix",
        "This flag determines if the lightToEyeSpaceMatrix attribute is part of \n"
        "the shader storage block, i.e. if the \"mat4  invLightToEyeSpaceMatrix;\" \n"
        "entry is contained in the shader struct for the Light.\n",
        HasInvLightPerspectiveMatrixFieldId, HasInvLightPerspectiveMatrixFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasInvLightPerspectiveMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasInvLightPerspectiveMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasColor",
        "This flag determines if the color attribute is part of the shader storage block, i.e.\n"
        "if the \"vec3  color;\" entry is contained in the shader struct for the Light.\n",
        HasColorFieldId, HasColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasColor),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasIntensity",
        "This flag determines if the intensity attribute is part of the shader storage block, i.e.\n"
        "if the \"float intensity;\" entry is contained in the shader struct for the Light.\n",
        HasIntensityFieldId, HasIntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasSeparateIntensities",
        "This flag determines if the color intensity attributes are part of the shader storage block, i.e.\n"
        "if the \"vec3  Ia;\", \"vec3  Id;\" and \"vec3 Is;\" entries are contained in the shader struct for the Light.\n",
        HasSeparateIntensitiesFieldId, HasSeparateIntensitiesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasSeparateIntensities),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasSeparateIntensities));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasAttenuation",
        "This flag determines if the attenuation attributes are part of the shader storage block, i.e.\n"
        "if the \"float constantAttenuation;\", \"float linearAttenuation;\" and \"float quadraticAttenuation;\"\n"
        "entries are contained in the shader struct for the Light.\n",
        HasAttenuationFieldId, HasAttenuationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasAttenuation),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasAttenuation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoCalcRanges",
        "If this flag is active and the lights have attenuations, then the cut on and cut off ranges\n"
        "are automatically calculated. They are, however, not provided automatically to the shader.\n"
        "For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.\n",
        AutoCalcRangesFieldId, AutoCalcRangesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleAutoCalcRanges),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleAutoCalcRanges));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasRangeCutOn",
        "This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.\n"
        "if the \"float rangeCutOn;\" entry is contained in the shader struct for the Light.\n",
        HasRangeCutOnFieldId, HasRangeCutOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasRangeCutOn),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasRangeCutOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasRangeCutOff",
        "This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.\n"
        "if the \"float hasRangeCutOff;\" entry is contained in the shader struct for the Light.\n",
        HasRangeCutOffFieldId, HasRangeCutOffFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasRangeCutOff),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasRangeCutOff));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasRangeNearZone",
        "This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.\n"
        "if the \"float hasRangeNearZone;\" entry is contained in the shader struct for the Light.\n",
        HasRangeNearZoneFieldId, HasRangeNearZoneFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasRangeNearZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasRangeNearZone));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasRangeFarZone",
        "This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.\n"
        "if the \"float hasRangeFarZone;\" entry is contained in the shader struct for the Light.\n",
        HasRangeFarZoneFieldId, HasRangeFarZoneFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasRangeFarZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasRangeFarZone));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasCosSpotlightAngle",
        "This flag determines if the cosine of the spot light angle attribute is part of the shader storage block, i.e.\n"
        "if the \"float  cosSpotlightAngle;\" entry is contained in the shader struct for the Light. If neither this flag\n"
        "nor the hasSpotlightAngle flag is true, then this flag is treated as if it has value true.\n",
        HasCosSpotlightAngleFieldId, HasCosSpotlightAngleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasCosSpotlightAngle),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasCosSpotlightAngle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasSpotlightAngle",
        "This flag determines if the spot light angle attribute is part of the shader storage block, i.e.\n"
        "if the \"float  spotlightAngle;\" entry is contained in the shader struct for the Light. If neither this flag\n"
        "nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle flag is treated as if it has value true.\n",
        HasSpotlightAngleFieldId, HasSpotlightAngleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasSpotlightAngle),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasSpotlightAngle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasSpotExponent",
        "This flag determines if the spot expenent attribute is part of the shader storage block, i.e.\n"
        "if the \"float  spotExponent;\" entry is contained in the shader struct for the Light.\n",
        HasSpotExponentFieldId, HasSpotExponentFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasSpotExponent),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasSpotExponent));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasCinemaLight",
        "This flag determines if the cinema light attributes are part of the shader storage block, i.e.\n"
        "if the \"float innerSuperEllipsesWidth;\", ... entries are contained in the shader struct for the Light.\n"
        "If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone\n"
        "flags, because cinema lights are described the corresponding attributes.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        HasCinemaLightFieldId, HasCinemaLightFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleHasCinemaLight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleHasCinemaLight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFPnt3f::Description(
        MFPnt3f::getClassType(),
        "position",
        "The light's position for point and spotlights in beacon space.\n",
        PositionFieldId, PositionFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandlePosition),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandlePosition));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "direction",
        "The light's direction for directional and spotlights in beacon space.\n",
        DirectionFieldId, DirectionFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleDirection),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleDirection));

    oType.addInitialDesc(pDesc);

    pDesc = new MFColor3f::Description(
        MFColor3f::getClassType(),
        "color",
        "The light's color.\n",
        ColorFieldId, ColorFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleColor),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleColor));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "intensity",
        "The light's intensity.\n",
        IntensityFieldId, IntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "ambientIntensity",
        "The light's ambient intensity.\n",
        AmbientIntensityFieldId, AmbientIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleAmbientIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleAmbientIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "diffuseIntensity",
        "The light's diffuse intensity.\n",
        DiffuseIntensityFieldId, DiffuseIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleDiffuseIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleDiffuseIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "specularIntensity",
        "The light's specular intensity.\n",
        SpecularIntensityFieldId, SpecularIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpecularIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpecularIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "attenuation",
        "The light's attenuation consiting of the constant, linear and quadratic attenuation parts.\n",
        AttenuationFieldId, AttenuationFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleAttenuation),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleAttenuation));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "spotlightAngle",
        "The spot angle in degree.\n",
        SpotlightAngleFieldId, SpotlightAngleFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpotlightAngle),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpotlightAngle));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "spotExponent",
        "The spot angle in degree.\n",
        SpotExponentFieldId, SpotExponentFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpotExponent),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpotExponent));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "innerSuperEllipsesWidth",
        "The cinema light is described among others by an inner ellipses. This is\n"
        "the width of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        InnerSuperEllipsesWidthFieldId, InnerSuperEllipsesWidthFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleInnerSuperEllipsesWidth),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleInnerSuperEllipsesWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "innerSuperEllipsesHeight",
        "The cinema light is described among others by an inner ellipses. This is\n"
        "the height of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        InnerSuperEllipsesHeightFieldId, InnerSuperEllipsesHeightFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleInnerSuperEllipsesHeight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleInnerSuperEllipsesHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "outerSuperEllipsesWidth",
        "The cinema light is described among others by an outer ellipses. This is\n"
        "the width of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        OuterSuperEllipsesWidthFieldId, OuterSuperEllipsesWidthFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleOuterSuperEllipsesWidth),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleOuterSuperEllipsesWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "outerSuperEllipsesHeight",
        "The cinema light is described among others by an outer ellipses. This is\n"
        "the height of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        OuterSuperEllipsesHeightFieldId, OuterSuperEllipsesHeightFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleOuterSuperEllipsesHeight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleOuterSuperEllipsesHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "superEllipsesRoundness",
        "The cinema light is described among others by a roundness parameter. \n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        SuperEllipsesRoundnessFieldId, SuperEllipsesRoundnessFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSuperEllipsesRoundness),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSuperEllipsesRoundness));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "superEllipsesTwist",
        "The twist angle in degree by which the superellipses is rotatet in the xy-plane.\n",
        SuperEllipsesTwistFieldId, SuperEllipsesTwistFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSuperEllipsesTwist),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSuperEllipsesTwist));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeCutOn",
        "The cinema light is described among others by a rangeCutOn parameter.\n"
        "In the interval rangeCutOn to rangeCutOff the lighted fragments are\n"
        "fully lit.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        RangeCutOnFieldId, RangeCutOnFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeCutOn),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeCutOn));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeCutOff",
        "The cinema light is described among others by a rangeCutOff parameter.\n"
        "In the interval rangeCutOn to rangeCutOff the lighted fragments are\n"
        "fully lit.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        RangeCutOffFieldId, RangeCutOffFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeCutOff),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeCutOff));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeNearZone",
        "The cinema light is described among others by a rangeNearZone parameter.\n"
        "In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are\n"
        "partly lit.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        RangeNearZoneFieldId, RangeNearZoneFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeNearZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeNearZone));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeFarZone",
        "In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are\n"
        "partly lit.\n",
        RangeFarZoneFieldId, RangeFarZoneFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeFarZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeFarZone));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "type",
        "Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.\n",
        TypeFieldId, TypeFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleType),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleType));

    oType.addInitialDesc(pDesc);

    pDesc = new MFBool::Description(
        MFBool::getClassType(),
        "enabled",
        "The on/off state of the light.\n",
        EnabledFieldId, EnabledFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleEnabled),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleEnabled));

    oType.addInitialDesc(pDesc);

    pDesc = new MFWeakNodePtr::Description(
        MFWeakNodePtr::getClassType(),
        "beacon",
        "The light's beacon determining its position or direction.\n",
        BeaconFieldId, BeaconFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleBeacon),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleBeacon));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "beaconMatrix",
        "The beacon matrices used for the last render pass.\n",
        BeaconMatrixFieldId, BeaconMatrixFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleBeaconMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleBeaconMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "eyeSpace",
        "The lights position and direction are transformed to eye space before loading into the shader. \n"
        "On default they are provided in world space.\n",
        EyeSpaceFieldId, EyeSpaceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleEyeSpace),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleEyeSpace));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lastCamNear",
        "The camera last near value.\n",
        LastCamNearFieldId, LastCamNearFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamNear),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamNear));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lastCamFar",
        "The camera last far value.\n",
        LastCamFarFieldId, LastCamFarFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamFar),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamFar));

    oType.addInitialDesc(pDesc);

    pDesc = new SFMatrix::Description(
        SFMatrix::getClassType(),
        "lastCamToWorld",
        "The camera last to world matrix.\n",
        LastCamToWorldFieldId, LastCamToWorldFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamToWorld),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamToWorld));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "LightBlockName",
        "The shader storage buffer block name for the light buffer.\n",
        LightBlockNameFieldId, LightBlockNameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLightBlockName),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLightBlockName));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "LightVariableName",
        "The shader variable name for the light buffer.\n",
        LightVariableNameFieldId, LightVariableNameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLightVariableName),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLightVariableName));

    oType.addInitialDesc(pDesc);
}


MultiLightChunkBase::TypeObject MultiLightChunkBase::_type(
    MultiLightChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MultiLightChunkBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MultiLightChunk::initMethod),
    reinterpret_cast<ExitContainerF>(&MultiLightChunk::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MultiLightChunk::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"MultiLightChunk\"\n"
    "    parent=\"ShaderStorageBufferObjStdLayoutChunk\"\n"
    "    library=\"System\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    docGroupBase=\"GrpSystemState\"\n"
    ">\n"
    "See \\ref PageSystemMultiLightChunk for a description.\n"
    "\n"
    "This chunk represents a number of lights that are exposed to shader code\n"
    "in form of a buffer in OpenGL std430 layout format.\n"
    "A shader, binding a shader storage block to the very same binding point, \n"
    "is expected to respect the corresponding block layout. The layout is regulated\n"
    "by the hasXXX fields of the chunk. If one is set to false the corresponding\n"
    "struct entry is omitted.\n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        mat4  worldToLightSpaceMatrix;\n"
    "        mat4  lightToWorldSpaceMatrix;\n"
    "        mat4  eyeToLightSpaceMatrix;\n"
    "        mat4  lightToEyeSpaceMatrix;\n"
    "        mat4  lightPerspectiveMatrix;\n"
    "        mat4  invLightPerspectiveMatrix;\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  color;\n"
    "        vec3  ambientIntensity;\n"
    "        vec3  diffuseIntensity;\n"
    "        vec3  specularIntensity;\n"
    "        float intensity;\n"
    "        float constantAttenuation;\n"
    "        float linearAttenuation;\n"
    "        float quadraticAttenuation;\n"
    "        float rangeCutOn;\n"
    "        float rangeCutOff;\n"
    "        float rangeNearZone;\n"
    "        float rangeFarZone;\n"
    "        float cosSpotlightAngle;\n"
    "        float spotlightAngle;\n"
    "        float spotExponent;\n"
    "        float innerSuperEllipsesWidth;\n"
    "        float innerSuperEllipsesHeight;\n"
    "        float outerSuperEllipsesWidth;\n"
    "        float outerSuperEllipsesHeight;\n"
    "        float superEllipsesRoundness;\n"
    "        float superEllipsesTwist;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "    };\n"
    "\n"
    "    layout (std430) buffer Lights\n"
    "    {\n"
    "        Light light[];\n"
    "    } lights;\n"
    "\n"
    "The chunk provides a convenient function that allows to adjust the struct layout\n"
    "for standard OpenGL lights \n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  ambientIntensity;\n"
    "        vec3  diffuseIntensity;\n"
    "        vec3  specularIntensity;\n"
    "        float constantAttenuation;\n"
    "        float linearAttenuation;\n"
    "        float quadraticAttenuation;\n"
    "        float cosSpotlightAngle;\n"
    "        float spotExponent;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "    };\n"
    "\n"
    "or for simple range lights:\n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  color;\n"
    "        float intensity;\n"
    "        float rangeCutOff;\n"
    "        float cosSpotlightAngle;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "    };\n"
    "\n"
    "    <Field\n"
    "        name=\"hasWorldToLightSpaceMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the worldToLightSpaceMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  worldToLightSpaceMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasLightToWorldSpaceMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the lightToWorldSpaceMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  lightToWorldSpaceMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasEyeToLightSpaceMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the eyeToLightSpaceMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  eyeToLightSpaceMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Attention: If this flag is set the light shader storage block has to\n"
    "        be updated with every redraw operation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasLightToEyeSpaceMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the lightToEyeSpaceMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  lightToEyeSpaceMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Attention: If this flag is set the light shader storage block has to\n"
    "        be updated with every redraw operation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasLightPerspectiveMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the lightPerspectiveMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  lightPerspectiveMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasInvLightPerspectiveMatrix\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the lightToEyeSpaceMatrix attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  invLightToEyeSpaceMatrix;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasColor\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the color attribute is part of the shader storage block, i.e.\n"
    "        if the \"vec3  color;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasIntensity\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the intensity attribute is part of the shader storage block, i.e.\n"
    "        if the \"float intensity;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasSeparateIntensities\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "        This flag determines if the color intensity attributes are part of the shader storage block, i.e.\n"
    "        if the \"vec3  Ia;\", \"vec3  Id;\" and \"vec3 Is;\" entries are contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasAttenuation\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "        This flag determines if the attenuation attributes are part of the shader storage block, i.e.\n"
    "        if the \"float constantAttenuation;\", \"float linearAttenuation;\" and \"float quadraticAttenuation;\"\n"
    "        entries are contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"autoCalcRanges\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "        If this flag is active and the lights have attenuations, then the cut on and cut off ranges\n"
    "        are automatically calculated. They are, however, not provided automatically to the shader.\n"
    "        For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasRangeCutOn\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.\n"
    "        if the \"float rangeCutOn;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasRangeCutOff\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeCutOff;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasRangeNearZone\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeNearZone;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasRangeFarZone\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeFarZone;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasCosSpotlightAngle\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "        This flag determines if the cosine of the spot light angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float  cosSpotlightAngle;\" entry is contained in the shader struct for the Light. If neither this flag\n"
    "        nor the hasSpotlightAngle flag is true, then this flag is treated as if it has value true.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasSpotlightAngle\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the spot light angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float  spotlightAngle;\" entry is contained in the shader struct for the Light. If neither this flag\n"
    "        nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle flag is treated as if it has value true.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasSpotExponent\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "        This flag determines if the spot expenent attribute is part of the shader storage block, i.e.\n"
    "        if the \"float  spotExponent;\" entry is contained in the shader struct for the Light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"hasCinemaLight\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "        This flag determines if the cinema light attributes are part of the shader storage block, i.e.\n"
    "        if the \"float innerSuperEllipsesWidth;\", ... entries are contained in the shader struct for the Light.\n"
    "        If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone\n"
    "        flags, because cinema lights are described the corresponding attributes.\n"
    "        See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "             http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "             https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"position\"\n"
    "        type=\"Pnt3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The light's position for point and spotlights in beacon space.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"direction\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's direction for directional and spotlights in beacon space.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"color\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's color.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"intensity\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"ambientIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's ambient intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"diffuseIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's diffuse intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"specularIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's specular intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"attenuation\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's attenuation consiting of the constant, linear and quadratic attenuation parts.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"spotlightAngle\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The spot angle in degree.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"spotExponent\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The spot angle in degree.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"innerSuperEllipsesWidth\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an inner ellipses. This is\n"
    "    the width of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"innerSuperEllipsesHeight\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an inner ellipses. This is\n"
    "    the height of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"outerSuperEllipsesWidth\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an outer ellipses. This is\n"
    "    the width of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"outerSuperEllipsesHeight\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an outer ellipses. This is\n"
    "    the height of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"superEllipsesRoundness\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a roundness parameter. \n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"superEllipsesTwist\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The twist angle in degree by which the superellipses is rotatet in the xy-plane.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeCutOn\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a rangeCutOn parameter.\n"
    "    In the interval rangeCutOn to rangeCutOff the lighted fragments are\n"
    "    fully lit.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeCutOff\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a rangeCutOff parameter.\n"
    "    In the interval rangeCutOn to rangeCutOff the lighted fragments are\n"
    "    fully lit.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeNearZone\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a rangeNearZone parameter.\n"
    "    In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are\n"
    "    partly lit.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeFarZone\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are\n"
    "    partly lit.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"type\"\n"
    "        type=\"UInt8\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"enabled\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The on/off state of the light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"beacon\"\n"
    "        type=\"Node\"\n"
    "        category=\"weakpointer\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's beacon determining its position or direction.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"beaconMatrix\"\n"
    "        type=\"Matrix\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "        The beacon matrices used for the last render pass.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"eyeSpace\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "    >\n"
    "    The lights position and direction are transformed to eye space before loading into the shader. \n"
    "    On default they are provided in world space.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamNear\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0.f\"\n"
    "    >\n"
    "        The camera last near value.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamFar\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0.f\"\n"
    "    >\n"
    "        The camera last far value.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamToWorld\"\n"
    "        type=\"Matrix\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "        The camera last to world matrix.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "     name=\"LightBlockName\"\n"
    "     type=\"std::string\"\n"
    "     cardinality=\"single\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     defaultValue='\"Lights\"'\n"
    "     >\n"
    "        The shader storage buffer block name for the light buffer.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "     name=\"LightVariableName\"\n"
    "     type=\"std::string\"\n"
    "     cardinality=\"single\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     defaultValue='\"lights\"'\n"
    "     >\n"
    "        The shader variable name for the light buffer.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "See \\ref PageSystemMultiLightChunk for a description.\n"
    "\n"
    "This chunk represents a number of lights that are exposed to shader code\n"
    "in form of a buffer in OpenGL std430 layout format.\n"
    "A shader, binding a shader storage block to the very same binding point, \n"
    "is expected to respect the corresponding block layout. The layout is regulated\n"
    "by the hasXXX fields of the chunk. If one is set to false the corresponding\n"
    "struct entry is omitted.\n"
    "\n"
    "struct Light\n"
    "{\n"
    "mat4  worldToLightSpaceMatrix;\n"
    "mat4  lightToWorldSpaceMatrix;\n"
    "mat4  eyeToLightSpaceMatrix;\n"
    "mat4  lightToEyeSpaceMatrix;\n"
    "mat4  lightPerspectiveMatrix;\n"
    "mat4  invLightPerspectiveMatrix;\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  color;\n"
    "vec3  ambientIntensity;\n"
    "vec3  diffuseIntensity;\n"
    "vec3  specularIntensity;\n"
    "float intensity;\n"
    "float constantAttenuation;\n"
    "float linearAttenuation;\n"
    "float quadraticAttenuation;\n"
    "float rangeCutOn;\n"
    "float rangeCutOff;\n"
    "float rangeNearZone;\n"
    "float rangeFarZone;\n"
    "float cosSpotlightAngle;\n"
    "float spotlightAngle;\n"
    "float spotExponent;\n"
    "float innerSuperEllipsesWidth;\n"
    "float innerSuperEllipsesHeight;\n"
    "float outerSuperEllipsesWidth;\n"
    "float outerSuperEllipsesHeight;\n"
    "float superEllipsesRoundness;\n"
    "float superEllipsesTwist;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "};\n"
    "\n"
    "layout (std430) buffer Lights\n"
    "{\n"
    "Light light[];\n"
    "} lights;\n"
    "\n"
    "The chunk provides a convenient function that allows to adjust the struct layout\n"
    "for standard OpenGL lights \n"
    "\n"
    "struct Light\n"
    "{\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  ambientIntensity;\n"
    "vec3  diffuseIntensity;\n"
    "vec3  specularIntensity;\n"
    "float constantAttenuation;\n"
    "float linearAttenuation;\n"
    "float quadraticAttenuation;\n"
    "float cosSpotlightAngle;\n"
    "float spotExponent;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "};\n"
    "\n"
    "or for simple range lights:\n"
    "\n"
    "struct Light\n"
    "{\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  color;\n"
    "float intensity;\n"
    "float rangeCutOff;\n"
    "float cosSpotlightAngle;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "};\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MultiLightChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &MultiLightChunkBase::getType(void) const
{
    return _type;
}

UInt32 MultiLightChunkBase::getContainerSize(void) const
{
    return sizeof(MultiLightChunk);
}

/*------------------------- decorator get ------------------------------*/


SFBool *MultiLightChunkBase::editSFHasWorldToLightSpaceMatrix(void)
{
    editSField(HasWorldToLightSpaceMatrixFieldMask);

    return &_sfHasWorldToLightSpaceMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasWorldToLightSpaceMatrix(void) const
{
    return &_sfHasWorldToLightSpaceMatrix;
}


SFBool *MultiLightChunkBase::editSFHasLightToWorldSpaceMatrix(void)
{
    editSField(HasLightToWorldSpaceMatrixFieldMask);

    return &_sfHasLightToWorldSpaceMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasLightToWorldSpaceMatrix(void) const
{
    return &_sfHasLightToWorldSpaceMatrix;
}


SFBool *MultiLightChunkBase::editSFHasEyeToLightSpaceMatrix(void)
{
    editSField(HasEyeToLightSpaceMatrixFieldMask);

    return &_sfHasEyeToLightSpaceMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasEyeToLightSpaceMatrix(void) const
{
    return &_sfHasEyeToLightSpaceMatrix;
}


SFBool *MultiLightChunkBase::editSFHasLightToEyeSpaceMatrix(void)
{
    editSField(HasLightToEyeSpaceMatrixFieldMask);

    return &_sfHasLightToEyeSpaceMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasLightToEyeSpaceMatrix(void) const
{
    return &_sfHasLightToEyeSpaceMatrix;
}


SFBool *MultiLightChunkBase::editSFHasLightPerspectiveMatrix(void)
{
    editSField(HasLightPerspectiveMatrixFieldMask);

    return &_sfHasLightPerspectiveMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasLightPerspectiveMatrix(void) const
{
    return &_sfHasLightPerspectiveMatrix;
}


SFBool *MultiLightChunkBase::editSFHasInvLightPerspectiveMatrix(void)
{
    editSField(HasInvLightPerspectiveMatrixFieldMask);

    return &_sfHasInvLightPerspectiveMatrix;
}

const SFBool *MultiLightChunkBase::getSFHasInvLightPerspectiveMatrix(void) const
{
    return &_sfHasInvLightPerspectiveMatrix;
}


SFBool *MultiLightChunkBase::editSFHasColor(void)
{
    editSField(HasColorFieldMask);

    return &_sfHasColor;
}

const SFBool *MultiLightChunkBase::getSFHasColor(void) const
{
    return &_sfHasColor;
}


SFBool *MultiLightChunkBase::editSFHasIntensity(void)
{
    editSField(HasIntensityFieldMask);

    return &_sfHasIntensity;
}

const SFBool *MultiLightChunkBase::getSFHasIntensity(void) const
{
    return &_sfHasIntensity;
}


SFBool *MultiLightChunkBase::editSFHasSeparateIntensities(void)
{
    editSField(HasSeparateIntensitiesFieldMask);

    return &_sfHasSeparateIntensities;
}

const SFBool *MultiLightChunkBase::getSFHasSeparateIntensities(void) const
{
    return &_sfHasSeparateIntensities;
}


SFBool *MultiLightChunkBase::editSFHasAttenuation(void)
{
    editSField(HasAttenuationFieldMask);

    return &_sfHasAttenuation;
}

const SFBool *MultiLightChunkBase::getSFHasAttenuation(void) const
{
    return &_sfHasAttenuation;
}


SFBool *MultiLightChunkBase::editSFAutoCalcRanges(void)
{
    editSField(AutoCalcRangesFieldMask);

    return &_sfAutoCalcRanges;
}

const SFBool *MultiLightChunkBase::getSFAutoCalcRanges(void) const
{
    return &_sfAutoCalcRanges;
}


SFBool *MultiLightChunkBase::editSFHasRangeCutOn(void)
{
    editSField(HasRangeCutOnFieldMask);

    return &_sfHasRangeCutOn;
}

const SFBool *MultiLightChunkBase::getSFHasRangeCutOn(void) const
{
    return &_sfHasRangeCutOn;
}


SFBool *MultiLightChunkBase::editSFHasRangeCutOff(void)
{
    editSField(HasRangeCutOffFieldMask);

    return &_sfHasRangeCutOff;
}

const SFBool *MultiLightChunkBase::getSFHasRangeCutOff(void) const
{
    return &_sfHasRangeCutOff;
}


SFBool *MultiLightChunkBase::editSFHasRangeNearZone(void)
{
    editSField(HasRangeNearZoneFieldMask);

    return &_sfHasRangeNearZone;
}

const SFBool *MultiLightChunkBase::getSFHasRangeNearZone(void) const
{
    return &_sfHasRangeNearZone;
}


SFBool *MultiLightChunkBase::editSFHasRangeFarZone(void)
{
    editSField(HasRangeFarZoneFieldMask);

    return &_sfHasRangeFarZone;
}

const SFBool *MultiLightChunkBase::getSFHasRangeFarZone(void) const
{
    return &_sfHasRangeFarZone;
}


SFBool *MultiLightChunkBase::editSFHasCosSpotlightAngle(void)
{
    editSField(HasCosSpotlightAngleFieldMask);

    return &_sfHasCosSpotlightAngle;
}

const SFBool *MultiLightChunkBase::getSFHasCosSpotlightAngle(void) const
{
    return &_sfHasCosSpotlightAngle;
}


SFBool *MultiLightChunkBase::editSFHasSpotlightAngle(void)
{
    editSField(HasSpotlightAngleFieldMask);

    return &_sfHasSpotlightAngle;
}

const SFBool *MultiLightChunkBase::getSFHasSpotlightAngle(void) const
{
    return &_sfHasSpotlightAngle;
}


SFBool *MultiLightChunkBase::editSFHasSpotExponent(void)
{
    editSField(HasSpotExponentFieldMask);

    return &_sfHasSpotExponent;
}

const SFBool *MultiLightChunkBase::getSFHasSpotExponent(void) const
{
    return &_sfHasSpotExponent;
}


SFBool *MultiLightChunkBase::editSFHasCinemaLight(void)
{
    editSField(HasCinemaLightFieldMask);

    return &_sfHasCinemaLight;
}

const SFBool *MultiLightChunkBase::getSFHasCinemaLight(void) const
{
    return &_sfHasCinemaLight;
}


MFPnt3f *MultiLightChunkBase::editMFPosition(void)
{
    editMField(PositionFieldMask, _mfPosition);

    return &_mfPosition;
}

const MFPnt3f *MultiLightChunkBase::getMFPosition(void) const
{
    return &_mfPosition;
}


MFVec3f *MultiLightChunkBase::editMFDirection(void)
{
    editMField(DirectionFieldMask, _mfDirection);

    return &_mfDirection;
}

const MFVec3f *MultiLightChunkBase::getMFDirection(void) const
{
    return &_mfDirection;
}


MFColor3f *MultiLightChunkBase::editMFColor(void)
{
    editMField(ColorFieldMask, _mfColor);

    return &_mfColor;
}

const MFColor3f *MultiLightChunkBase::getMFColor(void) const
{
    return &_mfColor;
}


MFReal32 *MultiLightChunkBase::editMFIntensity(void)
{
    editMField(IntensityFieldMask, _mfIntensity);

    return &_mfIntensity;
}

const MFReal32 *MultiLightChunkBase::getMFIntensity(void) const
{
    return &_mfIntensity;
}


MFVec3f *MultiLightChunkBase::editMFAmbientIntensity(void)
{
    editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);

    return &_mfAmbientIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFAmbientIntensity(void) const
{
    return &_mfAmbientIntensity;
}


MFVec3f *MultiLightChunkBase::editMFDiffuseIntensity(void)
{
    editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);

    return &_mfDiffuseIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFDiffuseIntensity(void) const
{
    return &_mfDiffuseIntensity;
}


MFVec3f *MultiLightChunkBase::editMFSpecularIntensity(void)
{
    editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);

    return &_mfSpecularIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFSpecularIntensity(void) const
{
    return &_mfSpecularIntensity;
}


MFVec3f *MultiLightChunkBase::editMFAttenuation(void)
{
    editMField(AttenuationFieldMask, _mfAttenuation);

    return &_mfAttenuation;
}

const MFVec3f *MultiLightChunkBase::getMFAttenuation(void) const
{
    return &_mfAttenuation;
}


MFReal32 *MultiLightChunkBase::editMFSpotlightAngle(void)
{
    editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);

    return &_mfSpotlightAngle;
}

const MFReal32 *MultiLightChunkBase::getMFSpotlightAngle(void) const
{
    return &_mfSpotlightAngle;
}


MFReal32 *MultiLightChunkBase::editMFSpotExponent(void)
{
    editMField(SpotExponentFieldMask, _mfSpotExponent);

    return &_mfSpotExponent;
}

const MFReal32 *MultiLightChunkBase::getMFSpotExponent(void) const
{
    return &_mfSpotExponent;
}


MFReal32 *MultiLightChunkBase::editMFInnerSuperEllipsesWidth(void)
{
    editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);

    return &_mfInnerSuperEllipsesWidth;
}

const MFReal32 *MultiLightChunkBase::getMFInnerSuperEllipsesWidth(void) const
{
    return &_mfInnerSuperEllipsesWidth;
}


MFReal32 *MultiLightChunkBase::editMFInnerSuperEllipsesHeight(void)
{
    editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);

    return &_mfInnerSuperEllipsesHeight;
}

const MFReal32 *MultiLightChunkBase::getMFInnerSuperEllipsesHeight(void) const
{
    return &_mfInnerSuperEllipsesHeight;
}


MFReal32 *MultiLightChunkBase::editMFOuterSuperEllipsesWidth(void)
{
    editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);

    return &_mfOuterSuperEllipsesWidth;
}

const MFReal32 *MultiLightChunkBase::getMFOuterSuperEllipsesWidth(void) const
{
    return &_mfOuterSuperEllipsesWidth;
}


MFReal32 *MultiLightChunkBase::editMFOuterSuperEllipsesHeight(void)
{
    editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);

    return &_mfOuterSuperEllipsesHeight;
}

const MFReal32 *MultiLightChunkBase::getMFOuterSuperEllipsesHeight(void) const
{
    return &_mfOuterSuperEllipsesHeight;
}


MFReal32 *MultiLightChunkBase::editMFSuperEllipsesRoundness(void)
{
    editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);

    return &_mfSuperEllipsesRoundness;
}

const MFReal32 *MultiLightChunkBase::getMFSuperEllipsesRoundness(void) const
{
    return &_mfSuperEllipsesRoundness;
}


MFReal32 *MultiLightChunkBase::editMFSuperEllipsesTwist(void)
{
    editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);

    return &_mfSuperEllipsesTwist;
}

const MFReal32 *MultiLightChunkBase::getMFSuperEllipsesTwist(void) const
{
    return &_mfSuperEllipsesTwist;
}


MFReal32 *MultiLightChunkBase::editMFRangeCutOn(void)
{
    editMField(RangeCutOnFieldMask, _mfRangeCutOn);

    return &_mfRangeCutOn;
}

const MFReal32 *MultiLightChunkBase::getMFRangeCutOn(void) const
{
    return &_mfRangeCutOn;
}


MFReal32 *MultiLightChunkBase::editMFRangeCutOff(void)
{
    editMField(RangeCutOffFieldMask, _mfRangeCutOff);

    return &_mfRangeCutOff;
}

const MFReal32 *MultiLightChunkBase::getMFRangeCutOff(void) const
{
    return &_mfRangeCutOff;
}


MFReal32 *MultiLightChunkBase::editMFRangeNearZone(void)
{
    editMField(RangeNearZoneFieldMask, _mfRangeNearZone);

    return &_mfRangeNearZone;
}

const MFReal32 *MultiLightChunkBase::getMFRangeNearZone(void) const
{
    return &_mfRangeNearZone;
}


MFReal32 *MultiLightChunkBase::editMFRangeFarZone(void)
{
    editMField(RangeFarZoneFieldMask, _mfRangeFarZone);

    return &_mfRangeFarZone;
}

const MFReal32 *MultiLightChunkBase::getMFRangeFarZone(void) const
{
    return &_mfRangeFarZone;
}


MFUInt8 *MultiLightChunkBase::editMFType(void)
{
    editMField(TypeFieldMask, _mfType);

    return &_mfType;
}

const MFUInt8 *MultiLightChunkBase::getMFType(void) const
{
    return &_mfType;
}


MFBool *MultiLightChunkBase::editMFEnabled(void)
{
    editMField(EnabledFieldMask, _mfEnabled);

    return &_mfEnabled;
}

const MFBool *MultiLightChunkBase::getMFEnabled(void) const
{
    return &_mfEnabled;
}


//! Get the MultiLightChunk::_mfBeacon field.
const MFWeakNodePtr *MultiLightChunkBase::getMFBeacon(void) const
{
    return &_mfBeacon;
}

MFWeakNodePtr       *MultiLightChunkBase::editMFBeacon         (void)
{
    editMField(BeaconFieldMask, _mfBeacon);

    return &_mfBeacon;
}
Node * MultiLightChunkBase::getBeacon(const UInt32 index) const
{
    return _mfBeacon[index];
}

MFMatrix *MultiLightChunkBase::editMFBeaconMatrix(void)
{
    editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);

    return &_mfBeaconMatrix;
}

const MFMatrix *MultiLightChunkBase::getMFBeaconMatrix(void) const
{
    return &_mfBeaconMatrix;
}


SFBool *MultiLightChunkBase::editSFEyeSpace(void)
{
    editSField(EyeSpaceFieldMask);

    return &_sfEyeSpace;
}

const SFBool *MultiLightChunkBase::getSFEyeSpace(void) const
{
    return &_sfEyeSpace;
}


SFReal32 *MultiLightChunkBase::editSFLastCamNear(void)
{
    editSField(LastCamNearFieldMask);

    return &_sfLastCamNear;
}

const SFReal32 *MultiLightChunkBase::getSFLastCamNear(void) const
{
    return &_sfLastCamNear;
}


SFReal32 *MultiLightChunkBase::editSFLastCamFar(void)
{
    editSField(LastCamFarFieldMask);

    return &_sfLastCamFar;
}

const SFReal32 *MultiLightChunkBase::getSFLastCamFar(void) const
{
    return &_sfLastCamFar;
}


SFMatrix *MultiLightChunkBase::editSFLastCamToWorld(void)
{
    editSField(LastCamToWorldFieldMask);

    return &_sfLastCamToWorld;
}

const SFMatrix *MultiLightChunkBase::getSFLastCamToWorld(void) const
{
    return &_sfLastCamToWorld;
}


SFString *MultiLightChunkBase::editSFLightBlockName(void)
{
    editSField(LightBlockNameFieldMask);

    return &_sfLightBlockName;
}

const SFString *MultiLightChunkBase::getSFLightBlockName(void) const
{
    return &_sfLightBlockName;
}


SFString *MultiLightChunkBase::editSFLightVariableName(void)
{
    editSField(LightVariableNameFieldMask);

    return &_sfLightVariableName;
}

const SFString *MultiLightChunkBase::getSFLightVariableName(void) const
{
    return &_sfLightVariableName;
}




void MultiLightChunkBase::pushToBeacon(Node * const value)
{
    editMField(BeaconFieldMask, _mfBeacon);

    _mfBeacon.push_back(value);
}

void MultiLightChunkBase::assignBeacon   (const MFWeakNodePtr     &value)
{
    MFWeakNodePtr    ::const_iterator elemIt  =
        value.begin();
    MFWeakNodePtr    ::const_iterator elemEnd =
        value.end  ();

    static_cast<MultiLightChunk *>(this)->clearBeacon();

    while(elemIt != elemEnd)
    {
        this->pushToBeacon(*elemIt);

        ++elemIt;
    }
}

void MultiLightChunkBase::removeFromBeacon(UInt32 uiIndex)
{
    if(uiIndex < _mfBeacon.size())
    {
        editMField(BeaconFieldMask, _mfBeacon);

        _mfBeacon.erase(uiIndex);
    }
}

void MultiLightChunkBase::removeObjFromBeacon(Node * const value)
{
    Int32 iElemIdx = _mfBeacon.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(BeaconFieldMask, _mfBeacon);

        _mfBeacon.erase(iElemIdx);
    }
}
void MultiLightChunkBase::clearBeacon(void)
{
    editMField(BeaconFieldMask, _mfBeacon);


    _mfBeacon.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT MultiLightChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (HasWorldToLightSpaceMatrixFieldMask & whichField))
    {
        returnValue += _sfHasWorldToLightSpaceMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasLightToWorldSpaceMatrixFieldMask & whichField))
    {
        returnValue += _sfHasLightToWorldSpaceMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasEyeToLightSpaceMatrixFieldMask & whichField))
    {
        returnValue += _sfHasEyeToLightSpaceMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasLightToEyeSpaceMatrixFieldMask & whichField))
    {
        returnValue += _sfHasLightToEyeSpaceMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasLightPerspectiveMatrixFieldMask & whichField))
    {
        returnValue += _sfHasLightPerspectiveMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasInvLightPerspectiveMatrixFieldMask & whichField))
    {
        returnValue += _sfHasInvLightPerspectiveMatrix.getBinSize();
    }
    if(FieldBits::NoField != (HasColorFieldMask & whichField))
    {
        returnValue += _sfHasColor.getBinSize();
    }
    if(FieldBits::NoField != (HasIntensityFieldMask & whichField))
    {
        returnValue += _sfHasIntensity.getBinSize();
    }
    if(FieldBits::NoField != (HasSeparateIntensitiesFieldMask & whichField))
    {
        returnValue += _sfHasSeparateIntensities.getBinSize();
    }
    if(FieldBits::NoField != (HasAttenuationFieldMask & whichField))
    {
        returnValue += _sfHasAttenuation.getBinSize();
    }
    if(FieldBits::NoField != (AutoCalcRangesFieldMask & whichField))
    {
        returnValue += _sfAutoCalcRanges.getBinSize();
    }
    if(FieldBits::NoField != (HasRangeCutOnFieldMask & whichField))
    {
        returnValue += _sfHasRangeCutOn.getBinSize();
    }
    if(FieldBits::NoField != (HasRangeCutOffFieldMask & whichField))
    {
        returnValue += _sfHasRangeCutOff.getBinSize();
    }
    if(FieldBits::NoField != (HasRangeNearZoneFieldMask & whichField))
    {
        returnValue += _sfHasRangeNearZone.getBinSize();
    }
    if(FieldBits::NoField != (HasRangeFarZoneFieldMask & whichField))
    {
        returnValue += _sfHasRangeFarZone.getBinSize();
    }
    if(FieldBits::NoField != (HasCosSpotlightAngleFieldMask & whichField))
    {
        returnValue += _sfHasCosSpotlightAngle.getBinSize();
    }
    if(FieldBits::NoField != (HasSpotlightAngleFieldMask & whichField))
    {
        returnValue += _sfHasSpotlightAngle.getBinSize();
    }
    if(FieldBits::NoField != (HasSpotExponentFieldMask & whichField))
    {
        returnValue += _sfHasSpotExponent.getBinSize();
    }
    if(FieldBits::NoField != (HasCinemaLightFieldMask & whichField))
    {
        returnValue += _sfHasCinemaLight.getBinSize();
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        returnValue += _mfPosition.getBinSize();
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        returnValue += _mfDirection.getBinSize();
    }
    if(FieldBits::NoField != (ColorFieldMask & whichField))
    {
        returnValue += _mfColor.getBinSize();
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        returnValue += _mfIntensity.getBinSize();
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        returnValue += _mfAmbientIntensity.getBinSize();
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        returnValue += _mfDiffuseIntensity.getBinSize();
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        returnValue += _mfSpecularIntensity.getBinSize();
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        returnValue += _mfAttenuation.getBinSize();
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        returnValue += _mfSpotlightAngle.getBinSize();
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        returnValue += _mfSpotExponent.getBinSize();
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        returnValue += _mfInnerSuperEllipsesWidth.getBinSize();
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        returnValue += _mfInnerSuperEllipsesHeight.getBinSize();
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        returnValue += _mfOuterSuperEllipsesWidth.getBinSize();
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        returnValue += _mfOuterSuperEllipsesHeight.getBinSize();
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        returnValue += _mfSuperEllipsesRoundness.getBinSize();
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        returnValue += _mfSuperEllipsesTwist.getBinSize();
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        returnValue += _mfRangeCutOn.getBinSize();
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        returnValue += _mfRangeCutOff.getBinSize();
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        returnValue += _mfRangeNearZone.getBinSize();
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        returnValue += _mfRangeFarZone.getBinSize();
    }
    if(FieldBits::NoField != (TypeFieldMask & whichField))
    {
        returnValue += _mfType.getBinSize();
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        returnValue += _mfEnabled.getBinSize();
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        returnValue += _mfBeacon.getBinSize();
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        returnValue += _mfBeaconMatrix.getBinSize();
    }
    if(FieldBits::NoField != (EyeSpaceFieldMask & whichField))
    {
        returnValue += _sfEyeSpace.getBinSize();
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        returnValue += _sfLastCamNear.getBinSize();
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        returnValue += _sfLastCamFar.getBinSize();
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        returnValue += _sfLastCamToWorld.getBinSize();
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        returnValue += _sfLightBlockName.getBinSize();
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        returnValue += _sfLightVariableName.getBinSize();
    }

    return returnValue;
}

void MultiLightChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (HasWorldToLightSpaceMatrixFieldMask & whichField))
    {
        _sfHasWorldToLightSpaceMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasLightToWorldSpaceMatrixFieldMask & whichField))
    {
        _sfHasLightToWorldSpaceMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasEyeToLightSpaceMatrixFieldMask & whichField))
    {
        _sfHasEyeToLightSpaceMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasLightToEyeSpaceMatrixFieldMask & whichField))
    {
        _sfHasLightToEyeSpaceMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasLightPerspectiveMatrixFieldMask & whichField))
    {
        _sfHasLightPerspectiveMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasInvLightPerspectiveMatrixFieldMask & whichField))
    {
        _sfHasInvLightPerspectiveMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasColorFieldMask & whichField))
    {
        _sfHasColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasIntensityFieldMask & whichField))
    {
        _sfHasIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasSeparateIntensitiesFieldMask & whichField))
    {
        _sfHasSeparateIntensities.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasAttenuationFieldMask & whichField))
    {
        _sfHasAttenuation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoCalcRangesFieldMask & whichField))
    {
        _sfAutoCalcRanges.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeCutOnFieldMask & whichField))
    {
        _sfHasRangeCutOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeCutOffFieldMask & whichField))
    {
        _sfHasRangeCutOff.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeNearZoneFieldMask & whichField))
    {
        _sfHasRangeNearZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeFarZoneFieldMask & whichField))
    {
        _sfHasRangeFarZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasCosSpotlightAngleFieldMask & whichField))
    {
        _sfHasCosSpotlightAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasSpotlightAngleFieldMask & whichField))
    {
        _sfHasSpotlightAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasSpotExponentFieldMask & whichField))
    {
        _sfHasSpotExponent.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasCinemaLightFieldMask & whichField))
    {
        _sfHasCinemaLight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        _mfPosition.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        _mfDirection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorFieldMask & whichField))
    {
        _mfColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        _mfIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        _mfAmbientIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        _mfDiffuseIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        _mfSpecularIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        _mfAttenuation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        _mfSpotlightAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        _mfSpotExponent.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        _mfInnerSuperEllipsesWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        _mfInnerSuperEllipsesHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        _mfOuterSuperEllipsesWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        _mfOuterSuperEllipsesHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        _mfSuperEllipsesRoundness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        _mfSuperEllipsesTwist.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        _mfRangeCutOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        _mfRangeCutOff.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        _mfRangeNearZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        _mfRangeFarZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TypeFieldMask & whichField))
    {
        _mfType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        _mfEnabled.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        _mfBeacon.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        _mfBeaconMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EyeSpaceFieldMask & whichField))
    {
        _sfEyeSpace.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        _sfLastCamNear.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        _sfLastCamFar.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        _sfLastCamToWorld.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        _sfLightBlockName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        _sfLightVariableName.copyToBin(pMem);
    }
}

void MultiLightChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (HasWorldToLightSpaceMatrixFieldMask & whichField))
    {
        editSField(HasWorldToLightSpaceMatrixFieldMask);
        _sfHasWorldToLightSpaceMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasLightToWorldSpaceMatrixFieldMask & whichField))
    {
        editSField(HasLightToWorldSpaceMatrixFieldMask);
        _sfHasLightToWorldSpaceMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasEyeToLightSpaceMatrixFieldMask & whichField))
    {
        editSField(HasEyeToLightSpaceMatrixFieldMask);
        _sfHasEyeToLightSpaceMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasLightToEyeSpaceMatrixFieldMask & whichField))
    {
        editSField(HasLightToEyeSpaceMatrixFieldMask);
        _sfHasLightToEyeSpaceMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasLightPerspectiveMatrixFieldMask & whichField))
    {
        editSField(HasLightPerspectiveMatrixFieldMask);
        _sfHasLightPerspectiveMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasInvLightPerspectiveMatrixFieldMask & whichField))
    {
        editSField(HasInvLightPerspectiveMatrixFieldMask);
        _sfHasInvLightPerspectiveMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasColorFieldMask & whichField))
    {
        editSField(HasColorFieldMask);
        _sfHasColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasIntensityFieldMask & whichField))
    {
        editSField(HasIntensityFieldMask);
        _sfHasIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasSeparateIntensitiesFieldMask & whichField))
    {
        editSField(HasSeparateIntensitiesFieldMask);
        _sfHasSeparateIntensities.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasAttenuationFieldMask & whichField))
    {
        editSField(HasAttenuationFieldMask);
        _sfHasAttenuation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoCalcRangesFieldMask & whichField))
    {
        editSField(AutoCalcRangesFieldMask);
        _sfAutoCalcRanges.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeCutOnFieldMask & whichField))
    {
        editSField(HasRangeCutOnFieldMask);
        _sfHasRangeCutOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeCutOffFieldMask & whichField))
    {
        editSField(HasRangeCutOffFieldMask);
        _sfHasRangeCutOff.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeNearZoneFieldMask & whichField))
    {
        editSField(HasRangeNearZoneFieldMask);
        _sfHasRangeNearZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasRangeFarZoneFieldMask & whichField))
    {
        editSField(HasRangeFarZoneFieldMask);
        _sfHasRangeFarZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasCosSpotlightAngleFieldMask & whichField))
    {
        editSField(HasCosSpotlightAngleFieldMask);
        _sfHasCosSpotlightAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasSpotlightAngleFieldMask & whichField))
    {
        editSField(HasSpotlightAngleFieldMask);
        _sfHasSpotlightAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasSpotExponentFieldMask & whichField))
    {
        editSField(HasSpotExponentFieldMask);
        _sfHasSpotExponent.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasCinemaLightFieldMask & whichField))
    {
        editSField(HasCinemaLightFieldMask);
        _sfHasCinemaLight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        editMField(PositionFieldMask, _mfPosition);
        _mfPosition.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        editMField(DirectionFieldMask, _mfDirection);
        _mfDirection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorFieldMask & whichField))
    {
        editMField(ColorFieldMask, _mfColor);
        _mfColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        editMField(IntensityFieldMask, _mfIntensity);
        _mfIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);
        _mfAmbientIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);
        _mfDiffuseIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);
        _mfSpecularIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        editMField(AttenuationFieldMask, _mfAttenuation);
        _mfAttenuation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);
        _mfSpotlightAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        editMField(SpotExponentFieldMask, _mfSpotExponent);
        _mfSpotExponent.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);
        _mfInnerSuperEllipsesWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);
        _mfInnerSuperEllipsesHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);
        _mfOuterSuperEllipsesWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);
        _mfOuterSuperEllipsesHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);
        _mfSuperEllipsesRoundness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);
        _mfSuperEllipsesTwist.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        editMField(RangeCutOnFieldMask, _mfRangeCutOn);
        _mfRangeCutOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        editMField(RangeCutOffFieldMask, _mfRangeCutOff);
        _mfRangeCutOff.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        editMField(RangeNearZoneFieldMask, _mfRangeNearZone);
        _mfRangeNearZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        editMField(RangeFarZoneFieldMask, _mfRangeFarZone);
        _mfRangeFarZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TypeFieldMask & whichField))
    {
        editMField(TypeFieldMask, _mfType);
        _mfType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        editMField(EnabledFieldMask, _mfEnabled);
        _mfEnabled.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        editMField(BeaconFieldMask, _mfBeacon);
        _mfBeacon.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);
        _mfBeaconMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EyeSpaceFieldMask & whichField))
    {
        editSField(EyeSpaceFieldMask);
        _sfEyeSpace.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        editSField(LastCamNearFieldMask);
        _sfLastCamNear.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        editSField(LastCamFarFieldMask);
        _sfLastCamFar.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        editSField(LastCamToWorldFieldMask);
        _sfLastCamToWorld.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        editSField(LightBlockNameFieldMask);
        _sfLightBlockName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        editSField(LightVariableNameFieldMask);
        _sfLightVariableName.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MultiLightChunkTransitPtr MultiLightChunkBase::createLocal(BitVector bFlags)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MultiLightChunkTransitPtr MultiLightChunkBase::createDependent(BitVector bFlags)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MultiLightChunkTransitPtr MultiLightChunkBase::create(void)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

MultiLightChunk *MultiLightChunkBase::createEmptyLocal(BitVector bFlags)
{
    MultiLightChunk *returnValue;

    newPtr<MultiLightChunk>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MultiLightChunk *MultiLightChunkBase::createEmpty(void)
{
    MultiLightChunk *returnValue;

    newPtr<MultiLightChunk>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MultiLightChunkBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightChunk *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightChunkBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightChunk *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightChunkBase::shallowCopy(void) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MultiLightChunk *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MultiLightChunkBase::MultiLightChunkBase(void) :
    Inherited(),
    _sfHasWorldToLightSpaceMatrix(bool(false)),
    _sfHasLightToWorldSpaceMatrix(bool(false)),
    _sfHasEyeToLightSpaceMatrix(bool(false)),
    _sfHasLightToEyeSpaceMatrix(bool(false)),
    _sfHasLightPerspectiveMatrix(bool(false)),
    _sfHasInvLightPerspectiveMatrix(bool(false)),
    _sfHasColor               (bool(false)),
    _sfHasIntensity           (bool(false)),
    _sfHasSeparateIntensities (bool(true)),
    _sfHasAttenuation         (bool(true)),
    _sfAutoCalcRanges         (bool(true)),
    _sfHasRangeCutOn          (bool(false)),
    _sfHasRangeCutOff         (bool(false)),
    _sfHasRangeNearZone       (bool(false)),
    _sfHasRangeFarZone        (bool(false)),
    _sfHasCosSpotlightAngle   (bool(true)),
    _sfHasSpotlightAngle      (bool(false)),
    _sfHasSpotExponent        (bool(true)),
    _sfHasCinemaLight         (bool(false)),
    _mfPosition               (),
    _mfDirection              (),
    _mfColor                  (),
    _mfIntensity              (),
    _mfAmbientIntensity       (),
    _mfDiffuseIntensity       (),
    _mfSpecularIntensity      (),
    _mfAttenuation            (),
    _mfSpotlightAngle         (),
    _mfSpotExponent           (),
    _mfInnerSuperEllipsesWidth(),
    _mfInnerSuperEllipsesHeight(),
    _mfOuterSuperEllipsesWidth(),
    _mfOuterSuperEllipsesHeight(),
    _mfSuperEllipsesRoundness (),
    _mfSuperEllipsesTwist     (),
    _mfRangeCutOn             (),
    _mfRangeCutOff            (),
    _mfRangeNearZone          (),
    _mfRangeFarZone           (),
    _mfType                   (),
    _mfEnabled                (),
    _mfBeacon                 (),
    _mfBeaconMatrix           (),
    _sfEyeSpace               (bool(false)),
    _sfLastCamNear            (Real32(0.f)),
    _sfLastCamFar             (Real32(0.f)),
    _sfLastCamToWorld         (),
    _sfLightBlockName         (std::string("Lights")),
    _sfLightVariableName      (std::string("lights"))
{
}

MultiLightChunkBase::MultiLightChunkBase(const MultiLightChunkBase &source) :
    Inherited(source),
    _sfHasWorldToLightSpaceMatrix(source._sfHasWorldToLightSpaceMatrix),
    _sfHasLightToWorldSpaceMatrix(source._sfHasLightToWorldSpaceMatrix),
    _sfHasEyeToLightSpaceMatrix(source._sfHasEyeToLightSpaceMatrix),
    _sfHasLightToEyeSpaceMatrix(source._sfHasLightToEyeSpaceMatrix),
    _sfHasLightPerspectiveMatrix(source._sfHasLightPerspectiveMatrix),
    _sfHasInvLightPerspectiveMatrix(source._sfHasInvLightPerspectiveMatrix),
    _sfHasColor               (source._sfHasColor               ),
    _sfHasIntensity           (source._sfHasIntensity           ),
    _sfHasSeparateIntensities (source._sfHasSeparateIntensities ),
    _sfHasAttenuation         (source._sfHasAttenuation         ),
    _sfAutoCalcRanges         (source._sfAutoCalcRanges         ),
    _sfHasRangeCutOn          (source._sfHasRangeCutOn          ),
    _sfHasRangeCutOff         (source._sfHasRangeCutOff         ),
    _sfHasRangeNearZone       (source._sfHasRangeNearZone       ),
    _sfHasRangeFarZone        (source._sfHasRangeFarZone        ),
    _sfHasCosSpotlightAngle   (source._sfHasCosSpotlightAngle   ),
    _sfHasSpotlightAngle      (source._sfHasSpotlightAngle      ),
    _sfHasSpotExponent        (source._sfHasSpotExponent        ),
    _sfHasCinemaLight         (source._sfHasCinemaLight         ),
    _mfPosition               (source._mfPosition               ),
    _mfDirection              (source._mfDirection              ),
    _mfColor                  (source._mfColor                  ),
    _mfIntensity              (source._mfIntensity              ),
    _mfAmbientIntensity       (source._mfAmbientIntensity       ),
    _mfDiffuseIntensity       (source._mfDiffuseIntensity       ),
    _mfSpecularIntensity      (source._mfSpecularIntensity      ),
    _mfAttenuation            (source._mfAttenuation            ),
    _mfSpotlightAngle         (source._mfSpotlightAngle         ),
    _mfSpotExponent           (source._mfSpotExponent           ),
    _mfInnerSuperEllipsesWidth(source._mfInnerSuperEllipsesWidth),
    _mfInnerSuperEllipsesHeight(source._mfInnerSuperEllipsesHeight),
    _mfOuterSuperEllipsesWidth(source._mfOuterSuperEllipsesWidth),
    _mfOuterSuperEllipsesHeight(source._mfOuterSuperEllipsesHeight),
    _mfSuperEllipsesRoundness (source._mfSuperEllipsesRoundness ),
    _mfSuperEllipsesTwist     (source._mfSuperEllipsesTwist     ),
    _mfRangeCutOn             (source._mfRangeCutOn             ),
    _mfRangeCutOff            (source._mfRangeCutOff            ),
    _mfRangeNearZone          (source._mfRangeNearZone          ),
    _mfRangeFarZone           (source._mfRangeFarZone           ),
    _mfType                   (source._mfType                   ),
    _mfEnabled                (source._mfEnabled                ),
    _mfBeacon                 (),
    _mfBeaconMatrix           (source._mfBeaconMatrix           ),
    _sfEyeSpace               (source._sfEyeSpace               ),
    _sfLastCamNear            (source._sfLastCamNear            ),
    _sfLastCamFar             (source._sfLastCamFar             ),
    _sfLastCamToWorld         (source._sfLastCamToWorld         ),
    _sfLightBlockName         (source._sfLightBlockName         ),
    _sfLightVariableName      (source._sfLightVariableName      )
{
}


/*-------------------------- destructors ----------------------------------*/

MultiLightChunkBase::~MultiLightChunkBase(void)
{
}

void MultiLightChunkBase::onCreate(const MultiLightChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        MultiLightChunk *pThis = static_cast<MultiLightChunk *>(this);

        MFWeakNodePtr::const_iterator BeaconIt  =
            source->_mfBeacon.begin();
        MFWeakNodePtr::const_iterator BeaconEnd =
            source->_mfBeacon.end  ();

        while(BeaconIt != BeaconEnd)
        {
            pThis->pushToBeacon(*BeaconIt);

            ++BeaconIt;
        }
    }
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasWorldToLightSpaceMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasWorldToLightSpaceMatrix,
             this->getType().getFieldDesc(HasWorldToLightSpaceMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasWorldToLightSpaceMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasWorldToLightSpaceMatrix,
             this->getType().getFieldDesc(HasWorldToLightSpaceMatrixFieldId),
             this));


    editSField(HasWorldToLightSpaceMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasLightToWorldSpaceMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasLightToWorldSpaceMatrix,
             this->getType().getFieldDesc(HasLightToWorldSpaceMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasLightToWorldSpaceMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasLightToWorldSpaceMatrix,
             this->getType().getFieldDesc(HasLightToWorldSpaceMatrixFieldId),
             this));


    editSField(HasLightToWorldSpaceMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasEyeToLightSpaceMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasEyeToLightSpaceMatrix,
             this->getType().getFieldDesc(HasEyeToLightSpaceMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasEyeToLightSpaceMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasEyeToLightSpaceMatrix,
             this->getType().getFieldDesc(HasEyeToLightSpaceMatrixFieldId),
             this));


    editSField(HasEyeToLightSpaceMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasLightToEyeSpaceMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasLightToEyeSpaceMatrix,
             this->getType().getFieldDesc(HasLightToEyeSpaceMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasLightToEyeSpaceMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasLightToEyeSpaceMatrix,
             this->getType().getFieldDesc(HasLightToEyeSpaceMatrixFieldId),
             this));


    editSField(HasLightToEyeSpaceMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasLightPerspectiveMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasLightPerspectiveMatrix,
             this->getType().getFieldDesc(HasLightPerspectiveMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasLightPerspectiveMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasLightPerspectiveMatrix,
             this->getType().getFieldDesc(HasLightPerspectiveMatrixFieldId),
             this));


    editSField(HasLightPerspectiveMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasInvLightPerspectiveMatrix (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasInvLightPerspectiveMatrix,
             this->getType().getFieldDesc(HasInvLightPerspectiveMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasInvLightPerspectiveMatrix(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasInvLightPerspectiveMatrix,
             this->getType().getFieldDesc(HasInvLightPerspectiveMatrixFieldId),
             this));


    editSField(HasInvLightPerspectiveMatrixFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasColor        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasColor,
             this->getType().getFieldDesc(HasColorFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasColor       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasColor,
             this->getType().getFieldDesc(HasColorFieldId),
             this));


    editSField(HasColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasIntensity    (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasIntensity,
             this->getType().getFieldDesc(HasIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasIntensity   (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasIntensity,
             this->getType().getFieldDesc(HasIntensityFieldId),
             this));


    editSField(HasIntensityFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasSeparateIntensities (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasSeparateIntensities,
             this->getType().getFieldDesc(HasSeparateIntensitiesFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasSeparateIntensities(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasSeparateIntensities,
             this->getType().getFieldDesc(HasSeparateIntensitiesFieldId),
             this));


    editSField(HasSeparateIntensitiesFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasAttenuation  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasAttenuation,
             this->getType().getFieldDesc(HasAttenuationFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasAttenuation (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasAttenuation,
             this->getType().getFieldDesc(HasAttenuationFieldId),
             this));


    editSField(HasAttenuationFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleAutoCalcRanges  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoCalcRanges,
             this->getType().getFieldDesc(AutoCalcRangesFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleAutoCalcRanges (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoCalcRanges,
             this->getType().getFieldDesc(AutoCalcRangesFieldId),
             this));


    editSField(AutoCalcRangesFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasRangeCutOn   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasRangeCutOn,
             this->getType().getFieldDesc(HasRangeCutOnFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasRangeCutOn  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasRangeCutOn,
             this->getType().getFieldDesc(HasRangeCutOnFieldId),
             this));


    editSField(HasRangeCutOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasRangeCutOff  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasRangeCutOff,
             this->getType().getFieldDesc(HasRangeCutOffFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasRangeCutOff (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasRangeCutOff,
             this->getType().getFieldDesc(HasRangeCutOffFieldId),
             this));


    editSField(HasRangeCutOffFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasRangeNearZone (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasRangeNearZone,
             this->getType().getFieldDesc(HasRangeNearZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasRangeNearZone(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasRangeNearZone,
             this->getType().getFieldDesc(HasRangeNearZoneFieldId),
             this));


    editSField(HasRangeNearZoneFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasRangeFarZone (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasRangeFarZone,
             this->getType().getFieldDesc(HasRangeFarZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasRangeFarZone(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasRangeFarZone,
             this->getType().getFieldDesc(HasRangeFarZoneFieldId),
             this));


    editSField(HasRangeFarZoneFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasCosSpotlightAngle (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasCosSpotlightAngle,
             this->getType().getFieldDesc(HasCosSpotlightAngleFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasCosSpotlightAngle(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasCosSpotlightAngle,
             this->getType().getFieldDesc(HasCosSpotlightAngleFieldId),
             this));


    editSField(HasCosSpotlightAngleFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasSpotlightAngle (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasSpotlightAngle,
             this->getType().getFieldDesc(HasSpotlightAngleFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasSpotlightAngle(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasSpotlightAngle,
             this->getType().getFieldDesc(HasSpotlightAngleFieldId),
             this));


    editSField(HasSpotlightAngleFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasSpotExponent (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasSpotExponent,
             this->getType().getFieldDesc(HasSpotExponentFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasSpotExponent(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasSpotExponent,
             this->getType().getFieldDesc(HasSpotExponentFieldId),
             this));


    editSField(HasSpotExponentFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleHasCinemaLight  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasCinemaLight,
             this->getType().getFieldDesc(HasCinemaLightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleHasCinemaLight (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasCinemaLight,
             this->getType().getFieldDesc(HasCinemaLightFieldId),
             this));


    editSField(HasCinemaLightFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandlePosition        (void) const
{
    MFPnt3f::GetHandlePtr returnValue(
        new  MFPnt3f::GetHandle(
             &_mfPosition,
             this->getType().getFieldDesc(PositionFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandlePosition       (void)
{
    MFPnt3f::EditHandlePtr returnValue(
        new  MFPnt3f::EditHandle(
             &_mfPosition,
             this->getType().getFieldDesc(PositionFieldId),
             this));


    editMField(PositionFieldMask, _mfPosition);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleDirection       (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfDirection,
             this->getType().getFieldDesc(DirectionFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleDirection      (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfDirection,
             this->getType().getFieldDesc(DirectionFieldId),
             this));


    editMField(DirectionFieldMask, _mfDirection);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleColor           (void) const
{
    MFColor3f::GetHandlePtr returnValue(
        new  MFColor3f::GetHandle(
             &_mfColor,
             this->getType().getFieldDesc(ColorFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleColor          (void)
{
    MFColor3f::EditHandlePtr returnValue(
        new  MFColor3f::EditHandle(
             &_mfColor,
             this->getType().getFieldDesc(ColorFieldId),
             this));


    editMField(ColorFieldMask, _mfColor);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleIntensity       (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleIntensity      (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             this));


    editMField(IntensityFieldMask, _mfIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleAmbientIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfAmbientIntensity,
             this->getType().getFieldDesc(AmbientIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleAmbientIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfAmbientIntensity,
             this->getType().getFieldDesc(AmbientIntensityFieldId),
             this));


    editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleDiffuseIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfDiffuseIntensity,
             this->getType().getFieldDesc(DiffuseIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleDiffuseIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfDiffuseIntensity,
             this->getType().getFieldDesc(DiffuseIntensityFieldId),
             this));


    editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpecularIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfSpecularIntensity,
             this->getType().getFieldDesc(SpecularIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpecularIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfSpecularIntensity,
             this->getType().getFieldDesc(SpecularIntensityFieldId),
             this));


    editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleAttenuation     (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfAttenuation,
             this->getType().getFieldDesc(AttenuationFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleAttenuation    (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfAttenuation,
             this->getType().getFieldDesc(AttenuationFieldId),
             this));


    editMField(AttenuationFieldMask, _mfAttenuation);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpotlightAngle  (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSpotlightAngle,
             this->getType().getFieldDesc(SpotlightAngleFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpotlightAngle (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSpotlightAngle,
             this->getType().getFieldDesc(SpotlightAngleFieldId),
             this));


    editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpotExponent    (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSpotExponent,
             this->getType().getFieldDesc(SpotExponentFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpotExponent   (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSpotExponent,
             this->getType().getFieldDesc(SpotExponentFieldId),
             this));


    editMField(SpotExponentFieldMask, _mfSpotExponent);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleInnerSuperEllipsesWidth (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfInnerSuperEllipsesWidth,
             this->getType().getFieldDesc(InnerSuperEllipsesWidthFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleInnerSuperEllipsesWidth(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfInnerSuperEllipsesWidth,
             this->getType().getFieldDesc(InnerSuperEllipsesWidthFieldId),
             this));


    editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleInnerSuperEllipsesHeight (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfInnerSuperEllipsesHeight,
             this->getType().getFieldDesc(InnerSuperEllipsesHeightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleInnerSuperEllipsesHeight(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfInnerSuperEllipsesHeight,
             this->getType().getFieldDesc(InnerSuperEllipsesHeightFieldId),
             this));


    editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleOuterSuperEllipsesWidth (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfOuterSuperEllipsesWidth,
             this->getType().getFieldDesc(OuterSuperEllipsesWidthFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleOuterSuperEllipsesWidth(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfOuterSuperEllipsesWidth,
             this->getType().getFieldDesc(OuterSuperEllipsesWidthFieldId),
             this));


    editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleOuterSuperEllipsesHeight (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfOuterSuperEllipsesHeight,
             this->getType().getFieldDesc(OuterSuperEllipsesHeightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleOuterSuperEllipsesHeight(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfOuterSuperEllipsesHeight,
             this->getType().getFieldDesc(OuterSuperEllipsesHeightFieldId),
             this));


    editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSuperEllipsesRoundness (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSuperEllipsesRoundness,
             this->getType().getFieldDesc(SuperEllipsesRoundnessFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSuperEllipsesRoundness(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSuperEllipsesRoundness,
             this->getType().getFieldDesc(SuperEllipsesRoundnessFieldId),
             this));


    editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSuperEllipsesTwist (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSuperEllipsesTwist,
             this->getType().getFieldDesc(SuperEllipsesTwistFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSuperEllipsesTwist(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSuperEllipsesTwist,
             this->getType().getFieldDesc(SuperEllipsesTwistFieldId),
             this));


    editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeCutOn      (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeCutOn,
             this->getType().getFieldDesc(RangeCutOnFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeCutOn     (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeCutOn,
             this->getType().getFieldDesc(RangeCutOnFieldId),
             this));


    editMField(RangeCutOnFieldMask, _mfRangeCutOn);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeCutOff     (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeCutOff,
             this->getType().getFieldDesc(RangeCutOffFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeCutOff    (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeCutOff,
             this->getType().getFieldDesc(RangeCutOffFieldId),
             this));


    editMField(RangeCutOffFieldMask, _mfRangeCutOff);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeNearZone   (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeNearZone,
             this->getType().getFieldDesc(RangeNearZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeNearZone  (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeNearZone,
             this->getType().getFieldDesc(RangeNearZoneFieldId),
             this));


    editMField(RangeNearZoneFieldMask, _mfRangeNearZone);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeFarZone    (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeFarZone,
             this->getType().getFieldDesc(RangeFarZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeFarZone   (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeFarZone,
             this->getType().getFieldDesc(RangeFarZoneFieldId),
             this));


    editMField(RangeFarZoneFieldMask, _mfRangeFarZone);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleType            (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfType,
             this->getType().getFieldDesc(TypeFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleType           (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfType,
             this->getType().getFieldDesc(TypeFieldId),
             this));


    editMField(TypeFieldMask, _mfType);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleEnabled         (void) const
{
    MFBool::GetHandlePtr returnValue(
        new  MFBool::GetHandle(
             &_mfEnabled,
             this->getType().getFieldDesc(EnabledFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleEnabled        (void)
{
    MFBool::EditHandlePtr returnValue(
        new  MFBool::EditHandle(
             &_mfEnabled,
             this->getType().getFieldDesc(EnabledFieldId),
             this));


    editMField(EnabledFieldMask, _mfEnabled);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleBeacon          (void) const
{
    MFWeakNodePtr::GetHandlePtr returnValue(
        new  MFWeakNodePtr::GetHandle(
             &_mfBeacon,
             this->getType().getFieldDesc(BeaconFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleBeacon         (void)
{
    MFWeakNodePtr::EditHandlePtr returnValue(
        new  MFWeakNodePtr::EditHandle(
             &_mfBeacon,
             this->getType().getFieldDesc(BeaconFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&MultiLightChunk::pushToBeacon,
                    static_cast<MultiLightChunk *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&MultiLightChunk::removeFromBeacon,
                    static_cast<MultiLightChunk *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&MultiLightChunk::removeObjFromBeacon,
                    static_cast<MultiLightChunk *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&MultiLightChunk::clearBeacon,
                    static_cast<MultiLightChunk *>(this)));

    editMField(BeaconFieldMask, _mfBeacon);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleBeaconMatrix    (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfBeaconMatrix,
             this->getType().getFieldDesc(BeaconMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleBeaconMatrix   (void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfBeaconMatrix,
             this->getType().getFieldDesc(BeaconMatrixFieldId),
             this));


    editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleEyeSpace        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfEyeSpace,
             this->getType().getFieldDesc(EyeSpaceFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleEyeSpace       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfEyeSpace,
             this->getType().getFieldDesc(EyeSpaceFieldId),
             this));


    editSField(EyeSpaceFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamNear     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLastCamNear,
             this->getType().getFieldDesc(LastCamNearFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamNear    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLastCamNear,
             this->getType().getFieldDesc(LastCamNearFieldId),
             this));


    editSField(LastCamNearFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamFar      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLastCamFar,
             this->getType().getFieldDesc(LastCamFarFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamFar     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLastCamFar,
             this->getType().getFieldDesc(LastCamFarFieldId),
             this));


    editSField(LastCamFarFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamToWorld  (void) const
{
    SFMatrix::GetHandlePtr returnValue(
        new  SFMatrix::GetHandle(
             &_sfLastCamToWorld,
             this->getType().getFieldDesc(LastCamToWorldFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamToWorld (void)
{
    SFMatrix::EditHandlePtr returnValue(
        new  SFMatrix::EditHandle(
             &_sfLastCamToWorld,
             this->getType().getFieldDesc(LastCamToWorldFieldId),
             this));


    editSField(LastCamToWorldFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLightBlockName  (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfLightBlockName,
             this->getType().getFieldDesc(LightBlockNameFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLightBlockName (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfLightBlockName,
             this->getType().getFieldDesc(LightBlockNameFieldId),
             this));


    editSField(LightBlockNameFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLightVariableName (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfLightVariableName,
             this->getType().getFieldDesc(LightVariableNameFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLightVariableName(void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfLightVariableName,
             this->getType().getFieldDesc(LightVariableNameFieldId),
             this));


    editSField(LightVariableNameFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MultiLightChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MultiLightChunk *pThis = static_cast<MultiLightChunk *>(this);

    pThis->execSync(static_cast<MultiLightChunk *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MultiLightChunkBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MultiLightChunk *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MultiLightChunk *>(pRefAspect),
                  dynamic_cast<const MultiLightChunk *>(this));

    return returnValue;
}
#endif

void MultiLightChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<MultiLightChunk *>(this)->clearBeacon();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfPosition.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDirection.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfColor.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfAmbientIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDiffuseIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpecularIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfAttenuation.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpotlightAngle.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpotExponent.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfInnerSuperEllipsesWidth.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfInnerSuperEllipsesHeight.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfOuterSuperEllipsesWidth.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfOuterSuperEllipsesHeight.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSuperEllipsesRoundness.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSuperEllipsesTwist.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeCutOn.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeCutOff.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeNearZone.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeFarZone.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfType.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfEnabled.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfBeaconMatrix.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
